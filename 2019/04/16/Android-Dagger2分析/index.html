<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Android Dagger2分析 | 吾与尔</title>

  
  <meta name="author" content="brokge">
  

  
  <meta name="description" content="Dagger2官方地址 
参考博客地址
涉及的知识点注解依赖注入Dagger2 是一个依赖注入框架，依赖注入的目的就是为了给需求方在合适的时候注入依赖。@Inject@Inject 注解就如同一个标签，或者说它是一个记号，它是给 Dagger2 看的。它运用的地方有两处。

@Inject 给一个类">
  

  
  <meta name="keywords" content="吾与尔">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Android Dagger2分析">

  <meta property="og:site_name" content="吾与尔">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="吾与尔" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">吾与尔</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Android Dagger2分析</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/04/16/Android-Dagger2分析/" rel="bookmark">
        <time class="entry-date published" datetime="2019-04-16T13:01:11.000Z">
          2019-04-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Dagger2"><a href="#Dagger2" class="headerlink" title="Dagger2"></a>Dagger2</h1><p><a href="https://google.github.io/dagger/" target="_blank" rel="noopener">官方地址 </a></p>
<p><a href="https://blog.csdn.net/briblue/article/details/75578459" target="_blank" rel="noopener">参考博客地址</a></p>
<h2 id="涉及的知识点"><a href="#涉及的知识点" class="headerlink" title="涉及的知识点"></a>涉及的知识点</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>Dagger2 是一个依赖注入框架，依赖注入的目的就是为了给需求方在合适的时候注入依赖。<br><strong>@Inject</strong><br>@Inject 注解就如同一个标签，或者说它是一个记号，它是给 Dagger2 看的。它运用的地方有两处。</p>
<ul>
<li><p>@Inject 给一个类的相应的属性做标记时，说明了它是一个依赖需求方，需要一些依赖。</p>
</li>
<li><p>@Inject 给一个类的构造方法进行注解时，表明了它能提供依赖的能力。</p>
</li>
</ul>
<p>就这样，通过 @Inject 注解符号，就很容易标记依赖和它的需求方。但是，单单一个 @Inject 是不能让 Dagger2 正常运行的。还需要另外一个注解配合。这个注解就是 @Component。</p>
<p><strong>@Component</strong></p>
<p>而 @Component 相当于联系纽带，将 @inject 标记的需求方和依赖绑定起来，并建立了联系，而 Dagger2 在编译代码时会依靠这种关系来进行对应的依赖注入</p>
<p><strong>@Provides 和 @Module</strong><br>Dagger2 为了能够对第三方库中的类进行依赖注入，提供了 @Provides 和 @Module 两个注解。</p>
<p>Provide 本身的字面意思就是提供，显然在 Dagger2 中它的作用就是提供依赖。 </p>
<p>Module 是模块的意思，Dagger2 中规定，用 @Provides 注解的依赖必须存在一个用 @Module 注解的类中。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7cb82d844f92dfa47016fa2fda60e58d?method=download&amp;shareKey=32e575c6c38ade13609fae051ed17920" alt="image"></p>
<p><strong>@Inject 和 @Provides 的优先级</strong></p>
<p>Baozi 这个类就符合我上面给的情景，一方面它确实拥有被 @Inject 注解过的构造方法，另一方面在 Module 中它又通过 @Provides 提供了依赖。那么，最终，Dagger2 采取了哪一种呢？</p>
<p>答案是 Module，其实现象我们在之前的测试时已经可以观察到了，最终屏幕显示的是豆沙包选项。</p>
<p>Dagger2 依赖查找的顺序是先查找 Module 内所有的 @Provides 提供的依赖，如果查找不到再去查找 @Inject 提供的依赖。</p>
<p><strong>Dagger2 中的单例 @Singleton</strong></p>
<ul>
<li>用 @Singleton 标注在目标单例上，然后用 @Singleton 标注在 Component 对象上。</li>
<li><p>如果要以 @Provides 方式提供单例的话，需要用 @Singleton 注解依赖提供的方法</p>
<pre><code> @Module
 public class SecondActivityModule {

     @Provides
     @Singleton
     public TestSingleton provideTestSingleton(){
         return new TestSingleton();
      }
 }

</code></pre></li>
<li>@Singleton 是一个注解，但是它被一个元注解 @Scope 注解了</li>
<li>为什么要用 @Singleton 同时标注 @Provides 和 @Component ?<blockquote>
<p>Component 是联系需求与依赖的纽带，所以用 @Singleton 确定的单例作用域应该也是在 Component 的范围内。也就是说 @Scope 的作用范围其实就是单例能力范围，这个范围在单个的 Component 中.</p>
</blockquote>
</li>
</ul>
<p><strong>@Qualifiers 和 @Name</strong></p>
<p>@Name 只是被 @Qualifier 注解的一个注解。所以，它能够有效完全是因为 @Qualifier</p>
<pre><code>@Qualifier
@Documented
@Retention(RUNTIME)
public @interface Named {

    /** The name. */
    String value() default &quot;&quot;;
}
</code></pre><p>完全可以自定义不同的注解，避免通过 Named 的方式容易拼错的问题。 </p>
<pre><code>@Qualifier
@Documented
@Target({ElementType.FIELD,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface B {
}
</code></pre><p>使用时</p>
<pre><code>   @Provides
    @Named(&quot;A&quot;)
    public int provideIntA(){
        return 111;
    }
    @Provides
    @B
    public int provideIntB(){
        return 222;
    }

    @Inject
    @Named(&quot;A&quot;)
    int testValueA;

    @Inject
    @B
    int testValueB;
</code></pre><p><strong>Dagger2 中的延迟加载</strong></p>
<p>所谓的延迟加载，是当我们使用的时候再去实例化,比如以下方式。</p>
<pre><code>public class TestLazy {

    String name;

    public String getName() {
        if ( name == null ) {
            name = &quot;TestLazy&quot;;
        }

        return name;
    }
}
</code></pre><p>Dagger2 提供了延迟加载能力。只需要通过 Lazy 就好了，Lazy 是泛型类，接受任何类型的参数。</p>
<pre><code>public class TestLazy {

    @Inject
    @Named(&quot;TestLazy&quot;)
    Lazy&lt;String&gt; name;

    public String getName() {
        return name.get();
    }

}

</code></pre><p><strong>多个component之间的依赖</strong></p>
<pre><code>@Component(modules = {ShangjiaAModule.class, XiaoChiModule.class},dependencies = XiaoChiComponent.class)

</code></pre><p><strong>SubComponent</strong><br>Java 软件开发中，我们经常面临的就是“组合”和“继承”的概念。它们都是为了扩展某个类的功能。<br>前面的 Component 的依赖采用 @Component(dependecies=othercomponent.class) 就相当于组合。<br>那么在 Dagger2 中，运用 @SubComponent 标记一个 Component 的行为相当于继承。</p>
<pre><code>@Subcomponent(modules = FoodModule.class)
public interface SubComponent {
    void inject(ThirdActivity activity);
}

@Component(modules = XiaoChiModule.class)
public interface ParentComponent {
    SubComponent provideSubComponent();
}


DaggerParentComponent.builder().build()
                .provideSubComponent().inject(this);

</code></pre><p>使用 Subcomponent 时，还是要先构造 ParentComponent 对象，然后通过它提供的 SubComponent 再去进行依赖注入。</p>
<p>大家可以细细观察下它与 depedency 方法的不同之处。</p>
<p>但是，SubComponent 同时具备了 ParentComponent 和自身的 @Scope 作用域。所以，这经常会造成混乱的地方。大家需要注意。</p>
<p>如果你要我比较，SubComponent 和 dependency 形式哪种更好时，我承认各有优点，但我自己倾向于 dependency，因为它更灵活。</p>
<p>不是说 组合优于继承嘛。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h3 id="基于-javax-inject"><a href="#基于-javax-inject" class="headerlink" title="基于 javax.inject "></a>基于 <a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="noopener">javax.inject </a></h3><p>Dagger 2 是一个设计非常巧妙且粗暴的框架。为什么说巧妙呢？</p>
<ol>
<li>Dagger 是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。</li>
<li>Dagger 通过生成中间代码，解决了基于反射带来的开发和性能上的问题。</li>
<li>Dagger 通过编译的时候进行依赖注入的框架。</li>
<li>Dagger 与其他依赖注入框架不同，它是通过apt插件在编译阶段生成相应的注入代码</li>
<li>Dagger 的目的为了降低程序耦合。</li>
</ol>
<p>总之：他是在编译的时候完成了一切所需要的工作，提供一种使用方便、耦合度低、避免了通过反射带来的性能问题。</p>
<p>为什么说粗暴呢？使用的时候简单几个注解就可以了，但是 在编译阶段通过 apt 插件生成了全部的注入代码。而且代码量还不小。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 brokge
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>