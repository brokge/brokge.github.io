<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Java枚举六问 | 吾与尔</title>

  
  <meta name="author" content="brokge">
  

  
  <meta name="description" content="一问：Java 枚举是如何保证线程安全的？
答：因为 Java 类加载与初始化是 JVM 保证线程安全，而 Java enum 枚举在编译器编译后的字节码实质是一个 final 类，每个枚举类型是这个 final 类中的一个静态常量属性，其属性初始化是在该 final 类的 static 块中进行，">
  

  
  <meta name="keywords" content="吾与尔">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Java枚举六问">

  <meta property="og:site_name" content="吾与尔">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="吾与尔" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">吾与尔</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Java枚举六问</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/06/Java枚举六问/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-06T07:26:00.000Z">
          2019-01-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="一问：Java-枚举是如何保证线程安全的？"><a href="#一问：Java-枚举是如何保证线程安全的？" class="headerlink" title="一问：Java 枚举是如何保证线程安全的？"></a>一问：Java 枚举是如何保证线程安全的？</h3><blockquote>
<p>答：因为 Java 类加载与初始化是 JVM 保证线程安全，而 Java enum 枚举在编译器编译后的字节码实质是一个 final 类，每个枚举类型是这个 final 类中的一个静态常量属性，其属性初始化是在该 final 类的 static 块中进行，而 static 的常量属性和代码块都是在类加载时初始化完成的，所以自然就是 JVM 保证了并发安全。（不清楚 enum 编译后为啥是静态常量的可以查看历史推送了解更多）</p>
</blockquote>
<h3 id="二问：不使用-synchronized-和-lock如何创建一个线程安全的单例？"><a href="#二问：不使用-synchronized-和-lock如何创建一个线程安全的单例？" class="headerlink" title="二问：不使用 synchronized 和 lock如何创建一个线程安全的单例？"></a>二问：不使用 synchronized 和 lock如何创建一个线程安全的单例？</h3><blockquote>
<p>答：这是一个很 open 的题目，我们平时提到单例并发都是用锁机制，实际抛开锁机制也有几种实现方式可以保证创建单例的并发安全，而且各具特色。</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token comment" spellcheck="true">// 通过枚举实现单例模式</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>
    INSTANCE<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过饿汉模式实现单例</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过静态内部类模式实现单例</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过 CAS（AtomicReference）实现单例模式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AtomicReference<span class="token operator">&lt;</span>Singleton<span class="token operator">></span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Singleton<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Singleton singleton <span class="token operator">=</span> INSTANCE<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> singleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> singleton<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>可以看到，上面四种方式都可以不使用 synchronized 或者 lock 来保证了单例创建的并发安全。前面三种都是借助了 JVM 的 ClassLoader 类加载初始化保证并发安全的机制（至于 JVM 底层其实也是使用了 synchronized 或者 lock 的机制），而对于最后一种通过 CAS 机制保证了并发安全（至于什么是 CAS 我们后面并发相关每日一题会再详细推送讨论的，这里先记住 CAS 就是一种非阻塞乐观锁机制，是一种基于忙等待的算法，依赖底层硬件实现，相对于锁其没有线程切换和阻塞的额外消耗，但是如果忙等待一直执行不成功的死循环会对 CPU 造成较大的开销），最后一种才是真正的无锁实现。</p>
</blockquote>
<h3 id="四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？"><a href="#四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？" class="headerlink" title="四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？"></a>四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？</h3><blockquote>
<p>答：其实这个题目算是一箭双雕，既考察了 Java 枚举的实质特性又考察了单例模式的一些弊端问题。除过枚举实现的单例模式以外的其他实现方式都有一个比较大的问题是一旦实现了 Serializable 接口后就不再是单例了，因为每次调用 readObject() 方法返回的都是一个新创建出来的对象（当然可以通过使用 readResolve() 方法来避免，但是终归麻烦），而 Java 规范中保证了每一个枚举类型及其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上 Java 做了特殊处理，序列化时 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化时则是通过 java.lang.Enum 的 valueOf 方法来根据名字查找枚举对象，同时禁用了 writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法。<br>这个问题也暴露出另一个新问题，Java 枚举序列化有哪些坑？</p>
</blockquote>
<h3 id="五问：Java-枚举序列化有哪些坑？"><a href="#五问：Java-枚举序列化有哪些坑？" class="headerlink" title="五问：Java 枚举序列化有哪些坑？"></a>五问：Java 枚举序列化有哪些坑？</h3><blockquote>
<p>答：如果我们枚举被序列化本地持久化了，那我们就不能删除原来枚举类型中定义的任何枚举对象，否则程序在运行过程中反序列化时 JVM 就会找不到与某个名字对应的枚举对象了，所以我们要尽量避免多枚举对象序列化的使用（当然了，枚举实现的单例枚举对象一般都不会增删改，所以不存在问题）。</p>
</blockquote>
<h3 id="六问：Java-迭代器和枚举器的区别是什么？"><a href="#六问：Java-迭代器和枚举器的区别是什么？" class="headerlink" title="六问：Java 迭代器和枚举器的区别是什么？"></a>六问：Java 迭代器和枚举器的区别是什么？</h3><blockquote>
<p>答：主要区别如下。<br>Enumeration<e> 枚举器接口是 JDK 1.0 提供的，适用于传统类，而 Iterator<e> 迭代器接口是 JDK 1.2 提供的，适用于 Collections。<br>Enumeration 只有两个方法接口，我们只能读取集合的数据而不能对数据进行修改，而 Iterator 有三个方法接口，除了能读取集合的数据外也能对数据进行删除操作。<br>Enumeration 不支持 fail-fast 机制，而 Iterator 支持 fail-fast 机制（一种错误检测机制，当多线程对集合进行结构上的改变的操作时就有可能会产生 fail-fast 机制，譬如 ConcurrentModificationException 异常）。<br>总归现在尽量使用 Iterator 迭代器而不是 Enumeration 枚举器。</e></e></p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/知识库/">知识库</a>, <a href="/categories/知识库/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 brokge
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>