<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Java  注解 | 吾与尔</title>

  
  <meta name="author" content="brokge">
  

  
  <meta name="description" content="注解注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。
一 、注解分类
java 内置注解 
@Override、 @Deprecated、@SuppressWarnings、@SafeVarargs(jdk 7 新增)

标注注解的元注解


它是用来修饰注解的注">
  

  
  <meta name="keywords" content="吾与尔">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Java  注解">

  <meta property="og:site_name" content="吾与尔">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="吾与尔" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">吾与尔</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Java  注解</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/08/30/Java-注解/" rel="bookmark">
        <time class="entry-date published" datetime="2019-08-30T12:44:41.000Z">
          2019-08-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。</p>
<h3 id="一-、注解分类"><a href="#一-、注解分类" class="headerlink" title="一 、注解分类"></a>一 、注解分类</h3><ol>
<li><p><strong>java 内置注解</strong> </p>
<p>@Override、 @Deprecated、@SuppressWarnings、@SafeVarargs(jdk 7 新增)</p>
</li>
<li><p><strong>标注注解的元注解</strong></p>
</li>
</ol>
<p>它是用来修饰注解的注解，从而创建新的注解。</p>
<ul>
<li>@Target, 说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目的。</li>
<li>@Retention, 定义了该Annotation被保留的时间长短，SOURCE、CLASS、RUNTIME（可通过反射获取内部属性）。</li>
<li>@Documented, 标记注解，可以工具文档化。</li>
<li>@Inherited 当前注解是否可以继承。</li>
<li>@Repeatable: JDK 8 新增，允许一个注解在同一声明类型（类、属性或方法）上多次使用。</li>
</ul>
<p><strong>@Targe</strong> 注解取值是一个 ElementType 类型的数组。</p>
<table>
<thead>
<tr>
<th>ElementType</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>- ElementType.TYPE</td>
<td>修饰类、接口或枚举类型。</td>
</tr>
<tr>
<td>- ElementType.FIELD</td>
<td>修饰成员变量。</td>
</tr>
<tr>
<td>- ElementType.METHOD</td>
<td>修饰方法。</td>
</tr>
<tr>
<td>- ElementType.PARAMETER</td>
<td>修饰参数。</td>
</tr>
<tr>
<td>- ElementType.CONSTRUCTOR</td>
<td>修饰构造方法。</td>
</tr>
<tr>
<td>- ElementType.LOCAL_VARIABLE</td>
<td>修饰局部变量。</td>
</tr>
<tr>
<td>- ElementType.ANNOTATION_TYPE</td>
<td>修饰注解。</td>
</tr>
<tr>
<td>- ElementType.PACKAGE</td>
<td>修饰包。</td>
</tr>
<tr>
<td>- ElementType.TYPE_PARAMETER</td>
<td>修饰参数声明。</td>
</tr>
<tr>
<td>- ElementType.TYOPE_USR</td>
<td>使用类型。</td>
</tr>
</tbody>
</table>
<p><strong>@Retention</strong> 3种类型，分别表示不同的保留周期</p>
<ul>
<li><strong>RetentionPolicy.SOURCE</strong>:源码级注解。<blockquote>
<p>注解信息只会保留在.java 源码中，源码在编译后，注解信息会被丢弃，不会保留到.class 中。</p>
</blockquote>
</li>
<li><strong>RetentionPolicy.CLASS</strong>:编译时注解。<blockquote>
<p>注解信息会保留在.java 源码以及.class 中。当运行java 程序时，JVM 会丢弃该注解信息，不会保留到 JVM 中。</p>
</blockquote>
</li>
<li><strong>RetentionPolicy.RUNTIME</strong>:运行时注解。<blockquote>
<p>当运行 java 程序时，JVM 也会保留该注解信息，可以通过反射获取该注解信息。</p>
</blockquote>
</li>
</ul>
<h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p><strong>1. 基本定义</strong></p>
<p>定义新的注解类型使用 @interface 关键字。</p>
<pre><code>public @interface Cup{

}

</code></pre><p>程序中使用该注解：</p>
<pre><code>@Cup
public class AnnotationTest{

}

</code></pre><p><strong>2. 定义成员变量(注解的属性)</strong></p>
<p>注解 只有成员变量，没有方法。注解的成员变量在注解定义中以“无形参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型；</p>
<pre><code>public @interface Cup{
    String name();
    int price();
}
</code></pre><p>上面两个成员变量以方法的形式来定义。使用该注解时候就应该为该成员变量赋值</p>
<pre><code>pubilc class AnnotationTest(){
    @Cup(name=&quot;马克杯&quot;,price=100)
    public void drink(){

    }
}

</code></pre><p>也可以在定义注解的时候通过 default 来指定默认值：</p>
<pre><code>public @interface Cup{
   String name() default &quot;马克杯&quot;;
   int price() default 100;

}
</code></pre><p><strong>3. 定义运行时注解</strong></p>
<p>使用@Retention 来设定注解的保留策略 ，这三哥策略的生命周期长度为：SOURCE&lt;CLASS&lt;RUNTIME.</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
public @interface Cup{
    String name() default &quot;马克杯&quot;;
    int price() default 100;
}

</code></pre><p><strong>4. 定义编译时注解</strong></p>
<pre><code>@Retention(RetentionPolicy.CLASS)
public @interface Cup{
    String name() default &quot;马克杯&quot;;
    int price() default 100;
}

</code></pre><p><strong>5. Repeatable 定义可重复注解</strong></p>
<p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p>
<p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p>
<p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p>
<pre><code>
@interface Persons {
    Person[]  value();
}


@Repeatable(Persons.class)
@interface Person{
    String role default &quot;&quot;;
}


@Person(role=&quot;artist&quot;)
@Person(role=&quot;coder&quot;)
@Person(role=&quot;PM&quot;)
public class SuperMan{

}


</code></pre><p>注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p>
<p>什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</p>
<p>以下代码中就是相关容器注解。</p>
<pre><code>@interface Persons {
    Person[]  value();
}

</code></pre><h3 id="二、注解的提取"><a href="#二、注解的提取" class="headerlink" title="二、注解的提取"></a>二、注解的提取</h3><p>注解通过反射获取。<br>首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p>
<pre><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {}
</code></pre><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p>
<pre><code>public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {}
</code></pre><p>或者是 getAnnotations() 方法。</p>
<pre><code>public Annotation[] getAnnotations() {}
</code></pre><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p>
<p>在处理的注解的过程中可能会用到以下方法</p>
<pre><code>Field getDeclaredField(String attrbuteName);

Method getDeclaredMethod(String methodName);
</code></pre><h3 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h3><p>注解： 使用场景 分为 三类：<br>编译前、<br>编译时生成代码、<br>运行时。</p>
<p>运行时注解：<br>例如：ButterKnife ，黑科技、低性能</p>
<p>编译时注解：<br>Dagger2：生成中间代码，所以性能高</p>
<p>注解处理器：<br>编译时处理器、<br>运行时处理器。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 brokge
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>