<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="brokge"><title>Java 反射 · 吾与尔</title><meta name="description" content="参考博客网址
反射入口Object.getClass()
Car car = new Car();
Class clazz = car.getClass();
.class
Class clazz = Car.class;
Class cls1 = int.class;
Class cls2 = S"><meta name="keywords" content="吾与尔"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">I and i</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">吾与尔</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">首頁</a></li><li><a href="/archives">歸檔</a></li><li><a href="/categories">分類</a></li><li><a href="/tags">標籤</a></li><li> <a href="https://brokge.github.io/scrapydoc/">爬虫</a></li><li> <a href="https://brokge.github.io/linux-command-line/html/">Linux命令行</a></li><li><a href="/about/index.html">关于</a></li><li class="soc"><a href="https://brokge.github.io/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="https://brokge.github.io" rel="noopener noreferrer">brokge</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Java 反射</a></p><p class="post-meta"><span class="date meta-item">發佈於&nbsp;2019-08-30</span></p><p class="post-abstract"></p><p><a href="https://blog.csdn.net/briblue/article/details/74616922" target="_blank" rel="noopener">参考博客网址</a></p>
<h2 id="反射入口"><a href="#反射入口" class="headerlink" title="反射入口"></a>反射入口</h2><p><strong>Object.getClass()</strong></p>
<pre><code>Car car = new Car();
Class clazz = car.getClass();
</code></pre><p><strong>.class</strong></p>
<pre><code>Class clazz = Car.class;
Class cls1 = int.class;
Class cls2 = String.class;
</code></pre><p> <strong>Class.forName() 方法</strong></p>
<pre><code> try {
    Class clz = Class.forName(&quot;com.aa.test.Car&quot;);
} catch (ClassNotFoundException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}

</code></pre><p> <strong>Class 的名字</strong></p>
<pre><code> Class.getName();

Class.getSimpleName();

Class.getCanonicalName();
</code></pre><pre><code> Class clz = new Outter.Inner[][][]{}.getClass();

System.out.println(&quot; Inner Class name:&quot;+clz.getName());
System.out.println(&quot; Inner Class simple name:&quot;+clz.getSimpleName());
System.out.println(&quot; Inner Class canonical name:&quot;+clz.getCanonicalName());


//run 是匿名类
Runnable run = new Runnable() {

    @Override
    public void run() {
        // TODO Auto-generated method stub

    }
};

System.out.println(&quot; anonymous Class name:&quot;+run.getClass().getName());
System.out.println(&quot; anonymous Class simple name:&quot;+run.getClass().getSimpleName());
System.out.println(&quot; anonymous Class canonical name:&quot;+run.getClass().getCanonicalName());

// local 是局部类
class local{};


System.out.println(&quot;Local a name:&quot;+local.class.getName());
System.out.println(&quot;Local a simplename:&quot;+local.class.getSimpleName());
System.out.println(&quot;Local a canonicalname:&quot;+local.class.getCanonicalName());

</code></pre><p>输出</p>
<pre><code>//[[[ 代表三维数组
Inner Class name:[[[Lcom.frank.test.Outter$Inner;
Inner Class simple name:Inner[][][]
Inner Class canonical name:com.frank.test.Outter.Inner[][][]


//匿名类:
anonymous Class name:com.frank.test.Test$1
anonymous Class simple name:
anonymous Class canonical name:null
//局部类
Local a name:com.frank.test.Test$1local
Local a simplename:local
Local a canonicalname:null

</code></pre><p>Canonical 是官方、标准的意思，那么 getCanonicalName() 自然就是返回一个 Class 对象的官方名字，这个官方名字 canonicalName 是 Java 语言规范制定的，如果 Class 对象没有 canonicalName 的话就返回 null。</p>
<p>getCanonicalName() 是 getName() 和 getSimpleName() 的结合。</p>
<ul>
<li>getCanonicalName() 返回的也是全限定类名，但是对于内部类，不用 $ 开头，而用 .。</li>
<li>getCanonicalName() 对于数组类型的 Class，同 simplename 一样直接在后面添加 [] 。</li>
<li>getCanonicalName() 不同于 simplename 的地方是，不存在 canonicalName 的时候返回 null 而不是空字符串。</li>
<li>局部类和匿名内部类不存在 canonicalName。</li>
</ul>
<p><strong>Class 获取修饰符</strong></p>
<pre><code>System.out.println(&quot;modifiers value:&quot;+TestModifier.class.getModifiers());
System.out.println(&quot;modifiers :&quot;+Modifier.toString(TestModifier.class.getModifiers()));
</code></pre><p>输出</p>
<pre><code>modifiers value:1025
modifiers :public abstract
</code></pre><p>大家肯定会有疑问，为什么会返回一个整型数值呢？</p>
<p>这是因为一个类定义的时候可能会被多个修饰符修饰，为了一并获取，所以 Java 工程师考虑到了位运算，用一个 int 数值来记录所有的修饰符，然后不同的位对应不同的修饰符，这些修饰符对应的位都定义在 Modifier 这个类当中。<br>举例：</p>
<table>
<thead>
<tr>
<th>待比较</th>
<th>2进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>public（0x00000001）</td>
<td>00000000001</td>
</tr>
<tr>
<td> 1025</td>
<td>10000000001</td>
</tr>
<tr>
<td>进行&amp;运算结果</td>
<td>00000000001 </td>
</tr>
</tbody>
</table>
<pre><code>public static boolean isPublic(int mod) {
        return (mod &amp; PUBLIC) != 0;
}
</code></pre><p>得出结果  00000000001 不等于0 返回true ，类修饰符为 public</p>
<h2 id="获取Class-的成员"><a href="#获取Class-的成员" class="headerlink" title="获取Class 的成员"></a>获取Class 的成员</h2><p>一个类的成员包括属性（有人翻译为字段或者域）、方法。对应到 Class 中就是 Field、Method、Constructor</p>
<p><strong>获取Field</strong></p>
<pre><code>//获取的是 Class 中的属性，不能获取其父类的属性
public Field getDeclaredField(String name)
                       throws NoSuchFieldException,
                              SecurityException;
//获取的是 public 属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取
public Field getField(String name)
               throws NoSuchFieldException,
                      SecurityException

//获取所有的属性，但不包括从父类继承下来的属性
public Field[] getDeclaredFields() throws SecurityException {}

//获取自身的所有的 public 属性，包括从父类继承下来的。
public Field[] getFields() throws SecurityException {

</code></pre><blockquote>
<p>1.两者的区别就是 getDeclaredField() 获取的是 Class 中的属性,不能获取其父类的属性。 getField() 方法获取的是public属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取。</p>
<ol start="2">
<li>getDeclaredFileds() 方法可以获取 private、protected、public 和 default 属性，但是它获取不到从父类继承下来的属性。getFields() 自身的所有的 public 属性，包括从父类继承下来的。</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>本 Class</th>
<th>SupperClass</th>
</tr>
</thead>
<tbody>
<tr>
<td>getField</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredField</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
<tr>
<td>getFields</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredFields</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
</tbody>
</table>
<p><strong>获取 Method</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>本 Class</th>
<th>SupperClass</th>
</tr>
</thead>
<tbody>
<tr>
<td>getMethod</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredMethod</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
<tr>
<td>getMethods</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredMethods</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>类或者接口中的方法对应到 Class 就是 Method。<br>相应的 API 如下，parameterTypes 是方法对应的参数，获取范围和Field类似。：</p>
<pre><code>public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)

public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)

public Method[] getDeclaredMethods() throws SecurityException

public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 
</code></pre><p><strong>获取Contructor</strong><br>Java 反射把构造器从方法中单独拎出来了，用 Constructor 表示。</p>
<pre><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)

public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)

public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException 

public Constructor&lt;?&gt;[] getConstructors() throws SecurityException 

</code></pre><p>因为，Constructor 不能从父类继承，所以就没有办法通过 getConstructor() 获取到父类的 Constructor。</p>
<h3 id="Field-的操作"><a href="#Field-的操作" class="headerlink" title="Field 的操作"></a><strong>Field 的操作</strong></h3><p>类中 定义的属性， 它们的类型要么是 8 种基础类型 int、long、float、double、boolean、char、byte 和 short。要么是引用，所有的引用都是 Object 的后代。<br><strong>Field 类型的获取</strong></p>
<pre><code>public Type getGenericType() {}

public Class&lt;?&gt; getType() {}
</code></pre><p>注意，两者返回的类型不一样，getGenericType() 方法能够获取到泛型类型，比如 <code>hashMap&lt;String,String&gt;</code>,比getType 更详细。<br><strong>Field 修饰符的获取</strong></p>
<pre><code>public int getModifiers() {}
</code></pre><p>这个与前面 Class 获取修饰符一致。<br><strong>Field 内容的读取与赋值</strong><br>Field 这个类定义了一系列的 get 方法来获取不同类型的值。</p>
<pre><code>public Object get(Object obj);

public int getInt(Object obj);

public long getLong(Object obj)
        throws IllegalArgumentException, IllegalAccessException;

public float getFloat(Object obj)
        throws IllegalArgumentException, IllegalAccessException;

public short getShort(Object obj)
        throws IllegalArgumentException, IllegalAccessException;

public double getDouble(Object obj)
        throws IllegalArgumentException, IllegalAccessException;

public char getChar(Object obj)
        throws IllegalArgumentException, IllegalAccessException;

public byte getByte(Object obj)
        throws IllegalArgumentException, IllegalAccessException;

public boolean getBoolean(Object obj)
        throws IllegalArgumentException, IllegalAccessException

</code></pre><p>Field 又定义了一系列的 set 方法用来对其自身进行赋值。</p>
<pre><code>public void set(Object obj, Object value);

public void setInt(Object obj,int value);

public void setLong(Object obj,long value)
        throws IllegalArgumentException, IllegalAccessException;

public void setFloat(Object obj,float value)
        throws IllegalArgumentException, IllegalAccessException;

public void setShort(Object obj,short value)
        throws IllegalArgumentException, IllegalAccessException;

public void setDouble(Object obj,double value)
        throws IllegalArgumentException, IllegalAccessException;

public void setChar(Object obj,char value)
        throws IllegalArgumentException, IllegalAccessException;

public void setByte(Object obj,byte b)
        throws IllegalArgumentException, IllegalAccessException;

public void setBoolean(Object obj,boolean b)
        throws IllegalArgumentException, IllegalAccessException

</code></pre><p>可能有同学会对方法中出现的 Object 参数有疑问，它其实是类的实例引用，这里涉及一个细节。</p>
<blockquote>
<p><strong>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。</strong></p>
</blockquote>
<p>在执行 set 属性的时，如果操作 private 修饰的成员，需要加上 </p>
<pre><code>field.setAccessible(true);
</code></pre><h3 id="Method-操作"><a href="#Method-操作" class="headerlink" title="Method 操作"></a>Method 操作</h3><p>Method 对应普通类的方法。<br>我们看看一般普通类的方法的构成。</p>
<pre><code>public int add(int a,int b);

</code></pre><p>方法由下面几个要素构成：</p>
<ul>
<li>方法名</li>
<li>方法参数</li>
<li>方法返回值</li>
<li>方法的修饰符</li>
<li>方法可能会抛出的异常</li>
</ul>
<p><strong>Method 获取方法名</strong></p>
<pre><code>
class.getDeleclaredMethods();
</code></pre><p><strong>Method 获取方法参数</strong></p>
<pre><code>//返回的是一个 Parameter 数组
public Parameter[] getParameters() {}

// 获取所有的参数类型
public Class&lt;?&gt;[] getParameterTypes() {}
// 获取所有的参数类型，包括泛型
public Type[] getGenericParameterTypes() {}
</code></pre><p>返回的是一个 Parameter 数组，在反射中 Parameter 对象就是用来映射方法中的参数。经常使用的<br>Parameter.java 类中的方法</p>
<pre><code>// 获取参数名字
public String getName() {}

// 获取参数类型
public Class&lt;?&gt; getType() {}

// 获取参数的修饰符
public int getModifiers() {}
</code></pre><p><strong>Method 获取返回值类型</strong></p>
<pre><code>// 获取返回值类型
public Class&lt;?&gt; getReturnType() {}

// 获取返回值类型包括泛型
public Type getGenericReturnType() {}
</code></pre><p><strong>Method 获取修饰符</strong></p>
<pre><code>public int getModifiers() {}
</code></pre><p><strong>Method 获取异常类型</strong></p>
<pre><code>public Class&lt;?&gt;[] getExceptionTypes() {}

public Type[] getGenericExceptionTypes() {}
</code></pre><p><strong>Method 方法的执行</strong> </p>
<p>这个应该是整个反射机制的核心内容了，很多时候运用反射目的其实就是为了以常规手段执行 Method。</p>
<pre><code>public Object invoke(Object obj, Object... args) {}
</code></pre><p>Method 调用 invoke() 的时候，存在许多细节：</p>
<ul>
<li><p>invoke() 方法中第一个参数 Object 实质上是 Method 所依附的 Class 对应的类的实例，如果这个方法是一个<strong>静态方法</strong>，那么 ojb 为 null，后面的可变参数 Object 对应的自然就是参数。</p>
</li>
<li><p>invoke() 返回的对象是 Object，所以实际上执行的时候要进行强制转换。</p>
</li>
<li><p>在对 Method 调用 invoke() 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 InvocationTargetException。而通过 InvocationTargetException.getCause() 可以获取真正的异常。</p>
</li>
</ul>
<h3 id="Constructor-的操作"><a href="#Constructor-的操作" class="headerlink" title="Constructor 的操作"></a>Constructor 的操作</h3><p>Constructor 同 Method 差不多，但是它特别的地方在于，它能够创建一个对象。</p>
<p>在 Java 反射机制中有两种方法可以用来创建类的对象实例：Class.newInstance() 和 Constructor.newInstance()。官方文档建议开发者使用后面这种方法，下面是原因。</p>
<ul>
<li>Class.newInstance() 只能调用无参的构造方法，而 Constructor.newInstance() 则可以调用任意的构造方法。</li>
<li>Class.newInstance() 通过构造方法直接抛出异常，而 Constructor.newInstance() 会把抛出来的异常包装到 InvocationTargetException 里面去，这个和 Method 行为一致。</li>
<li>Class.newInstance() 要求构造方法能够被访问，而 Constructor.newInstance() 却能够访问 private 修饰的构造器。</li>
</ul>
<h3 id="反射中的数组"><a href="#反射中的数组" class="headerlink" title="反射中的数组"></a>反射中的数组</h3><p>数组本质上是一个 Class，而在 Class 中存在一个方法用来识别它是否为一个数组。<br>在 Class.java 中 方法 <code>isArray()</code> 判断是否是数组<br>由于 数组本质上 还是 Class 所以可以通过 </p>
<pre><code>getName();
//获取数组的里面的元素的类型，比如 int[] 数组的 componentType 自然就是 int
getComponentType();
</code></pre><p><strong>动态创建数组*</strong><br>反射创建数组通过 Array.newInstance() 这个方法。</p>
<pre><code>public static Object newInstance(Class&lt;?&gt; componentType, int... dimensions)
        throws IllegalArgumentException, NegativeArraySizeException {}

</code></pre><p>第一个参数 为数组内原始类型，后面的是可变参数，表示的是相应维度的数组长度限制。<br>比如创建一个 二维数组 <code>Array.newInstance(int.class,2,3);</code></p>
<p><strong>Array 的读取与赋值</strong></p>
<ol>
<li>对Array 整体的赋值和读取<br><code>`</code><br>public void set(Object obj,<pre><code>         Object value)
  throws IllegalArgumentException,
         IllegalAccessException;
</code></pre></li>
</ol>
<p>public Object get(Object obj)<br>           throws IllegalArgumentException,<br>                  IllegalAccessException;</p>
<pre><code>2. 对 Array 指定位置进行赋值和读取,经典的几种方式分别为：
</code></pre><p>public static void set(Object array,<br>                       int index,<br>                       Object value)<br>                throws IllegalArgumentException,<br>                       ArrayIndexOutOfBoundsException;</p>
<p>public static void setBoolean(Object array,<br>                              int index,<br>                              boolean z)<br>                       throws IllegalArgumentException,<br>                              ArrayIndexOutOfBoundsException;</p>
<p>public static Object get(Object array,<br>                         int index)<br>                  throws IllegalArgumentException,<br>                         ArrayIndexOutOfBoundsException;</p>
<p>public static short getShort(Object array,<br>                             int index)<br>                      throws IllegalArgumentException,<br>                             ArrayIndexOutOfBoundsException;</p>
<pre><code>

### 反射中的枚举 enum
同数组一样本质上还是一个 Class 而已。

枚举的表现形式：

</code></pre><p>public enum State {<br>    IDLE,<br>    DRIVING,<br>    STOPPING,</p>
<pre><code>test();

int test1() {
    return 0;
}
</code></pre><p>}</p>
<pre><code>在 java 反射 中，可以把枚举看成一般的Class,但是反射机制提供了3个特别的 API 用于操作枚举。

</code></pre><p>//判断是否是枚举类型<br>Class.isEnum()<br>//获取枚举所有的常量<br>Class.getEnumConstants()<br>//判断一个 Field 是不是枚举常量<br>java.lang.reflect.Field.isEnumConstant()</p>
<p><code>`</code></p>
<p><strong>枚举的获取与设置</strong><br>因为等同于 Class， 所以 枚举的获取与设置，可以 通过 Field 中的get() 和 set() 方法。</p>
<p>需要注意的是，如果要获取枚举里面的Field、Method、Constructor  可以调用 Class 的通用 API.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Java 中的反射是非常规编码方式。</li>
<li>Java 反射机制的操作入口是获取 Class 文件。 有 Class.forName()、 .class 和 Object.getClass() 3 种。</li>
<li>获取 Class 对象后还不够，需要获取它的 Members，包含 Field、Method、Constructor。</li>
<li>Field 操作主要涉及到类别的获取，及数值的读取与赋值。</li>
<li>Method 算是反射机制最核心的内容，通常的反射都是为了调用某个 Method 的 invoke() 方法。</li>
<li>通过 Class.newInstance() 和 Constructor.newInstance() 都可以创建类的对象实例，但推荐后者。因为它适应于任何构造方法，而前者只会调用可见的无参数的构造方法。</li>
<li>数组和枚举可以被看成普通的 Class 对待。</li>
</ol>
<p></p></div><div class="share"><span>分享到</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=https://brokge.github.io/2019/08/30/Java-反射/%20吾与尔%20Java 反射" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/08/30/Java-反射进阶/" title="Java 反射进阶"><i class="fa fa-angle-double-left"></i>&nbsp;上一篇: Java 反射进阶</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/08/30/Java-注解/" title="Java  注解">下一篇: Java  注解&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><div id="vcomments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">(function(){
    new Valine({
    el: '#vcomments',
    appId: 'UmwJ3stwyISCG9WnW9Nc3SAN-gzGzoHsz',
    appKey: 'UKq878kYn6RXJWx34b77lma6'})
})();
</script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2019&nbsp;<a target="_blank" href="https://brokge.github.io" rel="noopener noreferrer">brokge</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>