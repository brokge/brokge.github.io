<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Android 数据结构之 LinkedHashMap | 吾与尔</title>

  
  <meta name="author" content="brokge">
  

  
  <meta name="description" content="原理分析： LinkedHashMap 是 HashMap 的子类，其在 HashMap 的基础上只添加了一个双向链表和一个顺序模式属性，其每次 put 元素都会往这个双向链表上添加节点，其构造方法比 HashMap 多了一个 boolean 类型的 accessOrder 参数，当该参数为 tru">
  

  
  <meta name="keywords" content="吾与尔">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Android 数据结构之 LinkedHashMap">

  <meta property="og:site_name" content="吾与尔">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="吾与尔" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">吾与尔</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Android 数据结构之 LinkedHashMap</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/24/Android-数据结构之-LinkedHashMap/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-24T13:07:42.000Z">
          2019-07-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="原理分析："><a href="#原理分析：" class="headerlink" title="原理分析："></a>原理分析：</h4><p> LinkedHashMap 是 HashMap 的子类，其在 HashMap 的基础上只添加了一个双向链表和一个顺序模式属性，其每次 put 元素都会往这个双向链表上添加节点，其构造方法比 HashMap 多了一个 boolean 类型的 accessOrder 参数，当该参数为 true 时则按照元素最后访问时间在双向链表中排序，为 false 则按照插入顺序排序，默认为 false。<br> 具体源码如下：</p>
<pre><code>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; {
    /**
     * The head of the doubly linked list.
     */
    private transient LinkedHashMapEntry&lt;K,V&gt; header;

    private final boolean accessOrder;


    public LinkedHashMap(int initialCapacity,
                         float loadFactor,
                         boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }
}


</code></pre><p>LinkedHashMap 继承自 HashMap，所以其 put 和 get 操作重写了父类的实现</p>
<pre><code>    /**
     * This override differs from addEntry in that it doesn&#39;t resize the
     * table or remove the eldest entry.
     */
    void createEntry(int hash, K key, V value, int bucketIndex) {
        HashMapEntry&lt;K,V&gt; old = table[bucketIndex];
        LinkedHashMapEntry&lt;K,V&gt; e = new LinkedHashMapEntry&lt;&gt;(hash, key, value, old);
        table[bucketIndex] = e;
        e.addBefore(header);
        size++;
    }

    public V get(Object key) {
        LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key);
        if (e == null)
            return null;
        e.recordAccess(this);
        return e.value;
    }


 private static class LinkedHashMapEntry&lt;K,V&gt; extends HashMapEntry&lt;K,V&gt; {

    LinkedHashMapEntry&lt;K,V&gt; before, after;

    LinkedHashMapEntry(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) {
            super(hash, key, value, next);
        }

    /**
     * Removes this entry from the linked list.
     */
    private void remove() {
            before.after = after;
            after.before = before;
    }

    /**
     * Inserts this entry before the specified existing entry in the list.
     */
    private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) {
            after  = existingEntry;
            before = existingEntry.before;
            before.after = this;
            after.before = this;
    }

    /**
     * This method is invoked by the superclass whenever the value
     * of a pre-existing entry is read by Map.get or modified by Map.set.
     * If the enclosing Map is access-ordered, it moves the entry
     * to the end of the list; otherwise, it does nothing.
     */
    void recordAccess(HashMap&lt;K,V&gt; m) {
            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;
            if (lm.accessOrder) {
                lm.modCount++;
                remove();
                addBefore(lm.header);
            }
    }

    void recordRemoval(HashMap&lt;K,V&gt; m) {
            remove();
    }

 }


</code></pre><p>可以看到 LinkedHashMapMap 中所有 put 进来的 Entry 最终除过按照 HashMap 的 put 操作进行哈希表存储后又额外添加进了一个以 head 为头结点的双向循环链表尾部。==所以说 KinkedHashMap 完全具备 HashMap 的所有特性，也允许 key 和 value 为 null 值，此外自己比 HashMap 厉害的地方在于保证了访问的有序性==。</p>
<p>接着在进行迭代器访问时与 HashMap 的区别在于 LinkedHashMap 是直接迭代遍历操作其自己维护的双向有序链表，以此来保证顺序性，如下：</p>
<pre><code>
private abstract class LinkedHashIterator&lt;T&gt; implements Iterator&lt;T&gt; {
        LinkedHashMapEntry&lt;K,V&gt; nextEntry    = header.after;
        LinkedHashMapEntry&lt;K,V&gt; lastReturned = null;

        /**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */
        int expectedModCount = modCount;

        public boolean hasNext() {
            return nextEntry != header;
        }

        public void remove() {
            if (lastReturned == null)
                throw new IllegalStateException();
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();

            LinkedHashMap.this.remove(lastReturned.key);
            lastReturned = null;
            expectedModCount = modCount;
        }

        Entry&lt;K,V&gt; nextEntry() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            if (nextEntry == header)
                throw new NoSuchElementException();

            LinkedHashMapEntry&lt;K,V&gt; e = lastReturned = nextEntry;
            nextEntry = e.after;
            return e;
        }
    }


</code></pre><p>所以 <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，除过具备 <code>HashMap</code> 的一切优缺点外自身具备插入有序性或者访问有序性，其实现依赖 <code>HashMap</code> 自身的存储结构不变外在 put、get 操作处添加了一个对自己内部维护的双向有序链表的操作。</p>
<p>场景使用 </p>
<ol>
<li>LRU 的结合：</li>
</ol>
<blockquote>
<p>LRU 是一种流行的替换算法，它的全称是 <code>Least Recently Used</code>，最近最少使用，常常在缓存设计的场景中充当一种策略，它的核心思路是最近刚被使用的很快再次被用的可能性最高，而最久没被访问的很快再次被用的可能性最低，所以被优先清理。</p>
</blockquote>
<ol start="2">
<li>LRU 容器的实现</li>
</ol>
<blockquote>
<p>在添加元素到<code>LinkedHashMap</code> 后会调用 <code>removeEldesEntry</code>方法，传递的参数是最久没被访问的键值对，如果这个方法返回<code>true</code> 则这个最久的键值对就会被删除，<code>LinkedHashMap</code>的实现总是返回<code>false</code>，所有容量没有限制。</p>
</blockquote>
<ul>
<li>LinkedHashMap 的实现<pre><code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
      return false;
  }
</code></pre></li>
<li>重写后的实现</li>
</ul>
<pre><code>public class LRUCache&lt;k,v&gt; extents LinkedHashMap&lt;k,v&gt;{
    private int maxEntries;
    public LRUCache(int maxEntries){
        super(16,0.75,true);
        this.maxEntries=maxEntries;
    }

    @override
    protected boolean removeEldesEntry(Entry&lt;k,v&gt; eldest){
        return size()&gt;maxentries;
    }
}

</code></pre>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>, <a href="/categories/Android/数据结构/">数据结构</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/数据结构/">数据结构</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 brokge
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>