<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>JVM 类加载和初始化 | 吾与尔</title>

  
  <meta name="author" content="brokge">
  

  
  <meta name="description" content="[toc]
Java 类加载和初始化我们知道 当要实例化一个类时，JVM会首先加载该类，并且在加载过程中检查这个类是否有静态属性以及静态代码块，如果有，就按顺序分配内存并初始化他们，并且只在类加载的过程中初始化一次。
对于构造代码块，以及普通属性，是在类实例化时进行的，并且每次实例化都会调用，并且普">
  

  
  <meta name="keywords" content="吾与尔">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="JVM 类加载和初始化">

  <meta property="og:site_name" content="吾与尔">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="吾与尔" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">吾与尔</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>JVM 类加载和初始化</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/07/30/JVM-类加载和初始化/" rel="bookmark">
        <time class="entry-date published" datetime="2019-07-30T12:50:24.000Z">
          2019-07-30
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>[toc]</p>
<h1 id="Java-类加载和初始化"><a href="#Java-类加载和初始化" class="headerlink" title="Java 类加载和初始化"></a>Java 类加载和初始化</h1><p>我们知道 当要实例化一个类时，JVM会首先加载该类，并且在加载过程中检查这个类是否有静态属性以及静态代码块，如果有，就按顺序分配内存并初始化他们，并且只在类加载的过程中初始化一次。</p>
<p>对于构造代码块，以及普通属性，是在类实例化时进行的，并且每次实例化都会调用，并且普通属性先于构造代码块，构造代码块先于构造方法执行。</p>
<p><img src="https://raw.githubusercontent.com/brokge/drawio/master/java-load-class.png" alt="流程图"></p>
<pre><code>public class Main {

    //1
    private static String staticValue = &quot;第一步 main 静态属性&quot; + System.currentTimeMillis();

    //3
    private String value = &quot;第三步 main 普通属性&quot; + System.currentTimeMillis();

    //2
    static {
        System.out.println(System.currentTimeMillis() + &quot;&quot;);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {

        }
        System.out.println(staticValue);
        System.out.println(System.currentTimeMillis() + &quot;&quot;);
        System.out.println(&quot;第二步 main 静态代码块&quot;);
    }

    //4
    {
        System.out.println(System.currentTimeMillis() + &quot;&quot;);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {

        }
        System.out.println(&quot;第四步 main 构造代码块 &quot;+System.currentTimeMillis());
        //通过查看时间戳，常规属性是在 构造代码块之前就初始化。
        System.out.println(value);
    }

    //5
    private Main() {
        System.out.println(&quot;第五步 main 构造方法&quot;);
    }


    public static String getString() {
        System.out.println(&quot;getString()&quot;);
        return &quot;&quot;;
    }

    public static void main(String[] args) {
        Main main = new Main();
    }
}
</code></pre><p>控制台输出：</p>
<pre><code>1565683686844
第一步 main 静态属性1565683686844
1565683687848
第二步 main 静态代码块
1565683687849
第四步 main 构造代码块 1565683688852
第三步 main 普通属性1565683687849
第五步 main 构造方法

</code></pre><p>可以发现第三步和第四步顺序是掉换的，但是根据时间戳知道，第三步是发生在第四部之前，也就是说第三步的普通属性的初始化在构造代码块之前执行。</p>
<h3 id="类什么时候加载？"><a href="#类什么时候加载？" class="headerlink" title="类什么时候加载？"></a>类什么时候加载？</h3><p>加载时机：</p>
<blockquote>
<ol>
<li>其他类引用时候。</li>
<li>类初始化。</li>
</ol>
</blockquote>
<p>加载工具： Classloader(类加载器)</p>
<h3 id="类初始化的方式"><a href="#类初始化的方式" class="headerlink" title="类初始化的方式"></a>类初始化的方式</h3><ol>
<li>实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。</li>
<li>类的静态方法被调用。</li>
<li>类的静态域（静态变量）被赋值。</li>
<li>静态域被访问，而且不是常量（final）。</li>
<li>顶层类中执行 assert 语句。</li>
</ol>
<h3 id="类初始化规则："><a href="#类初始化规则：" class="headerlink" title="类初始化规则："></a>类初始化规则：</h3><ol>
<li>类从顶至底部顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</li>
<li>超类早于子类和衍生类的初始化</li>
<li>如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的初始化即使静态域被子类或子接口或者它的实现类所引用。</li>
<li>接口初始化不会导致父接口的初始化。</li>
<li>静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</li>
<li>非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类。</li>
</ol>
<h2 id="名词说明"><a href="#名词说明" class="headerlink" title="名词说明"></a>名词说明</h2><p><strong>类的初始化和类的实例化是不同的</strong>:<br>类的初始化发生在类实例化之前。</p>
<ul>
<li>静态域=静态变量</li>
</ul>
<pre><code>private static String staticValue =&quot;静态域&quot;;
</code></pre><blockquote>
<p>静态域：如果将类中的域定义为static，则这个域属于这个类，而不属于这个类的某个对象，每个类中只有 一个这样的域，而每一个类对象对于所有的实例域(即没有定义为static的域)都有自己的一份拷贝。例如：</p>
<pre><code>class Employee {
　　private int id;
　　private static String staticValue =&quot;静态域&quot;;
}
</code></pre><p>如果有1000个Employee对象，则有1000个实例域 id，但是只有一个静态域 staticValue；即使没有一个Employee对象，静态域nextId也存在，它属于类，不属于任何对象。</p>
</blockquote>
<ul>
<li>实例域=非静态变量</li>
</ul>
<pre><code>private  String staticValue =&quot;实例域&quot;;
</code></pre><ul>
<li>静态常量=final</li>
</ul>
<pre><code>private final static String staticValue =&quot;静态常量&quot;;
</code></pre><ul>
<li>静态方法</li>
</ul>
<pre><code>public static String getString() {
        System.out.println(&quot;getString()&quot;);
        return &quot;&quot;;
}
</code></pre><ul>
<li>静态代码块</li>
</ul>
<pre><code>static {

}
</code></pre><ul>
<li>构造代码块</li>
</ul>
<pre><code>{
    System.out.println(&quot;构造代码块&quot;);
}

</code></pre><ul>
<li>构造方法</li>
</ul>
<pre><code>class main{

   private main(){
        System.out.println(&quot;构造方法&quot;);
    }
}
</code></pre><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">类加载器</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/JVM/">JVM</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 brokge
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>