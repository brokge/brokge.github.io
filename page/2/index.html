<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Page 2 | 吾与尔</title>

  
  <meta name="author" content="brokge">
  

  

  
  <meta name="keywords" content="吾与尔">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="吾与尔">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="吾与尔" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">吾与尔</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2019/01/08/hello-world/"><span>Hexo 使用说明</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/08/hello-world/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-08T03:02:23.000Z">
          2019-01-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/01/06/Java枚举六问/"><span>Java枚举六问</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/06/Java枚举六问/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-06T07:26:00.000Z">
          2019-01-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="一问：Java-枚举是如何保证线程安全的？"><a href="#一问：Java-枚举是如何保证线程安全的？" class="headerlink" title="一问：Java 枚举是如何保证线程安全的？"></a>一问：Java 枚举是如何保证线程安全的？</h3><blockquote>
<p>答：因为 Java 类加载与初始化是 JVM 保证线程安全，而 Java enum 枚举在编译器编译后的字节码实质是一个 final 类，每个枚举类型是这个 final 类中的一个静态常量属性，其属性初始化是在该 final 类的 static 块中进行，而 static 的常量属性和代码块都是在类加载时初始化完成的，所以自然就是 JVM 保证了并发安全。（不清楚 enum 编译后为啥是静态常量的可以查看历史推送了解更多）</p>
</blockquote>
<h3 id="二问：不使用-synchronized-和-lock如何创建一个线程安全的单例？"><a href="#二问：不使用-synchronized-和-lock如何创建一个线程安全的单例？" class="headerlink" title="二问：不使用 synchronized 和 lock如何创建一个线程安全的单例？"></a>二问：不使用 synchronized 和 lock如何创建一个线程安全的单例？</h3><blockquote>
<p>答：这是一个很 open 的题目，我们平时提到单例并发都是用锁机制，实际抛开锁机制也有几种实现方式可以保证创建单例的并发安全，而且各具特色。</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token comment" spellcheck="true">// 通过枚举实现单例模式</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>
    INSTANCE<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过饿汉模式实现单例</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过静态内部类模式实现单例</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过 CAS（AtomicReference）实现单例模式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AtomicReference<span class="token operator">&lt;</span>Singleton<span class="token operator">></span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Singleton<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Singleton singleton <span class="token operator">=</span> INSTANCE<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> singleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> singleton<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>



<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>可以看到，上面四种方式都可以不使用 synchronized 或者 lock 来保证了单例创建的并发安全。前面三种都是借助了 JVM 的 ClassLoader 类加载初始化保证并发安全的机制（至于 JVM 底层其实也是使用了 synchronized 或者 lock 的机制），而对于最后一种通过 CAS 机制保证了并发安全（至于什么是 CAS 我们后面并发相关每日一题会再详细推送讨论的，这里先记住 CAS 就是一种非阻塞乐观锁机制，是一种基于忙等待的算法，依赖底层硬件实现，相对于锁其没有线程切换和阻塞的额外消耗，但是如果忙等待一直执行不成功的死循环会对 CPU 造成较大的开销），最后一种才是真正的无锁实现。</p>
</blockquote>
<h3 id="四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？"><a href="#四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？" class="headerlink" title="四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？"></a>四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？</h3><blockquote>
<p>答：其实这个题目算是一箭双雕，既考察了 Java 枚举的实质特性又考察了单例模式的一些弊端问题。除过枚举实现的单例模式以外的其他实现方式都有一个比较大的问题是一旦实现了 Serializable 接口后就不再是单例了，因为每次调用 readObject() 方法返回的都是一个新创建出来的对象（当然可以通过使用 readResolve() 方法来避免，但是终归麻烦），而 Java 规范中保证了每一个枚举类型及其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上 Java 做了特殊处理，序列化时 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化时则是通过 java.lang.Enum 的 valueOf 方法来根据名字查找枚举对象，同时禁用了 writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法。<br>这个问题也暴露出另一个新问题，Java 枚举序列化有哪些坑？</p>
</blockquote>
<h3 id="五问：Java-枚举序列化有哪些坑？"><a href="#五问：Java-枚举序列化有哪些坑？" class="headerlink" title="五问：Java 枚举序列化有哪些坑？"></a>五问：Java 枚举序列化有哪些坑？</h3><blockquote>
<p>答：如果我们枚举被序列化本地持久化了，那我们就不能删除原来枚举类型中定义的任何枚举对象，否则程序在运行过程中反序列化时 JVM 就会找不到与某个名字对应的枚举对象了，所以我们要尽量避免多枚举对象序列化的使用（当然了，枚举实现的单例枚举对象一般都不会增删改，所以不存在问题）。</p>
</blockquote>
<h3 id="六问：Java-迭代器和枚举器的区别是什么？"><a href="#六问：Java-迭代器和枚举器的区别是什么？" class="headerlink" title="六问：Java 迭代器和枚举器的区别是什么？"></a>六问：Java 迭代器和枚举器的区别是什么？</h3><blockquote>
<p>答：主要区别如下。<br>Enumeration<e> 枚举器接口是 JDK 1.0 提供的，适用于传统类，而 Iterator<e> 迭代器接口是 JDK 1.2 提供的，适用于 Collections。<br>Enumeration 只有两个方法接口，我们只能读取集合的数据而不能对数据进行修改，而 Iterator 有三个方法接口，除了能读取集合的数据外也能对数据进行删除操作。<br>Enumeration 不支持 fail-fast 机制，而 Iterator 支持 fail-fast 机制（一种错误检测机制，当多线程对集合进行结构上的改变的操作时就有可能会产生 fail-fast 机制，譬如 ConcurrentModificationException 异常）。<br>总归现在尽量使用 Iterator 迭代器而不是 Enumeration 枚举器。</e></e></p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/知识库/">知识库</a>, <a href="/categories/知识库/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Java/">Java</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/01/06/线程池/"><span>Android  线程池</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/06/线程池/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-06T06:46:00.000Z">
          2019-01-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="Android-线程池特点"><a href="#Android-线程池特点" class="headerlink" title="Android  线程池特点"></a>Android  线程池特点</h2><ol>
<li><code>Thread()</code>,<code>AsyncTask</code>适合处理单个任务的场景，<code>HandlerThread</code>适合串行处理多任务的场景。当需要并行的处理多任务之时，<code>ThreadPoolExecutor</code>是更好的选择。</li>
<li>线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。</li>
<li><code>ThreadPool</code>较之<code>HandlerThread</code>在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。</li>
</ol>
<ul>
<li><strong>常用创建线程池的方式 </strong></li>
</ul>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          TimeUnit unit<span class="token punctuation">,</span>
                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>
                          ThreadFactory threadFactory<span class="token punctuation">,</span>
                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                          <span class="token comment" spellcheck="true">//...</span>
                          <span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>具体参数代表的信息，可文章底部的说明。</p>
</blockquote>
<ul>
<li><strong>线程池的分配遵循这样的规则</strong></li>
</ul>
<blockquote>
<ol>
<li>当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；</li>
<li>如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；</li>
<li>如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；</li>
<li>如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且<code>ThreadPoolExecutor</code>会调用<code>RejectedtionHandler</code>的<code>rejectedExecution</code>方法来通知调用者。</li>
</ol>
</blockquote>
<h2 id="实践场景"><a href="#实践场景" class="headerlink" title="实践场景"></a>实践场景</h2><p>从我们现实的业务种，所用到的场景是大同小异。所以官方准备了几个不同类型的线程池。通过工厂方法创建以下类型：</p>
<h5 id="1-newFixThreadPool"><a href="#1-newFixThreadPool" class="headerlink" title="1. newFixThreadPool"></a>1. newFixThreadPool</h5><p>通过<code>Executors</code>的<code>newFixedThreadPool()</code>方法创建，它是个线程数量固定的线程池，该线程池的线程全部为核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。</p>
<pre class="line-numbers language-java"><code class="language-java">ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//todo somthing</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="2-newCachedThreadPool"><a href="#2-newCachedThreadPool" class="headerlink" title="2. newCachedThreadPool"></a>2. newCachedThreadPool</h5><p>通过<code>Executors</code>的<code>newCachedThreadPool()</code>方法来创建，它是一个数量无限多的线程池，它所有的线程都是非核心线程，当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以此线程池适合执行大量耗时小的任务。由于设置了超时时间为60s，所以当线程空闲一定时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token keyword">new</span> <span class="token class-name">CachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        <span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>
        <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例代码：</p>
<pre class="line-numbers language-java"><code class="language-java">ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">CachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//todo somthing</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3. newScheduledThreadPool"></a>3. newScheduledThreadPool</h5><p>通过<code>Executors</code>的<code>newScheduledThreadPool()</code>方法来创建，<code>ScheduledThreadPool</code>线程池像是上两种的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledThreadPool <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>
          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例代码：</p>
<pre class="line-numbers language-java"><code class="language-java">
ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//todo somthing</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4. newSingleThreadExecutor"></a>4. newSingleThreadExecutor</h5><p>通过<code>Executors</code>的<code>newSingleThreadExecutor()</code>方法来创建，它内部只有一个核心线程，它确保所有任务进来都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让调用者可以忽略线程同步问题。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span><span class="token punctuation">(</span>
        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>
        <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> 
        <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例代码：</p>
<pre class="line-numbers language-java"><code class="language-java">
ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">//todo somthing</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h3><p>通过以上代码我们可以看出，所返回的皆是 <code>ExecutorService</code>，一个接口且继承于 <code>Executor</code>;</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> 
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>接口方法：</p>
<ol>
<li><code>shutDown()</code>，关闭线程池，需要执行完已提交的任务；</li>
<li><code>shutDownNow()</code>，关闭线程池，并尝试结束已提交的任务；</li>
<li><code>allowCoreThreadTimeOut(boolen)</code>，允许核心线程闲置超时回收；</li>
<li><code>execute()</code>，提交任务无返回值； </li>
<li><code>submit()</code>，提交任务有返回值；</li>
</ol>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote>
<ol>
<li><code>corePoolSize</code>：核心线程数，如果运行的线程少于<code>corePoolSize</code>，则创建新线程来执行新任务，即使线程池中的其他线程是空闲的</li>
<li><code>maximumPoolSize</code>:最大线程数，可允许创建的线程数，<code>corePoolSize</code>和<code>maximumPoolSize</code>设置的边界自动调整池大小：</li>
<li><code>corePoolSize</code> &lt;运行的线程数&lt; <code>maximumPoolSize</code>:仅当队列满时才创建新线程<br><code>corePoolSize</code>=运行的线程数= <code>maximumPoolSize</code>：创建固定大小的线程池</li>
<li><code>keepAliveTime</code>:如果线程数多于<code>corePoolSize</code>,则这些多余的线程的空闲时间超过<code>keepAliveTime</code>时将被终止</li>
<li><code>unit</code>:<code>keepAliveTime</code>参数的时间单位</li>
<li><code>workQueue</code>:保存任务的阻塞队列，与线程池的大小有关：当运行的线程数少于<code>corePoolSize</code>时，在有新任务时直接创建新线程来执行任务而无需再进队列； 当运行的线程数等于或多于<code>corePoolSize</code>，在有新任务添加时则选加入队列，不直接创建线程； 当队列满时，在有新任务时就创建新线程</li>
<li><code>threadFactory</code>:使用<code>ThreadFactory</code>创建新线程，默认使用<code>defaultThreadFactory</code>创建线程</li>
<li><code>handle</code>:定义处理被拒绝任务的策略，默认使用<code>ThreadPoolExecutor.AbortPolicy</code>,任务被拒绝时将抛出<code>RejectExecutorException</code></li>
</ol>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/并发编程/">并发编程</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2019/01/05/正则/"><span>正则</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2019/01/05/正则/" rel="bookmark">
        <time class="entry-date published" datetime="2019-01-05T11:37:00.000Z">
          2019-01-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>正则表达式在几乎所有语言中都可以使用，无论是前端的 JavaScript、还是后端的 Java、c#。他们都提供相应的接口函数支持正则表达式。</p>
<p>但很神奇的是：无论你大学选择哪一门计算机语言，都没有关于正则表达式的课程给你修，在你学会正则之前，你只能看着那些正则大师们，写了一串外星文似的字符串，替代了你用一大篇幅的 if else代码来做一些数据校验。</p>
<p>既然喜欢，那就动手学呗，可当你百度出一一堆相关资料时，你发现无一不例外的枯燥至极，难以学习（实话说，当年不理君也是这样的心态😂😂）。</p>
<p>下面，不理君尝试用一种比较通俗点的方式讲一下正则，让你能在读完之后，能自己写出一些简单的正则，再不济，能看懂别人写的正则，那也不错了。</p>
<h1 id="一、元字符"><a href="#一、元字符" class="headerlink" title="一、元字符"></a>一、元字符</h1><p>万物皆有缘，正则也是如此，元字符是构造正则表达式的一种基本元素。<br>我们先来记几个常用的元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结束</td>
</tr>
</tbody>
</table>
<p>有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，</p>
<p>比如：</p>
<ol>
<li>匹配有abc开头的字符串：<pre class="line-numbers language-bash"><code class="language-bash">\babc或者^abc
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>匹配8位数字的QQ号码：<pre class="line-numbers language-bash"><code class="language-bash">^\d\d\d\d\d\d\d\d$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>匹配1开头11位数字的手机号码：<pre class="line-numbers language-bash"><code class="language-bash">^1\d\d\d\d\d\d\d\d\d\d$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h1 id="二、重复限定符"><a href="#二、重复限定符" class="headerlink" title="二、重复限定符"></a>二、重复限定符</h1><p>有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？</p>
<p>答案是有的！</p>
<p>为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<p>有了这些限定符之后，我们就可以对之前的正则表达式进行改造了。</p>
<p>比如：</p>
<ol>
<li>匹配8位数字的QQ号码：<pre class="line-numbers language-bash"><code class="language-bash">^\d<span class="token punctuation">{</span>8<span class="token punctuation">}</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>匹配1开头11位数字的手机号码：<pre class="line-numbers language-bash"><code class="language-bash">^1\d<span class="token punctuation">{</span>10<span class="token punctuation">}</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>匹配银行卡号是14~18位的数字：<pre class="line-numbers language-bash"><code class="language-bash">^\d<span class="token punctuation">{</span>14,18<span class="token punctuation">}</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>匹配以a开头的，0个或多个b结尾的字符串<pre class="line-numbers language-bash"><code class="language-bash">^ab*$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h1 id="三、-分组"><a href="#三、-分组" class="headerlink" title="三、 分组"></a>三、 分组</h1><p>从上面的例子（4）中看到，限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要 ab 同时被限定那怎么办呢？</p>
<p><strong>正则表达式中用小括号 <code>()</code> 来做分组，也就是括号中的内容作为一个整体。</strong></p>
<p>因此当我们要匹配多个 ab 时，我们可以这样。<br>如：</p>
<ol>
<li>匹配字符串中包含 0 到多个 ab 开头：<pre class="line-numbers language-bash"><code class="language-bash">^<span class="token punctuation">(</span>ab<span class="token punctuation">)</span>*
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h1 id="四、-转义"><a href="#四、-转义" class="headerlink" title="四、 转义"></a>四、 转义</h1><p>我们看到正则表达式用小括号来做分组。</p>
<p>那么问题来了：<br>如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？</p>
<p>针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。<br>如：</p>
<ol>
<li>要匹配以 (ab) 开头：<pre class="line-numbers language-bash"><code class="language-bash">1 ^<span class="token punctuation">(</span>\<span class="token punctuation">(</span>ab\<span class="token punctuation">))</span>*
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h1 id="五、-条件或"><a href="#五、-条件或" class="headerlink" title="五、 条件或"></a>五、 条件或</h1><p>回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有 130/131/132/155/156/185/186/145/176 等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？</p>
<p><strong>正则用符号 | 来表示或，也叫做分支条件</strong>，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。<br>那么我们就可以用或条件来处理这个问题：</p>
<pre class="line-numbers language-bash"><code class="language-bash">^<span class="token punctuation">(</span>130<span class="token operator">|</span>131<span class="token operator">|</span>132<span class="token operator">|</span>155<span class="token operator">|</span>156<span class="token operator">|</span>185<span class="token operator">|</span>186<span class="token operator">|</span>145<span class="token operator">|</span>176<span class="token punctuation">)</span>\d<span class="token punctuation">{</span>8<span class="token punctuation">}</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="六、区间"><a href="#六、区间" class="headerlink" title="六、区间"></a>六、区间</h1><p>看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？</p>
<p>实际是有的。</p>
<p><strong>正则提供一个元字符中括号 [] 来表示区间条件。</strong></p>
<p>限定 0 到 9 可以写成 <code>[0-9]</code></p>
<p>限定 A-Z 写成 <code>[A-Z]</code></p>
<p>限定某些数字 <code>[165]</code></p>
<p>那上面的正则我们还改成这样：</p>
<pre class="line-numbers language-bash"><code class="language-bash"> ^<span class="token punctuation">((</span>13<span class="token punctuation">[</span>0-2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>15<span class="token punctuation">[</span>56<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>18<span class="token punctuation">[</span>5-6<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span>145<span class="token operator">|</span>176<span class="token punctuation">)</span>\d<span class="token punctuation">{</span>8<span class="token punctuation">}</span>$
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="七、零宽断言"><a href="#七、零宽断言" class="headerlink" title="七、零宽断言"></a>七、零宽断言</h1><p>无论是零宽还是断言，听起来都古古怪怪的，那先解释一下这两个词。</p>
<p><strong>断言</strong>：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”, 正则可以用断言找出 aa2 前面有 bb3，也可以找出 aa2 后面有 ss1.</p>
<p><strong>零宽</strong>：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</p>
<p>意思是讲明白了，那他有什么用呢？<br>我们来举个栗子：<br>假设我们要用爬虫抓取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构。</p>
<pre class="line-numbers language-html"><code class="language-html">"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read-count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>阅读数：641<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中只有‘<strong>641</strong>’这个是一个变量，也就是不同文章有不同的值，当我们拿到这个字符串时，需要获得这里边的‘<strong>641</strong>’有很多种办法，但如果使用正则应该怎么匹配呢？</p>
<p>下面先讲一下几种类型的断言：</p>
<h3 id="1-正向先行断言（正前瞻）"><a href="#1-正向先行断言（正前瞻）" class="headerlink" title="1. 正向先行断言（正前瞻）"></a>1. 正向先行断言（正前瞻）</h3><p><strong>语法</strong>：<code>（?=pattern）</code></p>
<p><strong>作用</strong>：++匹配 pattern 表达式的前面内容，不返回本身。++<br>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到<code>&lt;/span&gt;</code>前面的数字内容按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:<code>(?=&lt;/span&gt;)</code> 就可以匹配到前面的内容了。匹配什么内容呢？如果要所有内容那就是：</p>
<pre class="line-numbers language-java"><code class="language-java"> String reg<span class="token operator">=</span><span class="token string">".+(?=&lt;/span>)"</span><span class="token punctuation">;</span>

 String test <span class="token operator">=</span> <span class="token string">"&lt;span class=\"read-count\">阅读数：641&lt;/span>"</span><span class="token punctuation">;</span>
 Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
 Matcher mc<span class="token operator">=</span>    pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token punctuation">)</span>
   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出：</p>
<pre class="line-numbers language-html"><code class="language-html"># 匹配结果：
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read-count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>阅读数：641
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 <code>\d</code>, 那可以改成：</p>
<pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"\\d+(?=&lt;/span>)"</span><span class="token punctuation">;</span>
String test <span class="token operator">=</span> <span class="token string">"&lt;span class=\"read-count\">阅读数：641&lt;/span>"</span><span class="token punctuation">;</span>
Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher mc<span class="token operator">=</span>    pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<pre><code>//匹配结果：
641
</code></pre><p>大功告成！</p>
<h3 id="2-正向后行断言（正后顾）"><a href="#2-正向后行断言（正后顾）" class="headerlink" title="2. 正向后行断言（正后顾）"></a>2. 正向后行断言（正后顾）</h3><p><strong>语法</strong>：<code>（?&lt;=pattern）</code></p>
<p><strong>作用</strong>：匹配 pattern表达式的后面的内容，不返回本身。</p>
<p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。</p>
<p>上面的栗子，我们也可以用后行断言来处理：</p>
<pre class="line-numbers language-bash"><code class="language-bash"> <span class="token punctuation">(</span>?<span class="token operator">&lt;=</span><span class="token operator">&lt;</span>span class<span class="token operator">=</span><span class="token string">"read-count"</span><span class="token operator">></span>阅读数：<span class="token punctuation">)</span>\d+
 String reg<span class="token operator">=</span><span class="token string">"(?&lt;=&lt;span class=\"read-count\">阅读数：)\\d+"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java"><code class="language-java"> String test <span class="token operator">=</span> <span class="token string">"&lt;span class=\"read-count\">阅读数：641&lt;/span>"</span><span class="token punctuation">;</span>
 Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
 Matcher mc<span class="token operator">=</span>    pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 输出</p>
<pre><code># 匹配结果：
641
</code></pre><p>就这么简单。</p>
<h3 id="3-负向先行断言（负前瞻）"><a href="#3-负向先行断言（负前瞻）" class="headerlink" title="3. 负向先行断言（负前瞻）"></a>3. 负向先行断言（负前瞻）</h3><p><strong>语法</strong>：<code>(?!pattern)</code></p>
<p><strong>作用</strong>：匹配非 pattern 表达式的前面内容，不返回本身。</p>
<p>有正向也有负向，负向在这里其实就是非的意思。</p>
<blockquote>
<p>举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”<br>现在要找到不是’的花朵’前面的祖国</p>
</blockquote>
<p>用正则就可以这样写：</p>
<pre class="line-numbers language-bash"><code class="language-bash">祖国<span class="token punctuation">(</span>?<span class="token operator">!</span>的花朵<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="4-负向后行断言（负后顾）"><a href="#4-负向后行断言（负后顾）" class="headerlink" title="4. 负向后行断言（负后顾）"></a>4. 负向后行断言（负后顾）</h3><p><strong>语法</strong>：<code>(?&lt;!pattern)</code></p>
<p><strong>作用</strong>：匹配非 pattern</p>
<p>表达式的后面内容，不返回本身。</p>
<h1 id="八、捕获和非捕获"><a href="#八、捕获和非捕获" class="headerlink" title="八、捕获和非捕获"></a>八、捕获和非捕获</h1><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”。</p>
<p><strong>捕获组</strong>：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p>
<p>而根据命名方式的不同，又可以分为两种组：</p>
<h3 id="1-数字编号捕获组："><a href="#1-数字编号捕获组：" class="headerlink" title="1. 数字编号捕获组："></a>1. 数字编号捕获组：</h3><p><strong>语法</strong>：<code>(exp)</code></p>
<p><strong>解释</strong>：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第 0 组为整个表达式，第一组开始为分组。<br>比如固定电话的：020-85653333<br>他的正则表达式为：(0\d{2})-(\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>编号</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody>
</table>
<p>我们用Java来验证一下：</p>
<pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"020-85653333"</span><span class="token punctuation">;</span>
String reg<span class="token operator">=</span><span class="token string">"(0\\d{2})-(\\d{8})"</span><span class="token punctuation">;</span>
Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分组的个数有："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"个分组为："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>分组的个数有：2
第0个分组为：020-85653333
第1个分组为：020
第2个分组为：85653333
</code></pre><p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p>
<h3 id="2-命名编号捕获组"><a href="#2-命名编号捕获组" class="headerlink" title="2. 命名编号捕获组"></a>2. 命名编号捕获组</h3><p><strong>语法</strong>：<code>(?&lt;name&gt;exp)</code></p>
<p><strong>解释</strong>：分组的命名由表达式中的 name 指定<br>比如区号也可以这样写:<code>(?&lt;quhao&gt;\0\d{2})-(?&lt;haoma&gt;\d{8})</code>，按照左括号的顺序，这个表达式有如下分组：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>分组</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>(0\d{2})-(\d{8})</td>
<td>020-85653333</td>
</tr>
<tr>
<td>1</td>
<td>quhao</td>
<td>(0\d{2})</td>
<td>020</td>
</tr>
<tr>
<td>2</td>
<td>haoma</td>
<td>(\d{8})</td>
<td>85653333</td>
</tr>
</tbody>
</table>
<p>用代码来验证一下：</p>
<pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"020-85653333"</span><span class="token punctuation">;</span>
String reg<span class="token operator">=</span><span class="token string">"(?&lt;quhao>0\\d{2})-(?&lt;haoma>\\d{8})"</span><span class="token punctuation">;</span>
Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分组的个数有："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">"quhao"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">"haoma"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>分组的个数有：2
分组名称为:quhao,匹配内容为：020

分组名称为:haoma,匹配内容为：85653333

</code></pre><h3 id="3-非捕获组"><a href="#3-非捕获组" class="headerlink" title="3. 非捕获组"></a>3. 非捕获组</h3><p><strong>语法</strong>：<code>(?:exp)</code></p>
<p><strong>解释</strong>：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</p>
<p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：</p>
<pre><code>(?:\0\d{2})-(\d{8})
</code></pre><p>序号    |编号    |分组    |内容<br>0    |0    |(0\d{2})-(\d{8})    |020-85653333<br>1    |1    |(\d{8})    |85653333<br>验证一下：</p>
<pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"020-85653333"</span><span class="token punctuation">;</span>
String reg<span class="token operator">=</span><span class="token string">"(?:0\\d{2})-(\\d{8})"</span><span class="token punctuation">;</span>
Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分组的个数有："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> fi<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"个分组为："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>分组的个数有：1
第0个分组为：020-85653333
第1个分组为：85653333
</code></pre><h1 id="九、-反向引用"><a href="#九、-反向引用" class="headerlink" title="九、 反向引用"></a>九、 反向引用</h1><p>上面讲到捕获，我们知道：捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。</p>
<p>根据捕获组的命名规则，反向引用可分为：</p>
<ol>
<li>数字编号组反向引用：\k 或\number</li>
<li>命名编号组反向引用：\k 或者\’name’</li>
</ol>
<p>好了 讲完了，懂吗？不懂！！！</p>
<p>可能连前面讲的捕获有什么用都还不懂吧？</p>
<p>其实只是看完捕获不懂不会用是很正常的！</p>
<p>因为捕获组通常是和反向引用一起使用的</p>
<p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。</p>
<p>注意两个字眼：“内容” 和 “使用”。<br>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住。</p>
<p>那这里所说的“使用”是怎样使用呢？</p>
<p>因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。</p>
<p>还是举栗子吧：</p>
<p>比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母。</p>
<p>如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，现在我们先用程序思维理一下思路：</p>
<blockquote>
<ol>
<li>匹配到一个字母</li>
<li>匹配第下一个字母，检查是否和上一个字母是否一样</li>
<li>如果一样，则匹配成功，否则失败</li>
</ol>
</blockquote>
<p>这里的思路 2 中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？</p>
<p>这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件。</p>
<p>好了，有思路就要实践</p>
<p>首先匹配一个字母：<code>\w</code>，我们需要做成分组才能捕获，因此写成这样：<code>(\w)</code><br>那这个表达式就有一个捕获组：<code>（\w）</code><br>然后我们要用这个捕获组作为条件，那就可以：<code>(\w)\1</code>这样就大功告成了</p>
<p>可能有人不明白了，<code>\1</code> 是什么意思呢？</p>
<p>还记得捕获组有两种命名方式吗，一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名在默认情况下都是以数字来命名，而且数字命名的顺序是从 1 开始的。</p>
<p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 <code>\k&lt;1&gt;</code>或者<code>\1</code>，当然，通常都是是后者。</p>
<p>我们来测试一下：</p>
<pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"aabbbbgbddesddfiid"</span><span class="token punctuation">;</span>
Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"(\\w)\\1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>1aa
2bb
3bb
4dd
5dd
6ii
</code></pre><p>嗯，这就是我们想要的了。</p>
<p>在举个替换的例子，假如想要把字符串中abc换成a。</p>
<pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"abcbbabcbcgbddesddfiid"</span><span class="token punctuation">;</span>
String reg<span class="token operator">=</span><span class="token string">"(a)(b)c"</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">"$1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>abbabcgbddesddfiid
</code></pre><h1 id="十、贪婪和非贪婪"><a href="#十、贪婪和非贪婪" class="headerlink" title="十、贪婪和非贪婪"></a>十、贪婪和非贪婪</h1><h3 id="1-贪婪"><a href="#1-贪婪" class="headerlink" title="1. 贪婪"></a>1. 贪婪</h3><p>我们都知道，贪婪就是不满足，尽可能多的要。在正则中，贪婪也是差不多的意思:</p>
<p><strong>贪婪匹配</strong>：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。</p>
<p><strong>特性</strong>：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配 - 舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p>
<p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p>
<pre><code>\d{3,6}

</code></pre><p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p>
<p>如:</p>
<pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"\\d{3,6}"</span><span class="token punctuation">;</span>        
String test<span class="token operator">=</span><span class="token string">"61762828 176 2991 871"</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文本："</span><span class="token operator">+</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"贪婪模式："</span><span class="token operator">+</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Pattern p1 <span class="token operator">=</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher m1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token operator">+</span>m1<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>文本：61762828 176 2991 44 871
贪婪模式：\d{3,6}
匹配结果：617628
匹配结果：176
匹配结果：2991
匹配结果：871
</code></pre><p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个<code>（617）</code>就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。</p>
<p>一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p>
<p>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p>
<pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"(\\d{1,2})(\\d{3,4})"</span><span class="token punctuation">;</span>        
String test<span class="token operator">=</span><span class="token string">"61762828 176 2991 87321"</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文本："</span><span class="token operator">+</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"贪婪模式："</span><span class="token operator">+</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Pattern p1 <span class="token operator">=</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher m1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token operator">+</span>m1<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>文本：61762828 176 2991 87321
贪婪模式：(\d{1,2})(\d{3,4})
匹配结果：617628
匹配结果：2991
匹配结果：87321

</code></pre><blockquote>
<p>“617628” 是前面的\d{1,2}匹配出了 61，后面的匹配出了 7628<br>“2991” 是前面的\d{1,2}匹配出了 29 ，后面的匹配出了 91<br>“87321”是前面的\d{1,2}匹配出了 87，后面的匹配出了 321</p>
</blockquote>
<h3 id="2-懒惰（非贪婪）"><a href="#2-懒惰（非贪婪）" class="headerlink" title="2. 懒惰（非贪婪）"></a>2. 懒惰（非贪婪）</h3><p><strong>懒惰匹配</strong>：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。</p>
<p><strong>特性</strong>: 从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。<br>懒惰量词是在贪婪量词后面加个“？”</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"(\\d{1,2}?)(\\d{3,4})"</span><span class="token punctuation">;</span>        
String test<span class="token operator">=</span><span class="token string">"61762828 176 2991 87321"</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文本："</span><span class="token operator">+</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"贪婪模式："</span><span class="token operator">+</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Pattern p1 <span class="token operator">=</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>
Matcher m1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token operator">+</span>m1<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>文本：61762828 176 2991 87321
贪婪模式：(\d{1,2}?)(\d{3,4})
匹配结果：61762
匹配结果：2991
匹配结果：87321
</code></pre><p>解答：</p>
<blockquote>
<p>“61762” 是左边的懒惰匹配出 6，右边的贪婪匹配出 1762 </p>
<p>“2991” 是左边的懒惰匹配出 2，右边的贪婪匹配出 991</p>
<p>“87321” 左边的懒惰匹配出 8，右边的贪婪匹配出 7321</p>
</blockquote>
<h1 id="十一、-反义"><a href="#十一、-反义" class="headerlink" title="十一、 反义"></a>十一、 反义</h1><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody>
</table>
<p>正则知识就讲到这里，正则是一门博大精深的语言，其实学会它的一些语法和知识点还算不太难，但想要做到真正学以致用能写出非常 6的正则。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/知识库/">知识库</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/正则/">正则</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/01/大学/"><span>大学</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/01/大学/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-01T11:20:40.000Z">
          2018-11-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始，知所先后，则近道矣。古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先脩其身；欲脩其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知，致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身脩，身脩而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，壹是皆以脩身为本。其本乱而末治者否矣，其所厚者薄，而其所薄者厚，未之有也！此谓知本，此谓知之至也。</p>
<p>所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也！小人闲居为不善，无所不至，见君子而后厌然，揜其不善，而著其善。人之视己，如见其肺肝然，则何益矣！此谓诚于中，形于外，故君子必慎其独也。曾子曰：「十目所视，十手所指，其严乎！」富润屋，德润身，心广体胖，故君子必诚其意。</p>
<p>《诗》云：「瞻彼淇澳，菉竹猗猗。有斐君子，如切如磋，如琢如磨。瑟兮僩兮，赫兮喧兮。有斐君子，终不可喧兮！」「如切如磋」者，道学也；「如琢如磨」者，自脩也；「瑟兮僩兮」者，恂慄也；「赫兮喧兮」者，威仪也；「有斐君子，终不可喧兮」者，道盛德至善，民之不能忘也。《诗》云：「於戏，前王不忘！」君子贤其贤而亲其亲，小人乐其乐而利其利，此以没世不忘也。</p>
<p>《康诰》曰：「克明德。」《太甲》曰：「顾諟天之明命。」《帝典》曰：「克明峻德。」皆自明也。</p>
<p>汤之《盘铭》曰：「茍日新，日日新，又日新。」《康诰》曰：「作新民。」《诗》曰：「周虽旧邦，其命维新。」是故君子无所不用其极。<br>《诗》云：「邦畿千里，维民所止。」《诗》云：「缗蛮黄鸟，止于丘隅。」子曰：「於止，知其所止，可以人而不如鸟乎？」《诗》云：「穆穆文王，於缉熙敬止！」为人君，止于仁；为人臣止于敬；为人子，止于孝；为人父，止于慈；与国人交，止于信。</p>
<p>子曰：「听讼，吾犹人也，必也使无讼乎！」无情者不得尽其辞，大畏民志。此谓知本。</p>
<p>所谓脩身在正其心者，身有所忿懥，则不得其正；有所恐惧，则不得其正；有所好乐，则不得其正；有所忧患，则不得其正。心不在焉，视而不见，听而不闻，食而不知其味。此谓脩身在正其心。</p>
<p>所谓齐其家在脩其身者，人之其所亲爱而辟焉，之其所贱恶而辟焉，之其所畏敬而辟焉，之其所哀矜而辟焉，之其所敖惰而辟焉。故好而知其恶，恶而知其美者，天下鲜矣！故谚有之曰：「人莫知其子之恶，莫知其苗之硕。」此谓身不脩，不可以齐其家。</p>
<p>所谓治国必先齐其家者，其家不可教而能教人者，无之。故君子不出家而成教于国：孝者，所以事君也；弟者，所以事长也；慈者，所以使众也。《康诰》曰：「如保赤子」，心诚求之，虽不中，不远矣。未有学养子而后嫁者也！一家仁，一国兴仁；一家让，一国兴让；一人贪戾，一国作乱。其机如此。此谓一言偾事，一人定国。尧、舜率天下以仁，而民从之；桀、纣率天下以暴，而民从之。其所令反其所好，而民不从。是故君子有诸己而后求诸人，无诸己而后非诸人。所藏乎身不恕，而能喻诸人者，未之有也。故治国在齐其家。《诗》云：「桃之夭夭，其叶蓁蓁；之子于归，宜其家人。」宜其家人，而后可以教国人。《诗》云：「宜兄宜弟。」宜兄宜弟，而后可以教国人。《诗》云：「其仪不忒，正是四国。」其为父子兄弟足法，而后民法之也。此谓治国在齐其家。</p>
<p>所谓平天下在治其国者，上老老而民兴孝，上长长而民兴弟，上恤孤而民不倍，是以君子有絜矩之道也。所恶于上，毋以使下；所恶于下，毋以事上；所恶于前，毋以先后；所恶于后，毋以从前；所恶于右，毋以交于左；所恶于左，毋以交于右。此之谓絜矩之道。</p>
<p>《诗》云：「乐只君子，民之父母。」民之所好好之，民之所恶恶之，此之谓民之父母。《诗》云：「节彼南山，维石岩岩。赫赫师尹，民具尔瞻。」有国者不可以不慎，辟，则为天下戮矣。《诗》云：「殷之未丧师，克配上帝。仪监于殷，峻命不易。」道得众则得国，失众则失国。是故君子先慎乎德。有德此有人，有人此有土，有土此有财，有财此有用。德者本也，财者末也。外本内末，争民施夺。是故财聚则民散，财散则民聚。是故言悖而出者，亦悖而入；货悖而入者，亦悖而出。《康诰》曰：「惟命不于常！」道善则得之，不善则失之矣。《楚书》曰：「楚国无以为宝，惟善以为宝。」舅犯曰：「亡人无以为宝，仁亲以为宝。」《秦誓》曰：「若有一介臣，断断兮无他技，其心休休焉，其如有容焉。人之有技，若己有之；人之彦圣，其心好之，不啻若自其口出。实能容之，以能保我子孙黎民，尚亦有利哉！人之有技，媢嫉以恶之；人之彦圣，而违之俾不通。实不能容，以不能保我子孙黎民，亦曰殆哉！」唯仁人放流之，迸诸四夷，不与同中国，此谓唯仁人为能爱人，能恶人。见贤而不能举，举而不能先，命也；见不善而不能退，退而不能远，过也。</p>
<p>好人之所恶，恶人之所好，是谓拂人之性，菑必逮夫身。是故君子有大道，必忠信以得之，骄泰以失之。</p>
<p>生财有大道，生之者众，食之者寡，为之者疾，用之者舒，则财恒足矣。仁者以财发身，不仁者以身发财。未有上好仁而下不好义者也，未有好义其事不终者也，未有府库财非其财者也。孟献子曰：「畜马乘，不察于鸡豚；伐冰之家，不畜牛羊；百乘之家，不畜聚敛之臣。与其有聚敛之臣，宁有盗臣。」此谓国不以利为利，以义为利也。长国家而务财用者，必自小人矣。彼为善之，小人之使为国家，菑害并至。虽有善者，亦无如之何矣！此谓国不以利为利，以义为利也。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">Prev</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2019 brokge
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>