<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>玉蘇子</title><meta property="og:type" content="blog"><meta property="og:title" content="玉蘇子"><meta property="og:url" content="https://brokge.github.io/"><meta property="og:site_name" content="玉蘇子"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://brokge.github.io/img/og_image.png"><meta property="article:author" content="brokge"><meta property="article:tag" content="玉苏子"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://brokge.github.io"},"headline":"玉蘇子","image":["https://brokge.github.io/img/og_image.png"],"author":{"@type":"Person","name":"brokge"},"description":null}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="玉蘇子" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/scrapy">ScrapyDoc</a><a class="navbar-item" href="/tags">tag</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-07-24T13:07:42.000Z" title="2019-07-24T13:07:42.000Z">2019-07-24</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">7 分钟 读完 (大约 1026 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/24/Android-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-LinkedHashMap/">Android 数据结构之 LinkedHashMap</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">原理分析：</a></li>
<li><a href="#%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8">场景使用</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->



<h2><span id="原理分析">原理分析：</span></h2><p> LinkedHashMap 是 HashMap 的子类，其在 HashMap 的基础上只添加了一个双向链表和一个顺序模式属性，其每次 put 元素都会往这个双向链表上添加节点，其构造方法比 HashMap 多了一个 boolean 类型的 accessOrder 参数，当该参数为 true 时则按照元素最后访问时间在双向链表中排序，为 false 则按照插入顺序排序，默认为 false。<br> 具体源码如下：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * The head of the doubly linked list.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> header<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>


    <span class="token keyword">public</span> <span class="token function">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>
                         <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span>
                         <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>LinkedHashMap 继承自 HashMap，所以其 put 和 get 操作重写了父类的实现</p>
<pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**
     * This override differs from addEntry in that it doesn't resize the
     * table or remove the eldest entry.
     */</span>
    <span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        HashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> old <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMapEntry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token punctuation">;</span>
        table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">addBefore</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span><span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


 <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMapEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMapEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>

    LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>

    <span class="token function">LinkedHashMapEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> HashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * Removes this entry from the linked list.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            before<span class="token punctuation">.</span>after <span class="token operator">=</span> after<span class="token punctuation">;</span>
            after<span class="token punctuation">.</span>before <span class="token operator">=</span> before<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * Inserts this entry before the specified existing entry in the list.
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addBefore</span><span class="token punctuation">(</span>LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> existingEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            after  <span class="token operator">=</span> existingEntry<span class="token punctuation">;</span>
            before <span class="token operator">=</span> existingEntry<span class="token punctuation">.</span>before<span class="token punctuation">;</span>
            before<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            after<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * This method is invoked by the superclass whenever the value
     * of a pre-existing entry is read by Map.get or modified by Map.set.
     * If the enclosing Map is access-ordered, it moves the entry
     * to the end of the list; otherwise, it does nothing.
     */</span>
    <span class="token keyword">void</span> <span class="token function">recordAccess</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            LinkedHashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lm <span class="token operator">=</span> <span class="token punctuation">(</span>LinkedHashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>m<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lm<span class="token punctuation">.</span>accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                lm<span class="token punctuation">.</span>modCount<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">addBefore</span><span class="token punctuation">(</span>lm<span class="token punctuation">.</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">recordRemoval</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

 <span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到 LinkedHashMapMap 中所有 put 进来的 Entry 最终除过按照 HashMap 的 put 操作进行哈希表存储后又额外添加进了一个以 head 为头结点的双向循环链表尾部。==所以说 KinkedHashMap 完全具备 HashMap 的所有特性，也允许 key 和 value 为 null 值，此外自己比 HashMap 厉害的地方在于保证了访问的有序性==。</p>
<p>接着在进行迭代器访问时与 HashMap 的区别在于 LinkedHashMap 是直接迭代遍历操作其自己维护的双向有序链表，以此来保证顺序性，如下：</p>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashIterator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> nextEntry    <span class="token operator">=</span> header<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastReturned <span class="token operator">=</span> null<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */</span>
        <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> nextEntry <span class="token operator">!=</span> header<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> null<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            LinkedHashMap<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            lastReturned <span class="token operator">=</span> null<span class="token punctuation">;</span>
            expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">nextEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextEntry <span class="token operator">==</span> header<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> lastReturned <span class="token operator">=</span> nextEntry<span class="token punctuation">;</span>
            nextEntry <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>
            <span class="token keyword">return</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以 <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，除过具备 <code>HashMap</code> 的一切优缺点外自身具备插入有序性或者访问有序性，其实现依赖 <code>HashMap</code> 自身的存储结构不变外在 put、get 操作处添加了一个对自己内部维护的双向有序链表的操作。</p>
<h2><span id="场景使用">场景使用</span></h2><ol>
<li>LRU 的结合：</li>
</ol>
<blockquote>
<p>LRU 是一种流行的替换算法，它的全称是 <code>Least Recently Used</code>，最近最少使用，常常在缓存设计的场景中充当一种策略，它的核心思路是最近刚被使用的很快再次被用的可能性最高，而最久没被访问的很快再次被用的可能性最低，所以被优先清理。</p>
</blockquote>
<ol start="2">
<li>LRU 容器的实现</li>
</ol>
<blockquote>
<p>在添加元素到<code> LinkedHashMap</code> 后会调用 <code>removeEldesEntry</code>方法，传递的参数是最久没被访问的键值对，如果这个方法返回<code>true</code> 则这个最久的键值对就会被删除，<code>LinkedHashMap</code>的实现总是返回<code>false</code>，所有容量没有限制。</p>
</blockquote>
<ul>
<li>LinkedHashMap 的实现<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>重写后的实现</li>
</ul>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> extents LinkedHashMap<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> maxEntries<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxEntries<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">0.75</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>maxEntries<span class="token operator">=</span>maxEntries<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldesEntry</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> eldest<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>maxentries<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-07-16T13:09:53.000Z" title="2019-07-16T13:09:53.000Z">2019-07-16</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">13 分钟 读完 (大约 1941 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/16/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/">Android 性能优化总结</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><p><a href="#%E7%94%A8%E6%88%B7%E6%89%8B%E4%B8%AD%E5%A5%BD%E7%9A%84%E5%BA%94%E7%94%A8%E6%8C%87%E6%A0%87">用户手中好的应用指标：</a></p>
</li>
<li><p><a href="#%E7%94%A8%E6%88%B7%E6%89%8B%E4%B8%AD%E5%A5%BD%E7%9A%84%E5%BA%94%E7%94%A8%E6%8C%87%E6%A0%87">用户手中好的应用指标：</a></p>
</li>
<li><p><a href="#android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93">Android 性能优化总结</a></p>
<ul>
<li><a href="#%E7%9B%AE%E6%A0%87">目标:</a></li>
<li><a href="#%E5%BB%BA%E8%AE%AE">建议：</a><ul>
<li><a href="#1-%E6%B5%81%E7%95%85">1. 流畅</a></li>
<li><a href="#2-%E7%A8%B3%E5%AE%9A">2. 稳定</a></li>
<li><a href="#21%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96">2.1.内存优化</a></li>
<li><a href="#22-%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F">2.2. 提高代码质量</a></li>
<li><a href="#3-%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96">3. 电量优化</a></li>
<li><a href="#4-%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F">4. 安装包大小</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<h2><span id="用户手中好的应用指标">用户手中好的应用指标：</span></h2><ol>
<li>满足需求</li>
<li>合理的交互</li>
<li>高性能</li>
</ol>
<h2><span id="android-性能优化总结">Android 性能优化总结</span></h2><h4><span id="目标">目标:</span></h4><ol>
<li>流畅</li>
<li>稳定</li>
<li>省电、省流量</li>
<li>安装包小</li>
</ol>
<p>简称： 快、稳、省、小</p>
<h4><span id="建议">建议：</span></h4><h5><span id="1-流畅">1. 流畅</span></h5><p>卡顿场景：<br>UI 绘制、应用启动、页面跳转、事件响应</p>
<p>卡顿原因：</p>
<ol>
<li>界面绘制。<blockquote>
<p>主要原因是绘制的层级深、页面复杂、刷新不合理，由于这些原因导致卡顿的场景更多出现在 UI 和启动后的初始界面以及跳转到页面的绘制上。</p>
</blockquote>
</li>
<li>数据处理。<blockquote>
<p>导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，一是数据在处理 UI 线程，二是数据处理占用 CPU 高，导致主线程拿不到时间片，三是内存增加导致 GC 频繁，从而引起卡顿。</p>
</blockquote>
</li>
</ol>
<p>UI 绘制:</p>
<p>原理： Android 应用程序把经过Measure、Layout、Draw后的 surface 缓存数据，通过 SurfaceFlinger 服务把数据渲染到显示屏幕上， 通过 Android 的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕上。</p>
<p>卡顿根本原因：</p>
<ol>
<li>绘制任务太重，绘制一帧内容耗时太长。</li>
<li>主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧。</li>
</ol>
<p>常用工具：<br>通过性能分析工具 Profile GPU Rendering、TraceView、Systrace UI 性能分析<br>找出出现问题的点，然后解决。</p>
<p>优化建议：</p>
<ol>
<li>布局优化</li>
<li>避免过度绘制</li>
<li>启动优化</li>
<li>合理的刷新机制</li>
<li>在实现动画效果时，需要根据不同场景选择合适的动画框架来实现。有些情况下，可以用硬件加速方式来提供流畅度。</li>
</ol>
<h5><span id="2-稳定">2. 稳定</span></h5><blockquote>
<p>Android 应用的稳定性定义很宽泛，影响稳定性的原因很多，比如内存使用不合理、代码异常场景考虑不周全、代码逻辑不合理等，都会对应用的稳定性造成影响。其中最常见的两个场景是：Crash 和 ANR，这两个错误将会使得程序无法使用，比较常用的解决方式如下：</p>
</blockquote>
<h5><span id="21内存优化">2.1.内存优化</span></h5><p>虚拟机有两种运行模式：Dalvik 和 ART。</p>
<p>Android 内存控制权 Generational Heap Memory 。</p>
<ul>
<li>对象的生命周期：</li>
</ul>
<p>创建阶段-&gt;应用阶段-&gt;不可见阶段-&gt;不可达阶段-&gt;收集阶段-&gt;终结阶段-&gt;对象空间重新分配阶段</p>
<p>Zygote 进程是所有的应用程序进程之父。</p>
<p>每个应用 都有 Dalvik Heap Size 最大阈值。有 RAM 大小不同会有所差异。</p>
<ul>
<li>内存回收<br>young Generation(年轻代)、Old Generation(年老代)、Permanent Generation(持久代)</li>
</ul>
<p>根据对象的生命周期、所处的代区域、不同的内存数据类型，执行不同的GC 操作。</p>
<blockquote>
<p>分配的对象会存放在 Young Generation 区域。对象在某个时机触发 GC 回收垃圾，而没有回收的就根据不同规则，有可能被移动到 Old Generation，最后累积一定时间在移动到 Permanent Generation 区域。系统会根据内存中不同的内存数据类型分别执行不同的 GC 操作。GC 通过确定对象是否被活动对象引用来确定是否收集对象，进而动态回收无任何引用的对象占据的内存空间。但需要注意的是频繁的 GC 会增加应用的卡顿情况，影响应用的流畅性，因此需要尽量减少系统 GC 行为，以便提高应用的流畅度，减小卡顿发生的概率。</p>
</blockquote>
<p>分析工具：</p>
<ol>
<li>Memory Monitor</li>
<li>Heap Viewer</li>
<li>Allocation Tracker</li>
<li>Memory Analyzer Tool(MAT)</li>
<li>LeakCanary 第三方库.</li>
</ol>
<p>常见内存泄漏场景:</p>
<ol>
<li>资源性对象未关闭。比如Cursor、File文件等，往往都用了一些缓冲，在不使用时，应该及时关闭它们。</li>
<li>注册对象未注销。比如事件注册后未注销，会导致观察者列表中维持着对象的引用。</li>
<li>类的静态变量持有大数据对象。</li>
<li>非静态内部类的静态实例.</li>
<li>Handler临时性内存泄漏。如果Handler是非静态的，容易导致 Activity 或 Service 不会被回收。</li>
<li>容器中的对象没清理造成的内存泄漏。</li>
<li>WebView。WebView 存在着内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。</li>
</ol>
<p>优化内存空间：</p>
<ol>
<li>对象引用。强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。</li>
<li>减少不必要的内存开销。注意自动装箱，增加内存复用，比如有效利用系统自带的资源、视图复用、对象池、Bitmap对象的复用。</li>
<li>使用最优的数据类型。比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，使用缓存Lrucache等等。</li>
<li>图片内存优化。可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等等。</li>
</ol>
<h5><span id="22-提高代码质量">2.2. 提高代码质量</span></h5><blockquote>
<p>提高代码质量。比如开发期间的代码审核，看些代码设计逻辑，业务合理性等。<br>代码静态扫描工具。常见工具有Android Lint、Findbugs、Checkstyle、PMD等等。<br>Crash监控。把一些崩溃的信息，异常信息及时地记录下来，以便后续分析解决。<br>Crash上传机制。在Crash后，尽量先保存日志到本地，然后等下一次网络正常时再上传日志信息。</p>
</blockquote>
<h5><span id="3-电量优化">3. 电量优化</span></h5><ol>
<li>优化耗时的计算。</li>
</ol>
<h5><span id="4-安装包大小">4. 安装包大小</span></h5><ol>
<li>代码混淆。</li>
<li>资源优化。比如使用 Android Lint 删除冗余资源。</li>
<li>图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数、使用 WebP图片格式等。</li>
<li>避免重复功能的库。</li>
<li>插件化。</li>
</ol>
<h3><span id="参考">参考</span></h3><ul>
<li><a href="https://blog.dxdoctor.com/2019/06/30/Android-%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/">Android 应用内存分析</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-07-10T13:20:58.000Z" title="2019-07-10T13:20:58.000Z">2019-07-10</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">18 分钟 读完 (大约 2680 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/07/10/Android-Bundle/">Android Bundle 详解 </a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<pre><code>  - [实现](#%E5%AE%9E%E7%8E%B0)
  - [源码分析](#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)</code></pre>
<ul>
<li><a href="#parcelable">Parcelable</a><ul>
<li><a href="#parcel-%E6%98%AF%E4%BB%80%E4%B9%88">Parcel 是什么？</a></li>
<li><a href="#parcelable-%E5%9C%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E7%94%A8%E6%B3%95">Parcelable 在数据传递的用法</a></li>
</ul>
</li>
<li><a href="#serializable">Serializable</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3%E5%8D%B3%E5%8F%AF%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%86%E5%91%A2">为什么定义标记接口即可实现序列化了呢？</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%90%8E">最后</a><ul>
<li><a href="#%E4%B8%A4%E8%80%85%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7">两者的设计初衷：</a></li>
<li><a href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">两者的区别：</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景：</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<p>我们都知道，在 Android 应用开发中，需要数据和状态的传递，其中还包括在 跨进程 之间的传递 （比如 IPC/Binder）。关于数据传递有多种方式，其中最常见的就是通过 Bundle 。Bundle 中文意思：捆; 一批，顾名思义就很直观了。</p>
<p>Bundle 相当于传输过程的邮包，里面包裹的是具体的数据。</p>
<h5><span id="实现">实现</span></h5><p>Activity 之间可以通过 创建 intent 并传递参数 的方式来传递，</p>
<pre class="line-numbers language-java"><code class="language-java">Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> MyActivity<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span><span class="token string">"media_id"</span><span class="token punctuation">,</span> <span class="token string">"a1b2c3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在当前 Activity 打包数据，在 目标 Activity 解包数据。</p>
<blockquote>
<p>通过查看 Api ,我们可以知道 一些常规数据类型，如：int、string、boolean 等经过简单的设置，都没什么问题。但是我们如果想通过一定机制，传递一些复杂的复合对象呢？<br>这就需要 Parcelables 了。<br>传递复杂数据 可以查看相应的文章。</p>
</blockquote>
<ul>
<li>通过 Bundle 进行数据，要注意以下问题</li>
</ul>
<ol>
<li>复杂对象 通过  Parcelables 或者 seriable。</li>
<li>对象最大 不能超过 1 mb,否则会出现 <code>TransactionTooLargeException</code> 错误。7.0 (API level 24) 或更高系统上会报出，其他系统会有警告log。</li>
<li><code>savedInstanceState</code> 保存数据状态，系统运行中这些保存的数据会一直存在，所以尽可能小于 50kb，否则会照成资源的浪费。</li>
</ol>
<p>以上是bundle 如何使用以及需要注意的事项。</p>
<blockquote>
<p>Parcel不是通用的序列化机制（Serializable是通用的序列化机制） 所以不能把 Parcel数据存储在磁盘上或通过网络发送出去。</p>
</blockquote>
<h5><span id="源码分析">源码分析</span></h5><p>通过源码查看，Bundle 继承 BaseBundle 且实现了 Parcelable 接口。BaseBundle 内部 维护一个 ArrayMap&lt;String, Object&gt; mMap 常量来承载我们需要操作的对象。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Bundle</span> <span class="token keyword">extends</span> <span class="token class-name">BaseBundle</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> Parcelable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>BaseBundle 声明常量 mMap：</p>
<pre class="line-numbers language-java"><code class="language-java"> ArrayMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> mMap <span class="token operator">=</span> null<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过 </p>
<pre class="line-numbers language-java"><code class="language-java">Bundle bundle<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Bundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bundle<span class="token punctuation">.</span><span class="token function">putXX</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>实际上内部执行的是对 ArrayMap 的操作</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">putXXX</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">unparcel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="parcelable">Parcelable</span></h2><p>假设我们需要将<code>String  str = &quot;Hanmeimei&quot;;</code>，从 Activity  A 传递到 Activity B 时，我们可以使用  intent.putExtra(“name”,str ); 这样在 Activity B 中就能获取到由 Activity A 传递过来的字符串 str  .那么如果我想将一个对象由 Activity  A 传递到  Activity B 该怎么办，比如 User 对象。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> password<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPassword</span><span class="token punctuation">(</span>String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>String age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> String age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Android 并没有提供在两个 activity之间传递任意对象或者引用的方法，但是就是需要传递对象该怎么办呢，这个时候就需要  让该对象实现 Android 提供的 parcelable接口，说到 parcelable 就得说Parcel。</p>
<h3><span id="parcel-是什么">Parcel 是什么？</span></h3><p>简单说Parcel就是一个存放读取数据的容器， Android系统中的binder进程间通信(IPC)就使用了Parcel类来进行客户端与服务端数据的交互，而且AIDL的数据也是通过Parcel来交互的。在Java空间和C++都实现了Parcel，由于它在C/C++中，直接使用了内存来读取数据，因此，它更有效率。Parcel不是通用的序列化机制（Serialize 是通用的序列化机制） 所以不能把 Parcel数据存储在磁盘上或通过网络传输。</p>
<p>Parcel 的标记接口 是 Parcelable，如果该对象实现了parcelable接口，且实现了对应的方法，就拥有了 Parcel 的特性。</p>
<h3><span id="parcelable-在数据传递的用法">Parcelable 在数据传递的用法</span></h3><p>在Android 对象传递需求中，那么就可以利用下图红框中的方法进行传递了，putExtra(String name,Parcelable user);可以看出，我们可以传递一个实现 Parcelable接口的对象了</p>
<h2><span id="serializable">Serializable</span></h2><h3><span id="概念">概念</span></h3><ol>
<li>序列化就是将对象转化为字节流。</li>
<li>反序列化就是将字节流转化为对象。</li>
<li>默认的序列化是深度系列化（即类中嵌套其他对象引用的对象也会被序列化）。</li>
<li>静态成员不会被默认序列化，要让一个类支持序列化只要让这个类实现接口 java.io.Serializable 即可</li>
</ol>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>io<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>以上是 <code>Serializable</code> 的接口定义，且 <code>Serializable</code> 只是一个没有定义任何方法的标记接口。</p>
<h3><span id="为什么定义标记接口即可实现序列化了呢">为什么定义标记接口即可实现序列化了呢？</span></h3><p>声明实现 <code>Serializable</code> 接口后保存读取对象就可以使用 <code>ObjectOutputStream</code>、<code>ObjectInputStream</code> 流了，<code>ObjectOutputStream</code> 是 <code>OutputStream</code> 的子类，但实现了 <code>ObjectOutput</code> 接口，<code>ObjectOutput</code> 是 <code>DataOutput</code> 的子接口，增加了一个 <code>writeObject(Object obj)</code> 方法将对象转化为字节写到流中，<code>ObjectInputStream</code> 是 <code>InputStream</code> 的子类，实现了<code>ObjectInput</code> 接口，<code>ObjectInput</code> 是 <code>DataInput</code> 的子接口，增加了一个 <code>readObject()</code> 方法从流中读取字节转为对象。</p>
<blockquote>
<p>序列化和反序列化的实质在于 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 和 <code>ObjectInputStream</code> 的 <code>readObject</code> 方法实现，常见的 <code>String</code>、<code>Date</code>、<code>Double</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>TreeMap</code> 等都默认实现了 <code>Serializable</code>,.</p>
</blockquote>
<p>有时候我们对象有些字段的值可能与内存位置（<code>hashcode</code>）、当前时间等有关，所以我们不想序列化他（因为反序列化后的值是没有意义的）。或者有时候如果类中的字段，表示的是类的实现细节，而非逻辑信息则默认序列化，也是不适合的。</p>
<p><strong>由于以上原因</strong>：所以我们需要定制序列化，Java 提供的定制主要有<code> transient</code> 关键字方式 和 实现 <code>writeObject</code>、<code>readObject</code> 方式 及 <code>Externalizable</code> 接口 <code>readExternal</code>、<code>writeExternal</code> 方式。还可以将字段声明为 <code>transient</code> 后通过 <code>writeObject</code>、<code>readObject</code> 方法来自己保存该字段。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Transient</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Externalizable.java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Externalizable</span> <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>

    <span class="token keyword">void</span> <span class="token function">writeExternal</span><span class="token punctuation">(</span>ObjectOutput out<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">readExternal</span><span class="token punctuation">(</span>ObjectInput in<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认情况下 Java 会根据类中一系列信息自动生成一个版本号，在反序列化时如果类的定义发生了变化版本号就会变化，也就与反序列化流中的版本号不匹配导致会抛出异常，所以我们为了更好的控制和性能问题会自定义 <code>serialVersionUID</code> 版本号来避免类定义发生变化后反序列化版本号不匹配异常问题，如果版本号一样时流中有该字段而类定义中没有则该字段会被忽略，如果类定义中有而流中没有则该字段会被设为默认值，如果对于同名的字段类型变了则会抛出 <code>InvalidClassException</code>。</p>
<p>虚拟机是否允许反序列化不仅取决于类路径和功能代码是否一致，还取决于另一个非常重要的点是两个类的序列化 ID 是否一致（就是 <code>private static final long serialVersionUID = 1L</code>）。</p>
<p>因为声明实现 <code>Serializable</code> 接口后保存读取对象就可以使用 <code>ObjectOutputStream</code>、<code>ObjectInputStream</code> 流了，<code>ObjectOutputStream</code> 的 <code>writeObject(Object obj) </code>方法将对象转化为字节写到流中，<code>ObjectInputStream</code> 的 <code>readObject()</code> 方法从流中读取字节转为对象，<code>Serializable</code> 虽然是一个空接口，但是在调用 <code>writeObject</code> 方法时却充当了一种健全的校验作用，如果对象没有实现 <code>Serializable</code> 则在调用 <code>writeObject</code> 时就会抛出异常，所以说 <code>Serializable</code> 算是一种接口标识机制。</p>
<p>如下为 <code>ObjectOutputStream</code> 中 <code>writeObject(Object obj)</code> 的核心标记判断：</p>
<pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject0</span> <span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> <span class="token keyword">boolean</span> unshared<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">writeClass</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">ObjectStreamClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">writeClassDesc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ObjectStreamClass<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">writeString</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">writeArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">writeEnum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">writeOrdinaryObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>extendedDebugInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> debugInfoStack<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="最后">最后</span></h2><p>通过以上我们了解 Serializable 和 Parcelable都可以实现复杂数据结构的封装传输，两者的区别是什么？</p>
<h3><span id="两者的设计初衷">两者的设计初衷：</span></h3><ol>
<li><strong>Serializable</strong> 的作用是为了保存对象的属性到本地文件、数据库、网络流等以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。</li>
<li><strong>Parcelable</strong> 的设计初衷是因为Serializable 效率过慢，为了在程序内不同组件间以及不同 Android 程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，而且 Parcelable 是通过 IBinder 通信的消息的载体。</li>
</ol>
<h3><span id="两者的区别">两者的区别：</span></h3><ol>
<li>在使用内存的时候，Parcelable 类比 Serializable 性能高。</li>
<li>Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。</li>
<li>Parcelable不能适用在要将数据存储在磁盘上的情况，因为Parcelable 在外界有变化的情况下，不能很好的保证数据的持续性。</li>
</ol>
<h3><span id="适用场景">适用场景：</span></h3><ol>
<li>只在内存中操作数据时，比如两个 Activity 之间 传输数据。</li>
<li>需要持久化数据时，比如需要将数据保存的本地文件、数据库，所以尽管 Serializable 效率低点， 也不提倡用，但在这种情况下，还是建议你用 Serializable 。</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-06-30T02:56:51.000Z" title="2019-06-30T02:56:51.000Z">2019-06-30</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">6 分钟 读完 (大约 919 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/30/Android-%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/">Android 应用内存分析</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E6%89%80%E9%9C%80%E5%B7%A5%E5%85%B7">所需工具</a><ul>
<li><a href="#1-mta">1. MTA</a></li>
<li><a href="#2-androidstudio">2. AndroidStudio</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E5%B0%8F%E6%8A%80%E5%B7%A7">分析小技巧</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<p>Android 开发场景中，分析内存泄漏情况</p>
<h2><span id="所需工具">所需工具</span></h2><h3><span id="1-mta">1. MTA</span></h3><p>Eclipse Memory Analysis Tools (MAT) 是一个分析 Java堆数据的专业工具，用它可以定位内存泄漏的原因。</p>
<p>工具地址 : <a href="https://www.eclipse.org/mat/">https://www.eclipse.org/mat/</a></p>
<h3><span id="2-androidstudio">2. AndroidStudio</span></h3><ul>
<li>monitor</li>
</ul>
<p>存在 sdk/toools/ 下的 monitor</p>
<p>Dalvik Debug Monitor Server (DDMS) 是 ADT插件的一部分，其中有两项功能可用于内存检查 :</p>
<blockquote>
<ol>
<li>heap 查看堆的分配情况</li>
<li>allocation tracker跟踪内存分配情况</li>
</ol>
</blockquote>
<p>DDMS 这两项功能有助于找到内存泄漏的操作行为。</p>
<ul>
<li>profiler </li>
</ul>
<p>AndroidStudio 内置的 内存检测工具，可以回收内存和下载dump。</p>
<h2><span id="使用">使用</span></h2><ol>
<li>通过 AndroidStudio 内置工具 profiler 进行分析并获取到.hprof 文件。</li>
</ol>
<blockquote>
<p>操作步骤</p>
<ol>
<li>打开 profiler 窗口。</li>
<li>切换到 memory .</li>
<li>针对需要检测的页面，点击 <code>回收箱</code> 按钮，进行强制 GC.然后 点击 <code>下载图标</code> 按钮  获取堆栈信息.</li>
<li>排序方式 Arrange by package ，查看待检测的泄漏对象。</li>
<li>导出 .hprof 文件。</li>
</ol>
</blockquote>
<ol start="2">
<li>通过 sdk 目录 platform-tools/hprof-conv 工具进行转换</li>
</ol>
<pre class="line-numbers language-bash"><code class="language-bash">hrpof-conv -z <span class="token punctuation">[</span>待转换.hprof<span class="token punctuation">]</span>  <span class="token punctuation">[</span>转换后.hprof<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="3">
<li>以上转换后的 .hprof文件，通过 mat 打开，然后点击  histogram 。</li>
</ol>
<blockquote>
<p>进入Histogram<br>可以点击表头进行排序,在表的第一行可以输入正则表达式来匹配结果,找到我们想要找的类，然后右键选择<code>merge shortest paths to Gc roots</code> 然后在选择<code>exclude all phantom/weak/soft etc.references</code>选项.</p>
</blockquote>
<h2><span id="分析小技巧">分析小技巧</span></h2><ol>
<li><code>Histogram</code> 对比</li>
</ol>
<p>为查找内存泄漏，通常需要两个 Dump结果作对比，打开 <code>Navigator History</code>面板，将两个表的 <code>Histogram</code>结果都添加到 <code>Compare Basket</code>中去 :<br>添加好后，打开 Compare Basket面板，得到结果。</p>
<ol start="2">
<li>使用 <code>android:largeHeap=&quot;true&quot;</code>标记 (API Level &gt;= 11) </li>
</ol>
<p>在 <code>AndroidManifest.xml</code>中的 Application节点中声明即可分配到更大的堆内存, <code>android:largeHeap</code>标记在 Android系统应用中也有广泛的应用 ,比如 Launcher, Browser这些内存大户上均有使用.</p>
<ol start="3">
<li>mat 打开工具栏 <code>QQL</code>图标，可以使用 类sql 语句筛查<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">select</span> * from instanceof android.app.Activity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>mat 中 Actions 中的概念</li>
</ol>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Histogram</span>
列出内存中的对象，对象的个数以及大小。

<span class="token comment" spellcheck="true"># Dominator Tree</span>
列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）。

<span class="token comment" spellcheck="true"># Top Consumers</span>
通过图形列出最大的object。

<span class="token comment" spellcheck="true"># Shallow heap</span>
Shallow size就是对象本身占用内存的大小，不包含其引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。针对数组类型的对象，它的大小是数组元素对象的大小总和。

<span class="token comment" spellcheck="true">#Retained Heap</span>
它表示如果一个对象被释放掉，那会因为该对象的释放而减少引用进而被释放的所有的对象（包括被递归释放的）所占用的heap大小。<span class="token punctuation">(</span>间接引用的含义：A-<span class="token operator">></span>B-<span class="token operator">></span>C, C就是间接引用。不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-05-20T13:04:23.000Z" title="2019-05-20T13:04:23.000Z">2019-05-20</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">22 分钟 读完 (大约 3338 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/05/20/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/">Android 多线程开发实践</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E7%89%B9%E7%82%B9">特点：</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7">线程优先级</a></li>
<li><a href="#%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%96%B0%E7%BA%BF%E7%A8%8B">是否真的需要新线程？</a></li>
<li><a href="#asynctask">AsyncTask</a></li>
<li><a href="#handlerthread">HandlerThread</a></li>
<li><a href="#threadpoolexecutor">ThreadPoolExecutor</a></li>
<li><a href="#intentservice">IntentService</a></li>
<li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->



<h3><span id="特点">特点：</span></h3><ol>
<li>并行处理任务。</li>
<li>存在 线程数据安全、死锁、内存消耗、对象的生命周期管理、ui 的卡顿 等等。</li>
<li>存在优先级。</li>
</ol>
<h3><span id="线程优先级">线程优先级</span></h3><p>线程寄宿在进程当中，线程的生命周期直接被进程所影响，而进程的存活又和其优先级直接相关。在处理进程优先级的时候，大部分人靠直觉都能知道前台进程（<code>Foreground Process</code>）优先级要高于后台进程（<code>Background Process</code>）。但这种粗糙的划分无法满足操作系统高精度调度的需求。无论 Android 还是 iOS，系统对于 Foreground，Background 进程有进一步的细化。</p>
<ol>
<li>Foreground Process</li>
</ol>
<p>Foreground一般意味着用户双眼可见，可见却不一定是active。在Android的世界里，一个Activity处于前台之时，如果能采集用户的input事件，就可以判定为active，如果中途弹出一个Dialog，Dialog变成新的active实体，直接面对用户的操作。被部分遮挡的activity尽管依然可见，但状态却变为inactive。不能正确的区分visible和active</p>
<ol start="2">
<li>Background Process</li>
</ol>
<p>后台进程同样有更细的划分。所谓的Background可以理解为不可见（invisible）。对于不可见的任务，Android也有重要性的区分。重要的后台任务定义为Service，如果一个进程包含Service（称为Service Process），那么在“重要性”上就会被系统区别对待，其优先级自然会高于不包含Service的进程（称为Background Process），最后还剩一类空进程（Empty Process）。Empty Process初看有些费解，一个Process如果什么都不做，还有什么存在的必要。其实Empty Process并不Empty，还存在不少的内存占用。</p>
<p>在iOS的世界里，Memory被分为Clean Memory和Dirty Memory，Clean Memory是App启动被加载到内存之后原始占用的那一部分内存，一般包括初始的stack, heap, text, data等segment，Dirty Memory是由于用户操作所改变的那部分内存，也就是App的状态值。系统在出现Low Memory Warning的时候会首先清掉Dirty Memory，对于用户来说，操作的进度就全部丢失了，即使再次点击App图标，也是一切从头开始。但由于Clean Memory没有被清除，避免了从磁盘重新读取app数据的io损耗，启动会变快。这也是为什么很多人会感觉手机重启后，app打开的速度都比较慢。</p>
<p>同理Android世界当中的Empty Process还保存有App相关的Clean Memory，这部分Memory对于提升App的启动速度大有帮助。显而易见Empty Process的优先级是最低的。</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td>Active</td>
<td>Top</td>
</tr>
<tr>
<td>Visible</td>
<td>High</td>
</tr>
<tr>
<td>Service</td>
<td>High</td>
</tr>
<tr>
<td>Background</td>
<td>Low</td>
</tr>
<tr>
<td>Empty</td>
<td>Low</td>
</tr>
</tbody></table>
<p>Android将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Process<span class="token punctuation">.</span><span class="token function">setThreadPriority</span><span class="token punctuation">(</span>Process<span class="token punctuation">.</span>THREAD_PRIORITY_BACKGROUND<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以在我们决定新启一个线程执行任务的时候，首先要问自己这个任务在完成时间上是否重要到要和UI线程争夺CPU资源。如果不是，降低线程优先级将其归于background group，如果是，则需要进一步的profile看这个线程是否造成UI线程的卡顿。</p>
<p>虽说Android系统在任务调度上是以线程为基础单位，设置单个thread的优先级也可以改变其所属的control groups，从而影响CPU time slice的分配。但进程的属性变化也会影响到线程的调度，当一个App进入后台的时候，该App所属的整个进程都将进入background group，以确保处于foreground，用户可见的新进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。</p>
<pre class="line-numbers language-shell"><code class="language-shell">adb shell ps -P<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当你的App重新被用户切换到前台的时候，进程当中所属的线程又会回归的原来的group。在这些用户频繁切换的过程当中，thread的优先级并不会发生变化，但系统在time slice的分配上却在不停的调整。</p>
<h3><span id="是否真的需要新线程">是否真的需要新线程？</span></h3><p>开线程并不是提升App性能，解决UI卡顿的万金油。每一个新启的线程会消耗至少64KB的内存，系统在不同的线程之间switch context也会带来额外的开销。如果随意开启新线程，随着业务的膨胀，很容易在App运行的某个时间点发现几十个线程同时在运行。后果是原本想解决UI流畅性，却反而导致了偶现的不可控的卡顿。</p>
<p>移动端App新启线程一般都是为了保证UI的流畅性，增加App用户操作的响应度。但是否需要将任务放入工作线程需要先了解任务的瓶颈在哪，是i/o，gpu还是cpu？UI出现卡顿并不一定是UI线程出现了费时的计算，有可能是其它原因，比如layout层级太深。</p>
<p>尽量重用已有的工作线程（使用线程池）可以避免出现大量同时活跃的线程，比如对HTTP请求设置最大并发数。或者将任务放入某个串行的队列（HandlerThread）按顺序执行，工作线程任务队列适合处理大量耗时较短的任务，避免出现单个任务阻塞整个队列的情况。</p>
<p>用什么姿势开线程？</p>
<p>常用的方式：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状态的管理。start之后，run当中的代码就一定会执行到底，无法中途取消。</p>
<p>==Runnable作为匿名内部类还持有了外部类的引用，在线程退出之前，该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成内存泄漏==。</p>
<p>没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外的线程切换代码。</p>
<p>如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得</p>
<pre class="line-numbers language-java"><code class="language-java">Process<span class="token punctuation">.</span><span class="token function">setThreadPriority</span><span class="token punctuation">(</span>Process<span class="token punctuation">.</span>THREAD_PRIORITY_BACKGROUND<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。</p>
<h3><span id="asynctask">AsyncTask</span></h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAsyncTask</span> <span class="token keyword">extends</span> <span class="token class-name">AsyncTask</span> <span class="token punctuation">{</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> Object <span class="token function">doInBackground</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onPreExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPreExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onPostExecute</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPostExecute</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。</p>
<p>AsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管理上较之Thread()方式更为灵活。值得注意的是AsyncTask的cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel的状态值来决定是否中止任务。</p>
<p>==AsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。==</p>
<p>AsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要明确任务是串行还是并行。</p>
<p>线程优先级为background，对UI线程的执行影响极小。</p>
<h3><span id="handlerthread">HandlerThread</span></h3><p>在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。</p>
<p>HandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。</p>
<p>HandlerThread背后只有一个线程，所以任务是==串行==执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。</p>
<p>==HandlerThread所产生的线程会一直存活==，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。</p>
<p>HandlerThread较之Thread()，AsyncTask需要写更多的代码，但在实用性，灵活度，安全性上都有更好的表现。</p>
<h3><span id="threadpoolexecutor">ThreadPoolExecutor</span></h3><p>Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Executor THREAD_POOL_EXECUTOR
            <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>CORE_POOL_SIZE<span class="token punctuation">,</span> MAXIMUM_POOL_SIZE<span class="token punctuation">,</span> KEEP_ALIVE<span class="token punctuation">,</span>
            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> sPoolWorkQueue<span class="token punctuation">,</span> sThreadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。</p>
<p>ThreadPool较之HandlerThread在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。</p>
<h3><span id="intentservice">IntentService</span></h3><p>不得不说Android在API设计上粒度很细，同一样工作可以通过各种不同的类来完成。IntentService又是另一种开工作线程的方式，从名字就可以看出这个工作线程会带有service的属性。和AsyncTask不同，没有和UI线程的交互，也不像HandlerThread的工作线程会一直存活。IntentService背后其实也有一个HandlerThread来串行的处理Message Queue，从IntentService的onCreate方法可以看出：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// TODO: It would be nice to have an option to hold a partial wakelock</span>
        <span class="token comment" spellcheck="true">// during processing, and to have a static startService(Context, Intent)</span>
        <span class="token comment" spellcheck="true">// method that would launch the service &amp; hand off a wakelock.</span>

        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        HandlerThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HandlerThread</span><span class="token punctuation">(</span><span class="token string">"IntentService["</span> <span class="token operator">+</span> mName <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        mServiceLooper <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mServiceHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceHandler</span><span class="token punctuation">(</span>mServiceLooper<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只不过在所有的Message处理完毕之后，工作线程会自动结束。所以可以把IntentService看做是Service和HandlerThread的结合体，适合需要在工作线程处理UI无关任务的场景。</p>
<h3><span id="结束语">结束语</span></h3><p>Android开线程的方式虽然五花八门，但归根到底最后还是映射到linux下的pthread，业务的设计还是脱不了和线程相关的基础概念范畴：线程的执行顺序，调度策略，生命周期，串行还是并行，同步还是异步等等。摸清楚各类API下线程的行为特点，在设计具体业务的线程模型的时候自然轻车熟路了，线程模型的设计要有整个app视角的广度，切忌各业务模块各玩各的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-04-16T13:01:11.000Z" title="2019-04-16T13:01:11.000Z">2019-04-16</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">11 分钟 读完 (大约 1590 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/04/16/Android-Dagger2%E5%88%86%E6%9E%90/">Android Dagger2分析</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
<li><a href="#%E6%B3%A8%E8%A7%A3">注解</a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84">反射</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E-javaxinject">基于 javax.inject </a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<!--toc-->

<p><a href="https://google.github.io/dagger/">官方地址 </a></p>
<p><a href="https://blog.csdn.net/briblue/article/details/75578459">参考博客地址</a></p>
<h3><span id="注解">注解</span></h3><h3><span id="依赖注入">依赖注入</span></h3><p>Dagger2 是一个依赖注入框架，依赖注入的目的就是为了给需求方在合适的时候注入依赖。<br>**@Inject**<br>@Inject 注解就如同一个标签，或者说它是一个记号，它是给 Dagger2 看的。它运用的地方有两处。</p>
<ul>
<li><p>@Inject 给一个类的相应的属性做标记时，说明了它是一个依赖需求方，需要一些依赖。</p>
</li>
<li><p>@Inject 给一个类的构造方法进行注解时，表明了它能提供依赖的能力。</p>
</li>
</ul>
<p>就这样，通过 @Inject 注解符号，就很容易标记依赖和它的需求方。但是，单单一个 @Inject 是不能让 Dagger2 正常运行的。还需要另外一个注解配合。这个注解就是 @Component。</p>
<p><strong>@Component</strong></p>
<p>而 @Component 相当于联系纽带，将 @inject 标记的需求方和依赖绑定起来，并建立了联系，而 Dagger2 在编译代码时会依靠这种关系来进行对应的依赖注入</p>
<p><strong>@Provides 和 @Module</strong><br>Dagger2 为了能够对第三方库中的类进行依赖注入，提供了 @Provides 和 @Module 两个注解。</p>
<p>Provide 本身的字面意思就是提供，显然在 Dagger2 中它的作用就是提供依赖。 </p>
<p>Module 是模块的意思，Dagger2 中规定，用 @Provides 注解的依赖必须存在一个用 @Module 注解的类中。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7cb82d844f92dfa47016fa2fda60e58d?method=download&shareKey=32e575c6c38ade13609fae051ed17920" alt="image"></p>
<p><strong>@Inject 和 @Provides 的优先级</strong></p>
<p>Baozi 这个类就符合我上面给的情景，一方面它确实拥有被 @Inject 注解过的构造方法，另一方面在 Module 中它又通过 @Provides 提供了依赖。那么，最终，Dagger2 采取了哪一种呢？</p>
<p>答案是 Module，其实现象我们在之前的测试时已经可以观察到了，最终屏幕显示的是豆沙包选项。</p>
<p>Dagger2 依赖查找的顺序是先查找 Module 内所有的 @Provides 提供的依赖，如果查找不到再去查找 @Inject 提供的依赖。</p>
<p><strong>Dagger2 中的单例 @Singleton</strong></p>
<ul>
<li><p>用 @Singleton 标注在目标单例上，然后用 @Singleton 标注在 Component 对象上。</p>
</li>
<li><p>如果要以 @Provides 方式提供单例的话，需要用 @Singleton 注解依赖提供的方法</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Module</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecondActivityModule</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Provides</span>
    <span class="token annotation punctuation">@Singleton</span>
    <span class="token keyword">public</span> TestSingleton <span class="token function">provideTestSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TestSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>@Singleton 是一个注解，但是它被一个元注解 @Scope 注解了</p>
</li>
<li><p>为什么要用 @Singleton 同时标注 @Provides 和 @Component ?</p>
<blockquote>
<p>Component 是联系需求与依赖的纽带，所以用 @Singleton 确定的单例作用域应该也是在 Component 的范围内。也就是说 @Scope 的作用范围其实就是单例能力范围，这个范围在单个的 Component 中.</p>
</blockquote>
</li>
</ul>
<p><strong>@Qualifiers 和 @Name</strong></p>
<p>@Name 只是被 @Qualifier 注解的一个注解。所以，它能够有效完全是因为 @Qualifier</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Qualifier</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">/** The name. */</span>
    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完全可以自定义不同的注解，避免通过 Named 的方式容易拼错的问题。 </p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Qualifier</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用时</p>
<pre class="line-numbers language-java"><code class="language-java">   <span class="token annotation punctuation">@Provides</span>
    <span class="token annotation punctuation">@Named</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">provideIntA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">111</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Provides</span>
    <span class="token annotation punctuation">@B</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">provideIntB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">222</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Inject</span>
    <span class="token annotation punctuation">@Named</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span>
    <span class="token keyword">int</span> testValueA<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Inject</span>
    <span class="token annotation punctuation">@B</span>
    <span class="token keyword">int</span> testValueB<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Dagger2 中的延迟加载</strong></p>
<p>所谓的延迟加载，是当我们使用的时候再去实例化,比如以下方式。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestLazy</span> <span class="token punctuation">{</span>

    String name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> name <span class="token operator">==</span> null <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            name <span class="token operator">=</span> <span class="token string">"TestLazy"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Dagger2 提供了延迟加载能力。只需要通过 Lazy 就好了，Lazy 是泛型类，接受任何类型的参数。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestLazy</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Inject</span>
    <span class="token annotation punctuation">@Named</span><span class="token punctuation">(</span><span class="token string">"TestLazy"</span><span class="token punctuation">)</span>
    Lazy<span class="token operator">&lt;</span>String<span class="token operator">></span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>多个component之间的依赖</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> <span class="token punctuation">{</span>ShangjiaAModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> XiaoChiModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>dependencies <span class="token operator">=</span> XiaoChiComponent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>SubComponent</strong><br>Java 软件开发中，我们经常面临的就是“组合”和“继承”的概念。它们都是为了扩展某个类的功能。<br>前面的 Component 的依赖采用 @Component(dependecies=othercomponent.class) 就相当于组合。<br>那么在 Dagger2 中，运用 @SubComponent 标记一个 Component 的行为相当于继承。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Subcomponent</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> FoodModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SubComponent</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThirdActivity activity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> XiaoChiModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>
    SubComponent <span class="token function">provideSubComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


DaggerParentComponent<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">provideSubComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 Subcomponent 时，还是要先构造 ParentComponent 对象，然后通过它提供的 SubComponent 再去进行依赖注入。</p>
<p>大家可以细细观察下它与 depedency 方法的不同之处。</p>
<p>但是，SubComponent 同时具备了 ParentComponent 和自身的 @Scope 作用域。所以，这经常会造成混乱的地方。大家需要注意。</p>
<p>如果你要我比较，SubComponent 和 dependency 形式哪种更好时，我承认各有优点，但我自己倾向于 dependency，因为它更灵活。</p>
<p>不是说 组合优于继承嘛。</p>
<h3><span id="反射">反射</span></h3><h3><span id="基于-javaxinject">基于 </span></h3><p>Dagger 2 是一个设计非常巧妙且粗暴的框架。为什么说巧妙呢？</p>
<ol>
<li>Dagger 是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。</li>
<li>Dagger 通过生成中间代码，解决了基于反射带来的开发和性能上的问题。</li>
<li>Dagger 通过编译的时候进行依赖注入的框架。</li>
<li>Dagger 与其他依赖注入框架不同，它是通过apt插件在编译阶段生成相应的注入代码</li>
<li>Dagger 的目的为了降低程序耦合。</li>
</ol>
<p>总之：他是在编译的时候完成了一切所需要的工作，提供一种使用方便、耦合度低、避免了通过反射带来的性能问题。</p>
<p>为什么说粗暴呢？使用的时候简单几个注解就可以了，但是 在编译阶段通过 apt 插件生成了全部的注入代码。而且代码量还不小。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-02-15T12:46:34.000Z" title="2019-02-15T12:46:34.000Z">2019-02-15</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">14 分钟 读完 (大约 2135 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/02/15/Java-%E5%8F%8D%E5%B0%84%E8%BF%9B%E9%98%B6/">Java 反射进阶</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E4%B8%80%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AF%B9%E8%B1%A1">一、获取不存在的对象？</a><ul>
<li><a href="#1-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-class-%E5%AF%B9%E8%B1%A1">1. 获取不到 class 对象</a></li>
<li><a href="#2-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-field">2. 获取不到 Field</a></li>
<li><a href="#3-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-method">3. 获取不到 Method</a></li>
<li><a href="#4-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-constructor">4. 获取不到 Constructor</a></li>
<li><a href="#5-getinterfaces-%E7%9A%84%E4%BD%9C%E7%94%A8">5. getInterfaces() 的作用</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">二、反射中的权限问题</a><ul>
<li><a href="#1-%E6%93%8D%E7%BA%B5%E9%9D%9E-public-%E4%BF%AE%E9%A5%B0%E7%9A%84-field">1. 操纵非 public 修饰的 Field</a></li>
<li><a href="#2-%E6%93%8D%E7%BA%B5%E4%B8%80%E4%B8%AA-final-%E7%B1%BB%E5%9E%8B%E7%9A%84-field">2. 操纵一个 final 类型的 Field</a></li>
<li><a href="#3-%E6%93%8D%E7%BA%B5%E9%9D%9E-public-%E4%BF%AE%E9%A5%B0%E7%9A%84-method">3. 操纵非 public 修饰的 Method</a></li>
<li><a href="#4-%E6%93%8D%E7%BA%B5%E9%9D%9E-public-%E4%BF%AE%E9%A5%B0%E7%9A%84-constructor">4. 操纵非 public 修饰的 Constructor</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89setaccessible-%E7%9A%84%E7%A7%98%E5%AF%86">三、setAccessible() 的秘密</a></li>
<li><a href="#%E5%9B%9Bclassnewinstance-%E5%92%8C-constructornewinstance-%E7%9A%84%E5%8C%BA%E5%88%AB">四、Class.newInstance() 和 Constructor.newInstance() 的区别</a></li>
<li><a href="#%E4%BA%94%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-methodinvoke-%E6%96%B9%E6%B3%95">五、谨慎使用 Method.invoke() 方法</a></li>
<li><a href="#%E5%85%AD%E6%80%BB%E7%BB%93">六、总结</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<p><a href="https://blog.csdn.net/briblue/article/details/76223206">参考博客</a></p>
<h2><span id="一-获取不存在的对象">一、获取不存在的对象？</span></h2><h3><span id="1-获取不到-class-对象">1. 获取不到 class 对象</span></h3><ol>
<li>通过一个对象的 getClass() 方法。</li>
<li>通过 .class 关键字。</li>
<li>通过 Class.forName()。</li>
</ol>
<p>抛出 ClassNotFoundException 异常。</p>
<h3><span id="2-获取不到-field">2. 获取不到 Field</span></h3><p>获取不到 Field 的情况分3种：</p>
<ul>
<li><p>确实不存在这个 Field </p>
<p>抛出 NoSuchFieldException</p>
</li>
<li><p>由于修饰符导致的权限问题。</p>
<p>抛出 SecurityException</p>
</li>
<li><p>Field 存在，但获取不到</p>
<p>抛出 NoSuchFieldException </p>
</li>
</ul>
<p>针对 Field 存在，但获取不到情况：<br>由于 getField 和 getDeclaredField 在父类获取的限制。可以先获取 当前类的 父类，即 superClass ，然后 通过 getField或者getDeclaredField的方式获取</p>
<pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">superClass</span> <span class="token operator">=</span> clzBase<span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="3-获取不到-method">3. 获取不到 Method</span></h3><ul>
<li><p>获取本身就不存在的 Method</p>
<p> 抛出 NoSuchMethodException</p>
</li>
<li><p>参数类型不匹配而找不到</p>
<p> 抛出NoSuchMethodException，传递参数的方式：</p>
</li>
</ul>
<pre class="line-numbers language-java"><code class="language-java">Method methodtest <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">float</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Method methodtest <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">float</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="4-获取不到-constructor">4. 获取不到 Constructor</span></h3><p>与 method 的类似</p>
<h3><span id="5-getinterfaces-的作用">5. getInterfaces() 的作用</span></h3><p>大家可能都会觉得 getInterfaces() 的作用是获取一个类中定义的接口，但是其实不是的，getInterfaces() 获取的是一个类所有实现的接口。</p>
<h2><span id="二-反射中的权限问题">二、反射中的权限问题</span></h2><h3><span id="1-操纵非-public-修饰的-field">1. 操纵非 public 修饰的 Field</span></h3><p>抛出 IllegalAccessException 错误</p>
<pre class="line-numbers language-java"><code class="language-java">field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我这里以 private 为例，其实 protected 和 default 也是一样的，但是它们不同于 private 的地方在于，它们在本 package 范围内是可见的，有兴趣的同学可以测试一下，测试代码在一个 package，而测试的类在另外一个 package。</p>
<h3><span id="2-操纵一个-final-类型的-field">2. 操纵一个 final 类型的 Field</span></h3><p>抛出 IllegalAccessException 错误</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>虽然被 public 修饰，但是它同样被 final 修饰，这在正常的开发流程说明这个属性不能够再被改变。</p>
<p>如果要解决这个问题，同样可以使用 setAccessible(true) 方法</p>
<h3><span id="3-操纵非-public-修饰的-method">3. 操纵非 public 修饰的 Method</span></h3><pre class="line-numbers language-java"><code class="language-java">method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过 setAccessible(true) 同样可以解决这个问题。</p>
<h3><span id="4-操纵非-public-修饰的-constructor">4. 操纵非 public 修饰的 Constructor</span></h3><p>同前面两种，同样是通过 setAccessible(true) 来搞定。</p>
<p>所以，在反射中如果要操作被 private 修饰的对象，那么就必须调用它的 setAccessible(true)。</p>
<h2><span id="三-setaccessible-的秘密">三、setAccessible() 的秘密</span></h2><p>我们已经知道 Field、Method 和 Constructor 都有 setAccessible() 这个方法，至于是什么呢？这是因为它们有共同的祖先 AccessObject。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccessibleObject</span> <span class="token keyword">implements</span> <span class="token class-name">AnnotatedElement</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> flag<span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span class="token punctuation">{</span>
        SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> sm<span class="token punctuation">.</span><span class="token function">checkPermission</span><span class="token punctuation">(</span>ACCESS_PERMISSION<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setAccessible0</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/* Check that you aren't exposing java.lang.Class.&lt;init> or sensitive
       fields in java.lang.Class. */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setAccessible0</span><span class="token punctuation">(</span>AccessibleObject obj<span class="token punctuation">,</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> SecurityException
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Constructor</span> <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token punctuation">(</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Class<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span><span class="token punctuation">(</span><span class="token string">"Cannot make a java.lang.Class"</span> <span class="token operator">+</span>
                                            <span class="token string">" constructor accessible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        obj<span class="token punctuation">.</span>override <span class="token operator">=</span> flag<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * Get the value of the {@code accessible} flag for this object.
     *
     * @return the value of the object's {@code accessible} flag
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAccessible</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> override<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，主要是设置内部一个 override 变量。</p>
<p>那么，我们以 Method 的 invoke 方法为例。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span>
           InvocationTargetException
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>override<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Reflection<span class="token punctuation">.</span><span class="token function">quickCheckMemberAccess</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller <span class="token operator">=</span> Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">checkAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    MethodAccessor ma <span class="token operator">=</span> methodAccessor<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// read volatile</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ma <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ma <span class="token operator">=</span> <span class="token function">acquireMethodAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ma<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果一个 Method 的 overide 为 false 的话，它就会根据 Modifiers 判断是否具有访问权限。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">quickCheckMemberAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> memberClass<span class="token punctuation">,</span><span class="token keyword">int</span> modifiers<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span><span class="token function">getClassAccessFlags</span><span class="token punctuation">(</span>memberClass<span class="token punctuation">)</span> <span class="token operator">&amp;</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个方法主要是简单地判断 modifiers 是不是 public，如果不是的话就返回 false。所以 protected、private、default 修饰符都会返回 false,只有 public 都会返回 true。</p>
<p>而不是 public 修饰的话会执行下面的代码</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">checkAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">,</span> Object obj<span class="token punctuation">,</span> <span class="token keyword">int</span> modifiers<span class="token punctuation">)</span><span class="token keyword">throws</span> IllegalAccessException
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>caller <span class="token operator">==</span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// quick check</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// ACCESS IS OK</span>
    <span class="token punctuation">}</span>
    Object cache <span class="token operator">=</span> securityCheckCache<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// read volatile</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> clazz<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> null
        <span class="token operator">&amp;&amp;</span> Modifier<span class="token punctuation">.</span><span class="token function">isProtected</span><span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span>
        <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>targetClass <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Must match a 2-list of { caller, targetClass }.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> cache2 <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> cache<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cache2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> targetClass <span class="token operator">&amp;&amp;</span>
                cache2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> caller<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// ACCESS IS OK</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// (Test cache[1] first since range check for [1]</span>
            <span class="token comment" spellcheck="true">// subsumes range check for [0].)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">==</span> caller<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Non-protected case (or obj.class == this.clazz).</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// ACCESS IS OK</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// If no return, fall through to the slow path.</span>
    <span class="token function">slowCheckMemberAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// Keep all this slow stuff out of line:</span>
<span class="token keyword">void</span> <span class="token function">slowCheckMemberAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">,</span> Object obj<span class="token punctuation">,</span> <span class="token keyword">int</span> modifiers<span class="token punctuation">,</span>
                           Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> IllegalAccessException
<span class="token punctuation">{</span>
    Reflection<span class="token punctuation">.</span><span class="token function">ensureMemberAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Success: Update the cache.</span>
    Object cache <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>targetClass <span class="token operator">==</span> clazz<span class="token punctuation">)</span>
                    <span class="token operator">?</span> caller
                    <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> caller<span class="token punctuation">,</span> targetClass <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// Note:  The two cache elements are not volatile,</span>
    <span class="token comment" spellcheck="true">// but they are effectively final.  The Java memory model</span>
    <span class="token comment" spellcheck="true">// guarantees that the initializing stores for the cache</span>
    <span class="token comment" spellcheck="true">// elements will occur before the volatile write.</span>
    securityCheckCache <span class="token operator">=</span> cache<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// write volatile</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终通过 Reflection 这个类的静态方法 ensureMemberAccess() 确认。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ensureMemberAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> currentClass<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> memberClass<span class="token punctuation">,</span>
Object target<span class="token punctuation">,</span><span class="token keyword">int</span> modifiers<span class="token punctuation">)</span><span class="token keyword">throws</span> IllegalAccessException
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentClass <span class="token operator">==</span> null <span class="token operator">||</span> memberClass <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">verifyMemberAccess</span><span class="token punctuation">(</span>currentClass<span class="token punctuation">,</span> memberClass<span class="token punctuation">,</span> target<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">(</span><span class="token string">"Class "</span> <span class="token operator">+</span> currentClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                                             <span class="token string">" can not access a member of class "</span> <span class="token operator">+</span>
                                             memberClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                                             <span class="token string">" with modifiers \""</span> <span class="token operator">+</span>
                                             Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token operator">+</span>
                                             <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有访问权限，程序将会在此抛出一个 IllegalAccessException 的异常。</p>
<p>所以，如果通过反射方式去操作一个 Field、Method 或者是 Constructor，最好先调用它的 setAccessible(true) 以防止程序运行异常。</p>
<h2><span id="四-classnewinstance-和-constructornewinstance-的区别">四、Class.newInstance() 和 Constructor.newInstance() 的区别</span></h2><p>Class.newInstance() 的使用有严格的限制，那就是一个 Class 对象中，必须存在一个无参数的 Constructor，并且这个 Constructor 必须要有访问的权限。</p>
<p>通过 Constructor.newInstance() 却没有这种限制。Constructor.newInstance() 适应任何类型的 Constructor,无论它们有参数还是无参数，只要通过 setAccessible() 控制好访问权限就可以了。</p>
<h2><span id="五-谨慎使用-methodinvoke-方法">五、谨慎使用 Method.invoke() 方法</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span>
           InvocationTargetException<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第一个 Object 参数代表的是对应的 Class 对象实例，这在上面一节已经见识到了。而后面的参数就是可变形参了，它接受多个参数。我们考虑一种特殊情况。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestT</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>

    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是一个泛型类，T 表示接受任意类型的参数。</p>
<pre class="line-numbers language-java"><code class="language-java"> Method tMethod <span class="token operator">=</span> clzT<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 tMethod<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 tMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestT</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>报错 ：<br>NoSuchMethodException，提示找不到这个方法。原因是类型擦除。<br>当一个方法有泛型参数时，编译器会自动向上转型，T 向上转型是 Object。所以实际上是 void test(Object t); 上面的代码试图去找 test(Integer t) 这个方法，自然是找不到。</p>
<pre class="line-numbers language-java"><code class="language-java">Method tMethod <span class="token operator">=</span> clzT<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
tMethod<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

tMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestT</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Java 反射中，一个 Method 执行时遭遇的异常会被包装在一个特定的异常中，这个异常就是 InvocationTargetException。</p>
<h2><span id="六-总结">六、总结</span></h2><table>
<thead>
<tr>
<th>异常名称</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>ClassNotFoundException</td>
<td>1. class.forName() 传入的包名有误 2.Class本身不存在</td>
</tr>
<tr>
<td>NoSuchFieldException</td>
<td>1. Field 名称不正确。2. getDeclaredField 和 getField()方法使用不当。</td>
</tr>
<tr>
<td>NoSuchMethodException</td>
<td>1. 方法本身不存在。2. 传入的参数的类型不匹配。3. 传入的参数 个数不匹配。</td>
</tr>
<tr>
<td>IllegalAccessException</td>
<td>1. 访问非 public修饰的对象如Field、Method、Consturctor。2. 操作 final 修饰的 Field.</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>1. Method.invoke 中参数匹配。2. Field 操作时设置的值不匹配。3. Constructor.newInstance() 传入的参数不匹配。</td>
</tr>
<tr>
<td>InvocationTargetException</td>
<td>1. Method 运行时产生异常.2.Constructor.newInstance() 作用时产生异常</td>
</tr>
<tr>
<td>InstantiationException</td>
<td>1. Class.newInstance() 或者Constructor.newInstance()异常。</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-02-10T11:40:00.000Z" title="2019-02-10T11:40:00.000Z">2019-02-10</time><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">22 分钟 读完 (大约 3237 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/02/10/Java-%E5%8F%8D%E5%B0%84/">Java 反射</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E5%8F%8D%E5%B0%84%E5%85%A5%E5%8F%A3">反射入口</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96class-%E7%9A%84%E6%88%90%E5%91%98">获取Class 的成员</a><ul>
<li><a href="#field-%E7%9A%84%E6%93%8D%E4%BD%9C"><strong>Field 的操作</strong></a></li>
<li><a href="#method-%E6%93%8D%E4%BD%9C">Method 操作</a></li>
<li><a href="#constructor-%E7%9A%84%E6%93%8D%E4%BD%9C">Constructor 的操作</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84">反射中的数组</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE-enum">反射中的枚举 enum</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<p><a href="https://blog.csdn.net/briblue/article/details/74616922">参考博客网址</a></p>
<h2><span id="反射入口">反射入口</span></h2><p><strong>Object.getClass()</strong></p>
<pre class="line-numbers language-java"><code class="language-java">Car car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Class <span class="token class-name">clazz</span> <span class="token operator">=</span> car<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>.class</strong></p>
<pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
Class <span class="token class-name">cls1</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
Class <span class="token class-name">cls2</span> <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p> <strong>Class.forName() 方法</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>
   Class <span class="token class-name">clz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.aa.test.Car"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>
   e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> <strong>Class 的名字</strong></p>
<pre class="line-numbers language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Class<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Class<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">clz</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outter<span class="token punctuation">.</span>Inner</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" Inner Class name:"</span><span class="token operator">+</span>clz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" Inner Class simple name:"</span><span class="token operator">+</span>clz<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" Inner Class canonical name:"</span><span class="token operator">+</span>clz<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment" spellcheck="true">//run 是匿名类</span>
Runnable run <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>

   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" anonymous Class name:"</span><span class="token operator">+</span>run<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" anonymous Class simple name:"</span><span class="token operator">+</span>run<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" anonymous Class canonical name:"</span><span class="token operator">+</span>run<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// local 是局部类</span>
<span class="token keyword">class</span> <span class="token class-name">local</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>


System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local a name:"</span><span class="token operator">+</span>local<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local a simplename:"</span><span class="token operator">+</span>local<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local a canonicalname:"</span><span class="token operator">+</span>local<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//[[[ 代表三维数组</span>
Inner Class <span class="token class-name">name</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Lcom<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Outter$Inner<span class="token punctuation">;</span>
Inner Class <span class="token class-name">simple</span> name<span class="token operator">:</span>Inner<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
Inner Class <span class="token class-name">canonical</span> name<span class="token operator">:</span>com<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Outter<span class="token punctuation">.</span>Inner<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>


<span class="token comment" spellcheck="true">//匿名类:</span>
anonymous Class <span class="token class-name">name</span><span class="token operator">:</span>com<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Test$<span class="token number">1</span>
anonymous Class <span class="token class-name">simple</span> name<span class="token operator">:</span>
anonymous Class <span class="token class-name">canonical</span> name<span class="token operator">:</span>null
<span class="token comment" spellcheck="true">//局部类</span>
Local a name<span class="token operator">:</span>com<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Test$1local
Local a simplename<span class="token operator">:</span>local
Local a canonicalname<span class="token operator">:</span>null
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Canonical 是官方、标准的意思，那么 getCanonicalName() 自然就是返回一个 Class 对象的官方名字，这个官方名字 canonicalName 是 Java 语言规范制定的，如果 Class 对象没有 canonicalName 的话就返回 null。</p>
<p>getCanonicalName() 是 getName() 和 getSimpleName() 的结合。</p>
<ul>
<li>getCanonicalName() 返回的也是全限定类名，但是对于内部类，不用 $ 开头，而用 .。</li>
<li>getCanonicalName() 对于数组类型的 Class，同 simplename 一样直接在后面添加 [] 。</li>
<li>getCanonicalName() 不同于 simplename 的地方是，不存在 canonicalName 的时候返回 null 而不是空字符串。</li>
<li>局部类和匿名内部类不存在 canonicalName。</li>
</ul>
<p><strong>Class 获取修饰符</strong></p>
<pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"modifiers value:"</span><span class="token operator">+</span>TestModifier<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"modifiers :"</span><span class="token operator">+</span>Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>TestModifier<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>输出</p>
<pre class="line-numbers language-bash"><code class="language-bash">modifiers value:1025
modifiers :public abstract<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>大家肯定会有疑问，为什么会返回一个整型数值呢？</p>
<p>这是因为一个类定义的时候可能会被多个修饰符修饰，为了一并获取，所以 Java 工程师考虑到了位运算，用一个 int 数值来记录所有的修饰符，然后不同的位对应不同的修饰符，这些修饰符对应的位都定义在 Modifier 这个类当中。<br>举例：</p>
<table>
<thead>
<tr>
<th>待比较</th>
<th>2进制</th>
</tr>
</thead>
<tbody><tr>
<td>public（0x00000001）</td>
<td>00000000001</td>
</tr>
<tr>
<td>1025</td>
<td>10000000001</td>
</tr>
<tr>
<td>进行&amp;运算结果</td>
<td>00000000001</td>
</tr>
</tbody></table>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPublic</span><span class="token punctuation">(</span><span class="token keyword">int</span> mod<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>mod <span class="token operator">&amp;</span> PUBLIC<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>得出结果  00000000001 不等于0 返回true ，类修饰符为 public</p>
<h2><span id="获取class-的成员">获取Class 的成员</span></h2><p>一个类的成员包括属性（有人翻译为字段或者域）、方法。对应到 Class 中就是 Field、Method、Constructor</p>
<p><strong>获取Field</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取的是 Class 中的属性，不能获取其父类的属性</span>
<span class="token keyword">public</span> Field <span class="token function">getDeclaredField</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span>
                       <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span>
                              SecurityException<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//获取的是 public 属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取</span>
<span class="token keyword">public</span> Field <span class="token function">getField</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span>
               <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span>
                      SecurityException

<span class="token comment" spellcheck="true">//获取所有的属性，但不包括从父类继承下来的属性</span>
<span class="token keyword">public</span> Field<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//获取自身的所有的 public 属性，包括从父类继承下来的。</span>
<span class="token keyword">public</span> Field<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span class="token punctuation">{</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>1.两者的区别就是 getDeclaredField() 获取的是 Class 中的属性,不能获取其父类的属性。 getField() 方法获取的是public属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取。<br>2. getDeclaredFileds() 方法可以获取 private、protected、public 和 default 属性，但是它获取不到从父类继承下来的属性。getFields() 自身的所有的 public 属性，包括从父类继承下来的。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>本 Class</th>
<th>SupperClass</th>
</tr>
</thead>
<tbody><tr>
<td>getField</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredField</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
<tr>
<td>getFields</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredFields</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
</tbody></table>
<p><strong>获取 Method</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>本 Class</th>
<th>SupperClass</th>
</tr>
</thead>
<tbody><tr>
<td>getMethod</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredMethod</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
<tr>
<td>getMethods</td>
<td>public</td>
<td>public</td>
</tr>
<tr>
<td>getDeclaredMethods</td>
<td>public、protected、default、private</td>
<td>x</td>
</tr>
<tr>
<td>类或者接口中的方法对应到 Class 就是 Method。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>相应的 API 如下，parameterTypes 是方法对应的参数，获取范围和Field类似。：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Method <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>

<span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>

<span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException

<span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>获取Contructor</strong><br>Java 反射把构造器从方法中单独拎出来了，用 Constructor 表示。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>

<span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getConstructor</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span>

<span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException 

<span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为，Constructor 不能从父类继承，所以就没有办法通过 getConstructor() 获取到父类的 Constructor。</p>
<h3><span id="field-的操作"><strong>Field 的操作</strong></span></h3><p>类中 定义的属性， 它们的类型要么是 8 种基础类型 int、long、float、double、boolean、char、byte 和 short。要么是引用，所有的引用都是 Object 的后代。<br><strong>Field 类型的获取</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Type <span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意，两者返回的类型不一样，getGenericType() 方法能够获取到泛型类型，比如 <code>hashMap&lt;String,String&gt;</code>,比getType 更详细。<br><strong>Field 修饰符的获取</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个与前面 Class 获取修饰符一致。<br><strong>Field 内容的读取与赋值</strong><br>Field 这个类定义了一系列的 get 方法来获取不同类型的值。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getLong</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getFloat</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">short</span> <span class="token function">getShort</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getDouble</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">getChar</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">getByte</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">getBoolean</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Field 又定义了一系列的 set 方法用来对其自身进行赋值。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setInt</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLong</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">long</span> value<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFloat</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">float</span> value<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setShort</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">short</span> value<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDouble</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">double</span> value<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setChar</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">char</span> value<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setByte</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">byte</span> b<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBoolean</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可能有同学会对方法中出现的 Object 参数有疑问，它其实是类的实例引用，这里涉及一个细节。</p>
<blockquote>
<p><strong>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。</strong></p>
</blockquote>
<p>在执行 set 属性的时，如果操作 private 修饰的成员，需要加上 </p>
<pre class="line-numbers language-java"><code class="language-java">field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3><span id="method-操作">Method 操作</span></h3><p>Method 对应普通类的方法。<br>我们看看一般普通类的方法的构成。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>方法由下面几个要素构成：</p>
<ul>
<li>方法名</li>
<li>方法参数</li>
<li>方法返回值</li>
<li>方法的修饰符</li>
<li>方法可能会抛出的异常</li>
</ul>
<p><strong>Method 获取方法名</strong></p>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeleclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>Method 获取方法参数</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//返回的是一个 Parameter 数组</span>
<span class="token keyword">public</span> Parameter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 获取所有的参数类型</span>
<span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 获取所有的参数类型，包括泛型</span>
<span class="token keyword">public</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回的是一个 Parameter 数组，在反射中 Parameter 对象就是用来映射方法中的参数。经常使用的<br>Parameter.java 类中的方法</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取参数名字</span>
<span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 获取参数类型</span>
<span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 获取参数的修饰符</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Method 获取返回值类型</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取返回值类型</span>
<span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 获取返回值类型包括泛型</span>
<span class="token keyword">public</span> Type <span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>Method 获取修饰符</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>Method 获取异常类型</strong></p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getExceptionTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">public</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getGenericExceptionTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>Method 方法的执行</strong> </p>
<p>这个应该是整个反射机制的核心内容了，很多时候运用反射目的其实就是为了以常规手段执行 Method。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Method 调用 invoke() 的时候，存在许多细节：</p>
<ul>
<li><p>invoke() 方法中第一个参数 Object 实质上是 Method 所依附的 Class 对应的类的实例，如果这个方法是一个<strong>静态方法</strong>，那么 ojb 为 null，后面的可变参数 Object 对应的自然就是参数。</p>
</li>
<li><p>invoke() 返回的对象是 Object，所以实际上执行的时候要进行强制转换。</p>
</li>
<li><p>在对 Method 调用 invoke() 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 InvocationTargetException。而通过 InvocationTargetException.getCause() 可以获取真正的异常。</p>
</li>
</ul>
<h3><span id="constructor-的操作">Constructor 的操作</span></h3><p>Constructor 同 Method 差不多，但是它特别的地方在于，它能够创建一个对象。</p>
<p>在 Java 反射机制中有两种方法可以用来创建类的对象实例：Class.newInstance() 和 Constructor.newInstance()。官方文档建议开发者使用后面这种方法，下面是原因。</p>
<ul>
<li>Class.newInstance() 只能调用无参的构造方法，而 Constructor.newInstance() 则可以调用任意的构造方法。</li>
<li>Class.newInstance() 通过构造方法直接抛出异常，而 Constructor.newInstance() 会把抛出来的异常包装到 InvocationTargetException 里面去，这个和 Method 行为一致。</li>
<li>Class.newInstance() 要求构造方法能够被访问，而 Constructor.newInstance() 却能够访问 private 修饰的构造器。</li>
</ul>
<h3><span id="反射中的数组">反射中的数组</span></h3><p>数组本质上是一个 Class，而在 Class 中存在一个方法用来识别它是否为一个数组。<br>在 Class.java 中 方法 <code>isArray()</code> 判断是否是数组<br>由于 数组本质上 还是 Class 所以可以通过 </p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//获取数组的里面的元素的类型，比如 int[] 数组的 componentType 自然就是 int</span>
<span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>*<em>动态创建数组**</em><br>反射创建数组通过 Array.newInstance() 这个方法。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newInstance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> componentType<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> dimensions<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> NegativeArraySizeException <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个参数 为数组内原始类型，后面的是可变参数，表示的是相应维度的数组长度限制。<br>比如创建一个 二维数组 <code>Array.newInstance(int.class,2,3);</code></p>
<p><strong>Array 的读取与赋值</strong></p>
<ol>
<li>对Array 整体的赋值和读取<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span>
             Object value<span class="token punctuation">)</span>
      <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span>
             IllegalAccessException<span class="token punctuation">;</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>public Object get(Object obj)<br>           throws IllegalArgumentException,<br>                  IllegalAccessException;</p>
<pre><code>2. 对 Array 指定位置进行赋值和读取,经典的几种方式分别为：
```java
public static void set(Object array,
                       int index,
                       Object value)
                throws IllegalArgumentException,
                       ArrayIndexOutOfBoundsException;


public static void setBoolean(Object array,
                              int index,
                              boolean z)
                       throws IllegalArgumentException,
                              ArrayIndexOutOfBoundsException;



public static Object get(Object array,
                         int index)
                  throws IllegalArgumentException,
                         ArrayIndexOutOfBoundsException;


public static short getShort(Object array,
                             int index)
                      throws IllegalArgumentException,
                             ArrayIndexOutOfBoundsException;</code></pre>
<h3><span id="反射中的枚举-enum">反射中的枚举 enum</span></h3><p>同数组一样本质上还是一个 Class 而已。</p>
<p>枚举的表现形式：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> State <span class="token punctuation">{</span>
    IDLE<span class="token punctuation">,</span>
    DRIVING<span class="token punctuation">,</span>
    STOPPING<span class="token punctuation">,</span>

    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 java 反射 中，可以把枚举看成一般的Class,但是反射机制提供了3个特别的 API 用于操作枚举。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//判断是否是枚举类型</span>
Class<span class="token punctuation">.</span><span class="token function">isEnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//获取枚举所有的常量</span>
Class<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//判断一个 Field 是不是枚举常量</span>
java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">.</span><span class="token function">isEnumConstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>枚举的获取与设置</strong><br>因为等同于 Class， 所以 枚举的获取与设置，可以 通过 Field 中的get() 和 set() 方法。</p>
<p>需要注意的是，如果要获取枚举里面的Field、Method、Constructor  可以调用 Class 的通用 API.</p>
<h3><span id="总结">总结</span></h3><ol>
<li>Java 中的反射是非常规编码方式。</li>
<li>Java 反射机制的操作入口是获取 Class 文件。 有 Class.forName()、 .class 和 Object.getClass() 3 种。</li>
<li>获取 Class 对象后还不够，需要获取它的 Members，包含 Field、Method、Constructor。</li>
<li>Field 操作主要涉及到类别的获取，及数值的读取与赋值。</li>
<li>Method 算是反射机制最核心的内容，通常的反射都是为了调用某个 Method 的 invoke() 方法。</li>
<li>通过 Class.newInstance() 和 Constructor.newInstance() 都可以创建类的对象实例，但推荐后者。因为它适应于任何构造方法，而前者只会调用可见的无参数的构造方法。</li>
<li>数组和枚举可以被看成普通的 Class 对待。</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-01-08T03:02:23.000Z" title="2019-01-08T03:02:23.000Z">2019-01-08</time><span class="level-item">1 分钟 读完 (大约 186 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/01/08/hello-world/">Hexo 使用说明</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#quick-start">Quick Start</a><ul>
<li><a href="#create-a-new-post">Create a new post</a></li>
<li><a href="#run-server">Run server</a></li>
<li><a href="#generate-static-files">Generate static files</a></li>
<li><a href="#deploy-to-remote-sites">Deploy to remote sites</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-01-06T07:26:00.000Z" title="2019-01-06T07:26:00.000Z">2019-01-06</time><span class="level-item"> brokge </span><span class="level-item"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="level-item">10 分钟 读完 (大约 1574 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/01/06/Java%E6%9E%9A%E4%B8%BE%E5%85%AD%E9%97%AE/">Java-枚举六问</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E4%B8%80%E9%97%AEjava-%E6%9E%9A%E4%B8%BE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">一问：Java 枚举是如何保证线程安全的？</a></li>
<li><a href="#%E5%9B%9B%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%BA%E8%AF%B4%E5%9C%A8%E4%B8%80%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8B%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E4%BE%8B%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88">四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？</a></li>
<li><a href="#%E5%85%AD%E9%97%AEjava-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%9E%9A%E4%B8%BE%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">六问：Java 迭代器和枚举器的区别是什么？</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<h3><span id="一问java-枚举是如何保证线程安全的">一问：Java 枚举是如何保证线程安全的？</span></h3><blockquote>
<p>答：因为 Java 类加载与初始化是 JVM 保证线程安全，而 Java enum 枚举在编译器编译后的字节码实质是一个 final 类，每个枚举类型是这个 final 类中的一个静态常量属性，其属性初始化是在该 final 类的 static 块中进行，而 static 的常量属性和代码块都是在类加载时初始化完成的，所以自然就是 JVM 保证了并发安全。（不清楚 enum 编译后为啥是静态常量的可以查看历史推送了解更多）</p>
</blockquote>
<h3><span id="二问不使用-synchronized-和-lock如何创建一个线程安全的单例">二问：不使用 synchronized 和 lock如何创建一个线程安全的单例？</span></h3><blockquote>
<p>答：这是一个很 open 的题目，我们平时提到单例并发都是用锁机制，实际抛开锁机制也有几种实现方式可以保证创建单例的并发安全，而且各具特色。</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token comment" spellcheck="true">// 通过枚举实现单例模式</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>
    INSTANCE<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过饿汉模式实现单例</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过静态内部类模式实现单例</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 通过 CAS（AtomicReference）实现单例模式</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AtomicReference<span class="token operator">&lt;</span>Singleton<span class="token operator">></span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Singleton<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Singleton singleton <span class="token operator">=</span> INSTANCE<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> singleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> singleton<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>可以看到，上面四种方式都可以不使用 synchronized 或者 lock 来保证了单例创建的并发安全。前面三种都是借助了 JVM 的 ClassLoader 类加载初始化保证并发安全的机制（至于 JVM 底层其实也是使用了 synchronized 或者 lock 的机制），而对于最后一种通过 CAS 机制保证了并发安全（至于什么是 CAS 我们后面并发相关每日一题会再详细推送讨论的，这里先记住 CAS 就是一种非阻塞乐观锁机制，是一种基于忙等待的算法，依赖底层硬件实现，相对于锁其没有线程切换和阻塞的额外消耗，但是如果忙等待一直执行不成功的死循环会对 CPU 造成较大的开销），最后一种才是真正的无锁实现。</p>
</blockquote>
<h3><span id="四问为什么有人说在一些场景下通过枚举实现的单例是最好的方式原因是什么">四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？</span></h3><blockquote>
<p>答：其实这个题目算是一箭双雕，既考察了 Java 枚举的实质特性又考察了单例模式的一些弊端问题。除过枚举实现的单例模式以外的其他实现方式都有一个比较大的问题是一旦实现了 Serializable 接口后就不再是单例了，因为每次调用 readObject() 方法返回的都是一个新创建出来的对象（当然可以通过使用 readResolve() 方法来避免，但是终归麻烦），而 Java 规范中保证了每一个枚举类型及其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上 Java 做了特殊处理，序列化时 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化时则是通过 java.lang.Enum 的 valueOf 方法来根据名字查找枚举对象，同时禁用了 writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法。<br>这个问题也暴露出另一个新问题，Java 枚举序列化有哪些坑？</p>
</blockquote>
<h3><span id="五问java-枚举序列化有哪些坑">五问：Java 枚举序列化有哪些坑？</span></h3><blockquote>
<p>答：如果我们枚举被序列化本地持久化了，那我们就不能删除原来枚举类型中定义的任何枚举对象，否则程序在运行过程中反序列化时 JVM 就会找不到与某个名字对应的枚举对象了，所以我们要尽量避免多枚举对象序列化的使用（当然了，枚举实现的单例枚举对象一般都不会增删改，所以不存在问题）。</p>
</blockquote>
<h3><span id="六问java-迭代器和枚举器的区别是什么">六问：Java 迭代器和枚举器的区别是什么？</span></h3><blockquote>
<p>答：主要区别如下。<br>Enumeration<e> 枚举器接口是 JDK 1.0 提供的，适用于传统类，而 Iterator<e> 迭代器接口是 JDK 1.2 提供的，适用于 Collections。<br>Enumeration 只有两个方法接口，我们只能读取集合的数据而不能对数据进行修改，而 Iterator 有三个方法接口，除了能读取集合的数据外也能对数据进行删除操作。<br>Enumeration 不支持 fail-fast 机制，而 Iterator 支持 fail-fast 机制（一种错误检测机制，当多线程对集合进行结构上的改变的操作时就有可能会产生 fail-fast 机制，譬如 ConcurrentModificationException 异常）。<br>总归现在尽量使用 Iterator 迭代器而不是 Enumeration 枚举器。</e></e></p>
</blockquote>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Brokge"></figure><p class="title is-size-4 is-block line-height-inherit">Brokge</p><p class="is-size-6 is-block">玉苏子</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>日常搬砖</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">19</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/brokge" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/brokge"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E4%BA%BA%E6%96%87/"><span class="level-start"><span class="level-item">人文</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%9F%A5%E8%AF%86%E5%BA%93/"><span class="level-start"><span class="level-item">知识库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-06T09:35:01.000Z">2020-06-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/06/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/">网络协议梳理</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-05T13:08:38.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E4%B8%AA%E6%95%B0/">多线程编程如何确定线程个数</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-02T08:28:45.000Z">2020-06-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/02/Dubbo%E8%AF%A6%E8%A7%A3/">Dubbo详解</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-11T12:04:17.000Z">2020-02-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/11/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Redis核心原理详解</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-10T04:50:24.000Z">2020-02-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/10/redis5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">Redis5 集群搭建</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%98%E5%8C%96/"><span class="tag">优化</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%B0%84/"><span class="tag">反射</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><span class="tag">微服务</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/"><span class="tag">思维模型</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99/"><span class="tag">正则</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%A8%E8%A7%A3/"><span class="tag">注解</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">7</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="玉蘇子" height="28"></a><p class="size-small"><span>&copy; 2020 brokge</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://brokge.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>