<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玉蘇子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brokge.github.io/"/>
  <updated>2020-08-21T06:32:02.456Z</updated>
  <id>https://brokge.github.io/</id>
  
  <author>
    <name>brokge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于大型系统架构的10个问题</title>
    <link href="https://brokge.github.io/2020/08/21/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>https://brokge.github.io/2020/08/21/关于大型系统架构的10个问题/</id>
    <published>2020-08-21T06:22:37.000Z</published>
    <updated>2020-08-21T06:32:02.456Z</updated>
    
    <content type="html"><![CDATA[<p>下面这些问题都是一线大厂的真实面试问题，不论是对你面试还是说拓宽知识面都很有帮助。</p><a id="more"></a><h3 id="1-你使用过哪些组件或者方法来提升网站性能-可用性以及并发量"><a href="#1-你使用过哪些组件或者方法来提升网站性能-可用性以及并发量" class="headerlink" title="1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量"></a>1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量</h3><ol><li><strong>提高硬件能力、增加系统服务器</strong>。（当服务器增加到某个程度的时候系统所能提供的并发访问量几乎不变，所以不能根本解决问题）</li><li><strong>使用缓存</strong>（本地缓存：本地可以使用JDK自带的 Map、Guava Cache.分布式缓存：Redis、Memcache.本地缓存不适用于提高系统并发量，一般是用处用在程序中。比如Spring是如何实现单例的呢？大家如果看过源码的话，应该知道，S把已经初始过的变量放在一个Map中，下次再要使用这个变量的时候，先判断Map中有没有，这也就是系统中常见的单例模式的实现。）</li><li><strong>消息队列</strong> （解耦+削峰+异步）</li><li><strong>采用分布式开发</strong> （不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署(All In)的缺点，大大提高的系统并发量）</li><li><strong>数据库分库（读写分离）、分表（水平分表、垂直分表）</strong></li><li><strong>采用集群</strong> （多台机器提供相同的服务）</li><li><strong>CDN 加速</strong> (将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点)</li><li><strong>浏览器缓存</strong></li><li><strong>使用合适的连接池</strong>（数据库连接池、线程池等等）</li><li><strong>适当使用多线程进行开发。</strong></li></ol><h3 id="2-设计高可用系统的常用手段"><a href="#2-设计高可用系统的常用手段" class="headerlink" title="2. 设计高可用系统的常用手段"></a>2. 设计高可用系统的常用手段</h3><ol><li><strong>降级：</strong> 服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好；</li><li><strong>限流：</strong> 防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值；</li><li><strong>缓存：</strong> 避免大量请求直接落到数据库，将数据库击垮；</li><li><strong>超时和重试机制：</strong> 避免请求堆积造成雪崩；</li><li><strong>回滚机制：</strong> 快速修复错误版本。</li></ol><h3 id="3-现代互联网应用系统通常具有哪些特点"><a href="#3-现代互联网应用系统通常具有哪些特点" class="headerlink" title="3. 现代互联网应用系统通常具有哪些特点?"></a>3. 现代互联网应用系统通常具有哪些特点?</h3><ol><li>高并发，大流量；</li><li>高可用：系统7×24小时不间断服务；</li><li>海量数据：需要存储、管理海量数据，需要使用大量服务器；</li><li>用户分布广泛，网络情况复杂：许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别；</li><li>安全环境恶劣：由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会被黑客攻击；</li><li>需求快速变更，发布频繁：和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率是极高的；</li><li>渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来。</li></ol><h3 id="4-谈谈你对微服务领域的了解和认识"><a href="#4-谈谈你对微服务领域的了解和认识" class="headerlink" title="4. 谈谈你对微服务领域的了解和认识"></a>4. 谈谈你对微服务领域的了解和认识</h3><p>现在大公司都在用并且未来的趋势都是 Spring Cloud，而阿里开源的 Spring Cloud Alibaba 也是 Spring Cloud 规范的实现 。</p><p>我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon、Feign、Eureka（停止更新）、Hystrix 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。</p><p>Spring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现,Spring Cloud Alibaba 是一套国产开源产品集合，后续还会有中文 reference 和一些原理分析文章，所以，这对于国内的开发者是非常棒的一件事。阿里的这一举动势必会推动国内微服务技术的发展，因为在没有 Spring Cloud Alibaba 之前，我们的第一选择是 Spring Cloud Netflix，但是它们的文档都是英文的，出问题后排查也比较困难， 在国内并不是有特别多的人精通。Spring Cloud Alibaba 由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。</p><p>另外，Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p><h3 id="5-谈谈你对-Dubbo-和-Spring-Cloud-的认识-两者关系"><a href="#5-谈谈你对-Dubbo-和-Spring-Cloud-的认识-两者关系" class="headerlink" title="5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)"></a>5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)</h3><p>具体可以看公众号-阿里巴巴中间件的这篇文章:<a href="https://mp.weixin.qq.com/s/iNVctXw7tUGHhnF0hV84ww">独家解读：Dubbo Ecosystem - 从微服务框架到微服务生态</a></p><p>Dubbo 与 Spring Cloud 并不是竞争关系，Dubbo 作为成熟的 RPC 框架，其易用性、扩展性和健壮性已得到业界的认可。未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。</p><p>在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。我们后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p><h3 id="6-性能测试了解吗-说说你知道的性能测试工具"><a href="#6-性能测试了解吗-说说你知道的性能测试工具" class="headerlink" title="6. 性能测试了解吗?说说你知道的性能测试工具?"></a>6. 性能测试了解吗?说说你知道的性能测试工具?</h3><p>性能测试指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。性能测试是总称，通常细分为：</p><ol><li><strong>基准测试：</strong> 在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考</li><li><strong>负载测试：</strong> 是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。此时继续加压，系统处理能力会下降。</li><li><strong>压力测试：</strong> 超过安全负载情况下，不断施加压力（增加并发请求），直到系统崩溃或无法处理任何请求，依此获得系统最大压力承受能力。</li><li><strong>稳定性测试：</strong> 被测试系统在特定硬件、软件、网络环境下，加载一定业务压力（模拟生产环境不同时间点、不均匀请求，呈波浪特性）运行一段较长时间，以此检测系统是否稳定。</li></ol><p>后端程序员或者测试平常比较常用的测试工具是 JMeter（官网：<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a>）。Apache JMeter 是一款基于Java的压力测试工具(100％纯Java应用程序)，旨在加载测试功能行为和测量性能。它最初被设计用于 Web 应用测试但后来扩展到其他测试领域。</p><h3 id="7-对于一个单体应用系统-随着产品使用的用户越来越多-网站的流量会增加-最终单台服务器无法处理那么大的流量怎么办"><a href="#7-对于一个单体应用系统-随着产品使用的用户越来越多-网站的流量会增加-最终单台服务器无法处理那么大的流量怎么办" class="headerlink" title="7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?"></a>7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?</h3><p>这个时候就要考虑扩容了。《亿级流量网站架构核心技术》这本书上面介绍到我们可以考虑下面几步来解决这个问题：</p><ul><li>第一步，可以考虑简单的扩容来解决问题。比如增加系统的服务器，提高硬件能力等等。</li><li>第二步，如果简单扩容搞不定，就需要水平拆分和垂直拆分数据／应用来提升系统的伸缩性，即通过扩容提升系统负载能力。</li><li>第三步，如果通过水平拆分／垂直拆分还是搞不定，那就需要根据现有系统特性，架构层面进行重构甚至是重新设计，即推倒重来。</li></ul><p>对于系统设计，理想的情况下应支持线性扩容和弹性扩容，即在系统瓶颈时，只需要增加机器就可以解决系统瓶颈，如降低延迟提升吞吐量，从而实现扩容需求。</p><p>如果你想扩容，则支持水平/垂直伸缩是前提。在进行拆分时，一定要清楚知道自己的目的是什么，拆分后带来的问题如何解决，拆分后如果没有得到任何收益就不要为了<br>拆而拆，即不要过度拆分，要适合自己的业务。</p><h3 id="8-大表优化的常见手段"><a href="#8-大表优化的常见手段" class="headerlink" title="8. 大表优化的常见手段"></a>8. 大表优化的常见手段</h3><p>   当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li><li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li><strong>垂直分区：</strong> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。<img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/164084354ba2e0fd?w=950&h=279&f=jpeg&s=26015.jpg"><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li><li><strong>水平分区：</strong> <strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。<img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/164084b7e9e423e3?w=690&h=271&f=jpeg&s=23119.jpg" alt="数据库水平拆分">水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong>  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</li></ol><p><strong>下面补充一下数据库分片的两种常见方案：</strong></p><ul><li><strong>客户端代理：</strong>  <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h3 id="9-在系统中使用消息队列能带来什么好处"><a href="#9-在系统中使用消息队列能带来什么好处" class="headerlink" title="9. 在系统中使用消息队列能带来什么好处?"></a>9. 在系统中使用消息队列能带来什么好处?</h3><p><strong>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</strong></p><h4 id="1-通过异步处理提高系统性能"><a href="#1-通过异步处理提高系统性能" class="headerlink" title="1) 通过异步处理提高系统性能"></a>1) 通过异步处理提高系统性能</h4><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/162e63a8e34ba534?w=910&h=350&f=jpeg&s=29123.jpg" alt="通过异步处理提高系统性能"><br>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p><p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/162e64583dd3ed01?w=780&h=384&f=jpeg&s=13550.jpg" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击"><br>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h3 id="2-降低系统耦合性"><a href="#2-降低系统耦合性" class="headerlink" title="2) 降低系统耦合性"></a>2) 降低系统耦合性</h3><p>我们知道模块分布式部署以后聚合方式通常有两种：1.<strong>分布式消息队列</strong>和2.<strong>分布式服务</strong>。</p><blockquote><p><strong>先来简单说一下分布式服务：</strong></p></blockquote><p>目前使用比较多的用来构建<strong>SOA（Service Oriented Architecture面向服务体系结构）</strong>的<strong>分布式服务框架</strong>是阿里巴巴开源的<strong>Dubbo</strong>.如果想深入了解Dubbo的可以看我写的关于Dubbo的这一篇文章：<strong>《高性能优秀的服务框架-dubbo介绍》</strong>：<a href="https://juejin.im/post/5acadeb1f265da2375072f9c">https://juejin.im/post/5acadeb1f265da2375072f9c</a></p><blockquote><p><strong>再来谈我们的分布式消息队列：</strong></p></blockquote><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/162e6665fa394b3b?w=790&h=290&f=jpeg&s=14946.jpg" alt="利用消息队列实现事件驱动结构"><br><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong>   </p><p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<strong>比如在我们的ActiveMQ消息队列中还有点对点工作模式</strong>，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。</p><blockquote><p>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！</p></blockquote><h3 id="10-说说自己对-CAP-定理-BASE-理论的了解"><a href="#10-说说自己对-CAP-定理-BASE-理论的了解" class="headerlink" title="10. 说说自己对 CAP 定理,BASE 理论的了解"></a>10. 说说自己对 CAP 定理,BASE 理论的了解</h3><h4 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h4><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/163912e973ecb93c?w=624&h=471&f=png&s=32984.jpg" alt="CAP定理"><br>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li><strong>一致性（Consistence）</strong> :所有节点访问同一份最新的数据副本</li><li><strong>可用性（Availability）</strong>:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li><li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li></ul><p>CAP仅适用于原子读写的NOSQL场景中，并不适合数据库系统。现在的分布式系统具有更多特性比如扩展性、可用性等等，在进行系统设计和开发时，我们不应该仅仅局限在CAP问题上。</p><p><strong>注意：不是所谓的3选2（不要被网上大多数文章误导了）:</strong></p><p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在CAP理论诞生12年之后，CAP之父也在2012年重写了之前的论文。</p><p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能2选1。也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p><p>我在网上找了很多文章想看一下有没有文章提到这个不是所谓的3选2，用百度半天没找到了一篇，用谷歌搜索找到一篇比较不错的，如果想深入学习一下CAP就看这篇文章把，我这里就不多BB了：<strong>《分布式系统之CAP理论》 ：</strong> <a href="http://www.cnblogs.com/hxsyl/p/4381980.html">http://www.cnblogs.com/hxsyl/p/4381980.html</a></p><h4 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h4><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。</p><p><strong>BASE理论的核心思想：</strong> 即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p><p><strong>BASE理论三要素：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/163914806d9e15c6?w=612&h=461&f=png&s=39129.jpg" alt="BASE理论三要素"></p><ol><li><strong>基本可用：</strong> 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 比如： <strong>①响应时间上的损失</strong>:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；<strong>②系统功能上的损失</strong>：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；</li><li><strong>软状态：</strong> 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；</li><li><strong>最终一致性：</strong> 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《大型网站技术架构》</li><li>《亿级流量网站架构核心技术》</li><li>《Java工程师修炼之道》</li><li><a href="https://www.cnblogs.com/puresoul/p/5456855.html">https://www.cnblogs.com/puresoul/p/5456855.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面这些问题都是一线大厂的真实面试问题，不论是对你面试还是说拓宽知识面都很有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://brokge.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java-分布式锁这样实现</title>
    <link href="https://brokge.github.io/2020/08/13/Java-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0/"/>
    <id>https://brokge.github.io/2020/08/13/Java-分布式锁这样实现/</id>
    <published>2020-08-13T12:41:41.000Z</published>
    <updated>2020-08-21T04:57:50.587Z</updated>
    
    <content type="html"><![CDATA[<p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。</p><a id="more"></a><p>分布式锁实现，目前有很多种方式比如以下方式。</p><h1 id="1-常用实现方式"><a href="#1-常用实现方式" class="headerlink" title="1. 常用实现方式"></a>1. 常用实现方式</h1><ul><li>基于数据库实现分布式锁</li></ul><ol><li>性能较差，容易出现单点故障。</li><li>锁没有失效时间，容易死锁。</li></ol><ul><li>基于缓存实现分布式锁</li></ul><ol><li>比如通过Redis 实现，但相对复杂。</li><li>存在死锁（或短时间死锁）的可能。</li></ol><ul><li>基于 Zookeeper 实现分布式锁</li></ul><ol><li>实现相对简单</li><li>可靠性高</li><li>性能好</li></ol><p>从上面来看，Zookeeper 是一个理想状态下的分布式锁实现，那zk为什么理想呢？这要从 zk 的特性来说。</p><ol><li>首先zk 是一个分布式的，开放源码的分布式应用程序协调服务。</li><li>基于节点的数据结构，和unix文件路径相似的节点，可以往这个节点存储或获取数据。</li><li>通过客户端可对 znode 进行增删改查的操作，还可以注册watcher监控znode变化。</li><li>节点类型分为持久节点（包含：顺序和非顺序）、临时节点（顺序和非顺序）</li><li>同父的子节点不可重复。</li></ol><h2 id="3-Zookeeper-实现分布式锁一"><a href="#3-Zookeeper-实现分布式锁一" class="headerlink" title="3. Zookeeper 实现分布式锁一"></a>3. Zookeeper 实现分布式锁一</h2><p>利用zk 同父节点下子节点不可重名的特性。</p><p>实现流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1892343233.jpg" alt="image"></p><p>针对以上流程代码实现如下，包含可重入锁的特性。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZKDistributeLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String lockPath<span class="token punctuation">;</span>    <span class="token keyword">private</span> ZkClient client<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 锁重入计数</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> reentrantCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ZKDistributeLock</span><span class="token punctuation">(</span>String lockPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>        client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZkClient</span><span class="token punctuation">(</span><span class="token string">"localhost:2181"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setZkSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyZkSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 不会阻塞</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">++</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 创建节点</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">createEphemeral</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ZkNodeExistsException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 重入的释放锁处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">--</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果获取不到锁，阻塞等待</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 没获得锁，阻塞自己</span>            <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 再次尝试</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CountDownLatch cdl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IZkDataListener listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IZkDataListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataDeleted</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----收到节点被删除了-------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cdl<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataChange</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">,</span> Object data<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">subscribeDataChanges</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 阻塞自己</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                cdl<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 取消注册</span>        client<span class="token punctuation">.</span><span class="token function">unsubscribeDataChanges</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 并发数</span>        <span class="token keyword">int</span> currency <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环屏障</span>        CyclicBarrier cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>currency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 多线程模拟高并发</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currency<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"---------我准备好---------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 等待一起出发</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    ZKDistributeLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZKDistributeLock</span><span class="token punctuation">(</span><span class="token string">"/distLock11"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 获得锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>是否可以利用持久节点进行创建？</li></ol><p>利用持久节点，存在死锁的风险。因为如果持有锁的进程挂掉了，没有来的及删除节点，则出现死锁。<br>所以需要用临时节点，因为临时节点有自删除的特性。</p><ol start="2"><li>但是采用临时节点就没问题了吗？</li></ol><p>有问题，临时节点会出现惊群效应，在高并发场景下，如果有多个线程 注册了 watcher 机制，那么在这种实现方式下，就会有多个线程同时被唤醒，进行锁争抢，会造成巨大的服务器性能损耗，甚至可能出现宕机的风险，这就是所谓的惊群效应。</p><p>针对惊群效应，下面给出个改进版。</p><h2 id="4-zk实现分布式锁方式二"><a href="#4-zk实现分布式锁方式二" class="headerlink" title="4. zk实现分布式锁方式二"></a>4. zk实现分布式锁方式二</h2><p>利用zk 临时顺序节点的特性。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1892343234.jpg" alt="image"></p><p>利用临时顺序节点来实现分布式锁，包含可重入特性的完整代码。</p><ol><li>获取锁：取排队号（创建自己的临时顺序节点），然后判断自己是否是最小号，如是，则获得锁；不是，则注册前一节点的watcher,阻塞等待</li><li>释放锁：删除自己创建的临时顺序节点</li><li>通知：watcher机制通知阻塞等待的线程。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZKDistributeImproveLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lockPath<span class="token punctuation">;</span>    <span class="token keyword">private</span> ZkClient client<span class="token punctuation">;</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> currentPath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> beforePath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 锁重入计数</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> reentrantCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ZKDistributeImproveLock</span><span class="token punctuation">(</span>String lockPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>        client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZkClient</span><span class="token punctuation">(</span><span class="token string">"localhost:2181"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setZkSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyZkSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">createPersistent</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ZkNodeExistsException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">++</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            currentPath<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">createEphemeralSequential</span><span class="token punctuation">(</span>lockPath <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 获得所有的子</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> children <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 排序list</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 判断当前节点是否是最小的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lockPath <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 取到前一个</span>            <span class="token comment" spellcheck="true">// 得到字节的索引号</span>            <span class="token keyword">int</span> curIndex <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            beforePath<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockPath <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 阻塞等待</span>            <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 再次尝试加锁</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CountDownLatch cdl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注册watcher</span>        IZkDataListener listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IZkDataListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataDeleted</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----监听到节点被删除"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cdl<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataChange</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">,</span> Object data<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">subscribeDataChanges</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beforePath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 怎么让自己阻塞</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beforePath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                cdl<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 醒来后，取消watcher</span>        client<span class="token punctuation">.</span><span class="token function">unsubscribeDataChanges</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beforePath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 重入的释放锁处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">--</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 删除节点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 并发数</span>        <span class="token keyword">int</span> currency <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环屏障</span>        CyclicBarrier cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>currency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 多线程模拟高并发</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currency<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"---------我准备好---------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 等待一起出发</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    ZKDistributeImproveLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZKDistributeImproveLock</span><span class="token punctuation">(</span><span class="token string">"/distLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 获得锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="微服务" scheme="https://brokge.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="锁" scheme="https://brokge.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 疫苗爬虫脚本</title>
    <link href="https://brokge.github.io/2020/08/12/Python-%E7%96%AB%E8%8B%97%E7%88%AC%E8%99%AB%E8%84%9A%E6%9C%AC/"/>
    <id>https://brokge.github.io/2020/08/12/Python-疫苗爬虫脚本/</id>
    <published>2020-08-12T07:03:28.000Z</published>
    <updated>2020-08-21T04:52:03.076Z</updated>
    
    <content type="html"><![CDATA[<p>关于疫苗的python爬虫脚本，主要爬新华网。</p><a id="more"></a><p>源码地址查看 </p><p><a href="https://github.com/brokge/vaccine-scrapy">Github brokge  / vaccine-scrapy</a></p><h1 id="1-需要环境"><a href="#1-需要环境" class="headerlink" title="1. 需要环境"></a>1. 需要环境</h1><ul><li>python 3.5.2</li><li>scrapy 1.5.2</li><li>conda 4.6.11 或者 pip3</li><li>pycryptodome </li><li>pymysql</li></ul><p>如果碰到 兼容性问题<br>最好的方式，是通过 conda 安装所需要的环境变量，记得安装之后重启下系统</p><pre class="line-numbers language-sh"><code class="language-sh">conda install -c conda-forge scrapy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然也可以通过 pip3 来安装</p><pre class="line-numbers language-sh"><code class="language-sh">pip3 --default-timeout=100 install scrapy pip3 install pycryptodomepip3 install pymysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="2-运行"><a href="#2-运行" class="headerlink" title="2. 运行"></a>2. 运行</h1><pre class="line-numbers language-sh"><code class="language-sh">scrapy crawl spiderNews  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-文件目录说明"><a href="#3-文件目录说明" class="headerlink" title="3. 文件目录说明"></a>3. 文件目录说明</h1><p>通过 tree 命令查看目录结构</p><pre><code>.── README.md├── scrapy.cfg└── vaccine    ├── README.md    ├── __init__.py    ├── __pycache__    │   ├── __init__.cpython-37.pyc    │   ├── items.cpython-37.pyc    │   ├── pipelines.cpython-37.pyc    │   └── settings.cpython-37.pyc    ├── dbsql.sql    ├── items.py    ├── middlewares.py    ├── pipelines.py    ├── settings.py    ├── spiders    │   ├── VaccineNewsSpider.py    │   ├── __init__.py    │   └── __pycache__    │       ├── VaccineNewsSpider.cpython-37.pyc    │       └── __init__.cpython-37.pyc    └── vaccine_name.txt</code></pre><ul><li><p>dbsql.sql —数据表结构脚本</p></li><li><p>vaccine_name.txt —需要查询的关键字配置文件</p></li><li><p>VaccineNewsSpider.py — 爬虫执行文件</p></li><li><p>pipelines.py — 配置 通道的位置，根据自己情况调整</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># 链接数据的配置</span> self<span class="token punctuation">.</span>connect <span class="token operator">=</span> pymysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>      <span class="token comment" spellcheck="true"># 数据库地址</span>      host<span class="token operator">=</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>      port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>      db<span class="token operator">=</span><span class="token string">"dbcontent"</span><span class="token punctuation">,</span>      user<span class="token operator">=</span><span class="token string">'yusuzi'</span><span class="token punctuation">,</span>      passwd<span class="token operator">=</span><span class="token string">'yusuzi'</span><span class="token punctuation">,</span>      charset<span class="token operator">=</span><span class="token string">'utf8'</span><span class="token punctuation">,</span>      use_unicode<span class="token operator">=</span><span class="token boolean">True</span>  <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="4-执行效果截图"><a href="#4-执行效果截图" class="headerlink" title="4. 执行效果截图"></a>4. 执行效果截图</h1><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1FB53BAABFE04F15A20134805AE5BE2C.jpg" alt="image"></p><h1 id="5-核心逻辑"><a href="#5-核心逻辑" class="headerlink" title="5. 核心逻辑"></a>5. 核心逻辑</h1><p>在  VaccineNewsSpider.py 文件中，主要逻辑流程如下</p><ol><li>构造 url请求地址，</li><li>填充 关键字</li><li>请求 url</li><li>解析 返回数据</li><li>根据请求url 生成 md5 去重。</li><li>写入数据哭。</li></ol><h2 id="5-1-构造请求并解析返回数据"><a href="#5-1-构造请求并解析返回数据" class="headerlink" title="5.1 构造请求并解析返回数据"></a>5.1 构造请求并解析返回数据</h2><pre class="line-numbers language-py"><code class="language-py">class VaccineNewsSpider(scrapy.Spider):    name = "spiderNews"    url_format = "http://so.news.cn/getNews?keyword=%s&curPage=%s&sortField=0&searchFields=1&lang=cn"    def start_requests(self):        keywords = set()        try:            f = open('vaccine/vaccine_name.txt', 'r')            for line in f.readlines():                line = line.strip('\n')  # 去除换行符号                keywords.add(line)        finally:            if f:                f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>url_format: 根据自己不同的目标网址，进行构造请求url</p><pre class="line-numbers language-py"><code class="language-py"> def parse_json(self, response):        print("aa")        print(response.body)        newJson = json.loads(response.body)         print(newJson['code'])        newContent = newJson['content']        results = newContent['results']        pageSize = newContent['pageCount']        curPage = newContent['curPage']        keyWord = newContent['keyword']        newSets = set()        for result in results:            url = result['url']            if 'm.xinhuanet.com' in url and result['des']:                html_remove = re.compile(r'<[^>]+>', re.S)  # 构建匹配模式                # dd = dr.sub('', string) # 去除html标签                title = html_remove.sub('', result['title'])                print("title"+title)                vaccineNewsItem = VaccineNewsItem()                vaccineNewsItem['title'] = title.lstrip()                vaccineNewsItem['from_url'] = url                # result['sitename']                vaccineNewsItem['from_source'] = '新华网'                vaccineNewsItem['summary'] = result['des'].lstrip()                vaccineNewsItem['create_date'] = result['pubtime']                vaccineNewsItem['md5'] = self.md5_str(str=title)                vaccineNewsItem['keyword'] = keyWord                newSets.add(vaccineNewsItem)                yield vaccineNewsItem        if curPage < pageSize:            curPage = curPage+1            url = self.url_format % (keyWord, curPage)            print(url)            yield scrapy.Request(url, callback=self.parse_json)    def md5_str(self, str):        m = MD5.new()        m.update(str.encode("utf-8"))        return m.hexdigest()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码为请求 url 并解析请求数据。</p><h2 id="5-2-写入数据库"><a href="#5-2-写入数据库" class="headerlink" title="5.2 写入数据库"></a>5.2 写入数据库</h2><p>首先：VaccinePipeline.py 中配置通道相关信息，比如数据库链接配置，数据实体映射配置，插入数据执行sql配置等。</p><p>其次：setting.py 中 激活通道，并配置优先级</p><pre class="line-numbers language-py"><code class="language-py">ITEM_PIPELINES = {    'vaccine.pipelines.MySQLPipeLine': 300, }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过以上基本就可以跑起来了。运行中有任何问题欢迎反馈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于疫苗的python爬虫脚本，主要爬新华网。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="https://brokge.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://brokge.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql explain详解和最佳实践</title>
    <link href="https://brokge.github.io/2020/08/05/Mysql-explain%E8%AF%A6%E8%A7%A3%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://brokge.github.io/2020/08/05/Mysql-explain详解和最佳实践/</id>
    <published>2020-08-05T15:40:00.000Z</published>
    <updated>2020-08-21T04:56:19.793Z</updated>
    
    <content type="html"><![CDATA[<p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈。</p><a id="more"></a><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）</p><h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>actor<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>actor<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>actor<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>film<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>film<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_name<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>film<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'film0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'film1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'film2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>film_actor<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>film_actor<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>film_id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>actor_id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>remark<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_film_actor_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>film_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>actor_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>film_actor<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>film_id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>actor_id<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D15C58240983455DA0B494E89385F7EB.jpg" alt="image"></p><p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。</p><h2 id="Explain-有两个变种："><a href="#Explain-有两个变种：" class="headerlink" title="Explain 有两个变种："></a>Explain 有两个变种：</h2><h3 id="1-explain-extended："><a href="#1-explain-extended：" class="headerlink" title="1. explain extended："></a>1. explain extended：</h3><p>会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p><pre><code>mysql&gt; explain extended select * from film where id = 1;mysql&gt; show warnings; </code></pre><h3 id="2-explain-partitions："><a href="#2-explain-partitions：" class="headerlink" title="2. explain partitions："></a>2. explain partitions：</h3><p>相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p><h2 id="Explain-中列的含义"><a href="#Explain-中列的含义" class="headerlink" title="Explain 中列的含义"></a>Explain 中列的含义</h2><h3 id="Id-列"><a href="#Id-列" class="headerlink" title="Id 列"></a>Id 列</h3><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。MySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。<br>复杂查询分为三类：简单子查询、派生表（from语句中的子查询）、union 查询。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p><ol><li>简单子查询</li></ol><pre><code>mysql&gt; explain select (select 1 from actor limit 1) from film;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/10898C201A834EB781EF7BC2C044A816.jpg" alt="image"></p><ol start="2"><li><p>from子句中的子查询</p><pre><code>mysql&gt; explain select id from (select id from film) as der; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/620B5A7572DA4F409C5E211D4836F389.jpg" alt="image"><br>这个查询执行时有个临时表别名为der，外部 select 查询引用了这个临时表.</p></li><li><p>union查询</p><pre><code>mysql&gt; explain select 1 union all select 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7B675D2DD4434EA3BDB670265D0F1548.jpg" alt="image"><br>union结果总是放在一个匿名临时表中，临时表不在SQL中出现，因此它的 id 是 NULL。</p></li></ol><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><p>select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p><ol><li>simple：简单查询。查询不包含子查询和union</li></ol><pre><code>mysql&gt; explain select * from film where id = 2;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A4615C5FE4434BE395226791172C471E.jpg" alt="image"></p><ol start="2"><li><p>primary：复杂查询中最外层的 select</p></li><li><p>subquery：包含在 select 中的子查询（不在 from 子句中）</p></li><li><p>derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）<br>用这个例子来了解 primary、subquery 和 derived 类型</p><pre><code>mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D6B2A80FE48448A98839C65F70657084.jpg" alt="image"></p></li><li><p>union：在 union 中的第二个和随后的 select</p></li><li><p>union result：从 union 临时表检索结果的 select<br>用这个例子来了解 union 和 union result 类型：</p><pre><code>mysql&gt; explain select 1 union all select 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/99B591DAED3E420B8567C9FDCD1715EE.jpg" alt="image"></p></li></ol><h3 id="table-列"><a href="#table-列" class="headerlink" title="table 列"></a>table 列</h3><p>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table 列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行 id。</p><h3 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref.</p><p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表.</p><pre><code>mysql&gt; explain select min(id) from film; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/99A7592E5BF04B44B13C011C202A4F42.jpg" alt="image"></p><p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system</p><pre><code>mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B0008777242C4F9DB30CE6481DD6321F.jpg" alt="image"></p><pre><code>mysql&gt; show warnings; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8F7B3AA78C9D4D658052DFDC4EAB5395.jpg" alt="image"></p><p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p><pre><code>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FA04A7F60F9B44FAB02D7F2EB39C83EF.jpg" alt="image"></p><p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p><ol><li><p>简单 select 查询，name是普通索引（非唯一索引） </p><pre><code>mysql&gt; explain select * from film where name = &quot;film1&quot;; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0C68CC0AA000435EA7DEBB1F2C3F3951.jpg" alt="image"></p></li><li><p>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。 </p><pre><code>mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7CBD03DB6EB8436186FD10E0151B8C5D.jpg" alt="image"></p></li></ol><p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p><pre><code>mysql&gt; explain select * from actor where id &gt; 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FCE44E2B4262490F8088E4FDCFCBD308.jpg" alt="image"></p><p><strong>index</strong>：扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）</p><pre><code>mysql&gt; explain select * from film; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/03CC238786AE4E489ED2170F2D6BEE26.jpg" alt="image"><br><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p><pre><code>mysql&gt; explain select * from actor; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8369B9614FDA438BAB8F24CC964439A7.jpg" alt="image"></p><h3 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h3><p>这一列显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。 </p><ul><li>key列</li></ul><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p><ul><li>key_len列</li></ul><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p><pre><code>mysql&gt; explain select * from film_actor where film_id = 2;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7849D860315B4AB6AB4FA6DF036E3B5D.jpg" alt="image"></p><blockquote><p>key_len计算规则如下：<br>字符串<br>char(n)：n字节长度<br>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</p><p>数值类型:tinyint：1字节  smallint：2字节 int：4字节<br>bigint：8字节　　</p><p>时间类型　<br>date：3字节<br>timestamp：4字节<br>datetime：8字节</p><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></blockquote><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p><h3 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h3><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p><h3 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h3><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h3><p>这一列展示的是额外信息。常见的重要值如下：</p><p><strong>Using index</strong>：查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高</p><pre><code>mysql&gt; explain select film_id from film_actor where film_id = 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5D3C7CA4BA7F46CB904D2C4B123BA39F.jpg" alt="image"></p><p><strong>Using where</strong>：查询的列未被索引覆盖，where筛选条件非索引的前导列</p><pre><code>mysql&gt; explain select * from actor where name = &#39;a&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/10451AF8BC4E46E2B23058C4F8CA6B71.jpg" alt="image"></p><p><strong>Using where Using index</strong>：查询的列被索引覆盖，并且==where筛选条件是索引列之一但是不是索引的前导列==，意味着无法直接通过索引查找来查询到符合条件的数据</p><pre><code>mysql&gt; explain select film_id from film_actor where actor_id = 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D79204ABDADC4803A8911BD6FFC54944.jpg" alt="image"></p><p><strong>NULL</strong>：查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引</p><pre><code>mysql&gt;explain select * from film_actor where film_id = 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/4E85A87B5E07442F8F017E8F1AD43BB8.jpg" alt="image"></p><p><strong>Using index condition</strong>：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p><pre><code>mysql&gt; explain select * from film_actor where film_id &gt; 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8310AC3EA8804936BB7BDADCDD15AFEC.jpg" alt="image"></p><p><strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><ol><li><p>actor.name 没有索引，此时创建了张临时表来 distinct </p><pre><code>mysql&gt; explain select distinct name from actor; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/6701658087B1421EB24F3EE7F066189B.jpg" alt="image"></p></li><li><p>film.name 建立了idx_name索引，此时查询时extra是using index,没有用临时表 </p><pre><code>mysql&gt; explain select distinct name from film; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8F30FFC5BE9446BE8CC4B829DD269406.jpg" alt="image"></p></li></ol><p><strong>Using filesort</strong>：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p><ol><li><p>actor.name 未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录 </p><pre><code>mysql&gt; explain select * from actor order by name;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C7764DB5AF434C998B20C27CEEE8C7A4.jpg" alt="image"></p></li><li><p>film.name 建立了idx_name索引,此时查询时extra是using index</p><pre><code>mysql&gt; explain select * from film order by name; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/28DEB88B1D0D40A29B5E810BD9993F52.jpg" alt="image"></p></li></ol><h1 id="索引最佳实践"><a href="#索引最佳实践" class="headerlink" title="索引最佳实践"></a>索引最佳实践</h1><p>使用的表：</p><pre><code>CREATE TABLE `employees` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(24) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,  `age` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,  `position` varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;职位&#39;,  `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;入职时间&#39;,  PRIMARY KEY (`id`),  KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=&#39;员工记录表&#39;;INSERT INTO employees(name,age,position,hire_time) VALUES(&#39;LiLei&#39;,22,&#39;manager&#39;,NOW());INSERT INTO employees(name,age,position,hire_time) VALUES(&#39;HanMeimei&#39;, 23,&#39;dev&#39;,NOW());INSERT INTO employees(name,age,position,hire_time) VALUES(&#39;Lucy&#39;,23,&#39;dev&#39;,NOW());</code></pre><h2 id="最佳实践规则"><a href="#最佳实践规则" class="headerlink" title="最佳实践规则"></a>最佳实践规则</h2><h3 id="1-全值匹配"><a href="#1-全值匹配" class="headerlink" title="1. 全值匹配"></a>1. 全值匹配</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A36DE3157FDD49C3B18EF1E7C3823328.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5D918054B73F4CD1BAEA459DB6880AF0.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B78B7997D4DB407D85CAA1EED8C27828.jpg" alt="image"></p><h3 id="2-最佳左前缀法则"><a href="#2-最佳左前缀法则" class="headerlink" title="2. 最佳左前缀法则"></a>2. 最佳左前缀法则</h3><p>如果索引了多列，要遵守最左前缀法则。指的是查询从引的最左前列开始并且不跳过索引中的列。</p><pre><code>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =&#39;manager&#39;;EXPLAIN SELECT * FROM employees WHERE position = &#39;manager&#39;;EXPLAIN SELECT * FROM employees WHERE name = &#39;LiLei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/AB5FAAFBB2B94D05BD5DDDEA5537A657.jpg" alt="image"></p><h3 id="3-不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描"><a href="#3-不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描" class="headerlink" title="3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描"></a>3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name = &#39;LiLei&#39;;EXPLAIN SELECT * FROM employees WHERE left(name,3) = &#39;LiLei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/220EB6D05CFD4BE287BC311AB11EE6D3.jpg" alt="image"></p><h3 id="4-存储引擎不能使用索引中范围条件右边的列"><a href="#4-存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="4. 存储引擎不能使用索引中范围条件右边的列"></a>4. 存储引擎不能使用索引中范围条件右边的列</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22 AND position =&#39;manager&#39;;EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age &gt; 22 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/03ACE575E6444B098A09431C06A51AF4.jpg" alt="image"></p><h3 id="5-尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select-语句"><a href="#5-尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select-语句" class="headerlink" title="5. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句"></a>5. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句</h3><pre><code>EXPLAIN SELECT name,age FROM employees WHERE name= &#39;LiLei&#39; AND age = 23 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/52C76F3FA6AB46FF9D491DC5BC07B02E.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 23 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/93B9706742EE4B778FCCE0E73583236B.jpg" alt="image"></p><h3 id="6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描"><a href="#6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描" class="headerlink" title="6. mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描"></a>6. mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name != &#39;LiLei&#39;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/801D61263E3E443298EDD09A4B568B98.jpg" alt="image"></p><h3 id="7-is-null-is-not-null-也无法使用索引"><a href="#7-is-null-is-not-null-也无法使用索引" class="headerlink" title="7. is null,is not null 也无法使用索引"></a>7. is null,is not null 也无法使用索引</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name is null</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E6C01DD0BEBB4DD59FC9B6A321420066.jpg" alt="image"></p><h3 id="8-like以通配符开头（’-abc…’）mysql索引失效会变成全表扫描操作"><a href="#8-like以通配符开头（’-abc…’）mysql索引失效会变成全表扫描操作" class="headerlink" title="8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作"></a>8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name like &#39;%Lei&#39;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8069AB8749DF4F94A32B7A615097F406.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name like &#39;Lei%&#39;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/86DD9D2FA50A491A9657C180B33C16B0.jpg" alt="image"></p><p><strong>问题：解决like’%字符串%’索引不被使用的方法？</strong></p><p>a. 使用覆盖索引，查询字段必须是建立覆盖索引字段</p><pre><code>EXPLAIN SELECT name,age,position FROM employees WHERE name like &#39;%Lei%&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FC9F82F3BF1C4C3D9F635737D8A52A80.jpg" alt="image"></p><p>b. 当覆盖索引指向的字段是 varchar(380) 及 380 以上的字段时，覆盖索引会失效！</p><h3 id="9-字符串不加单引号索引失效"><a href="#9-字符串不加单引号索引失效" class="headerlink" title="9. 字符串不加单引号索引失效"></a>9. 字符串不加单引号索引失效</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name = &#39;1000&#39;;EXPLAIN SELECT * FROM employees WHERE name = 1000;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7951BE0D3C83494680A5203437523D4B.jpg" alt="image"></p><h3 id="10-少用or-用它连接时很多情况下索引会失效"><a href="#10-少用or-用它连接时很多情况下索引会失效" class="headerlink" title="10. 少用or,用它连接时很多情况下索引会失效"></a>10. 少用or,用它连接时很多情况下索引会失效</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name = &#39;LiLei&#39; or name = &#39;HanMeimei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CB583B20AE814DB5A7B3C64DA63FF4DD.jpg" alt="image"></p><h2 id="实践总结："><a href="#实践总结：" class="headerlink" title="实践总结："></a>实践总结：</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E473DB8A1C0B4AB59A494790716A08AB.jpg" alt="image"></p><blockquote><p>like KK%相当于=常量，%KK和%KK% 相当于范围</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://brokge.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Mysql索引底层数据结构与算法</title>
    <link href="https://brokge.github.io/2020/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://brokge.github.io/2020/08/05/深入理解Mysql索引底层数据结构与算法/</id>
    <published>2020-08-05T15:38:26.000Z</published>
    <updated>2020-08-21T05:02:21.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、索引优化面试题分析"><a href="#一、索引优化面试题分析" class="headerlink" title="一、索引优化面试题分析"></a>一、索引优化面试题分析</h2><a id="more"></a><p>分析以下几条sql的索引使用情况</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> emp_no<span class="token operator">=</span><span class="token string">'10001'</span> <span class="token operator">AND</span> title<span class="token operator">=</span><span class="token string">'Senior Engineer'</span> <span class="token operator">AND</span> from_date<span class="token operator">=</span><span class="token string">'1986-06-26'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> title<span class="token operator">=</span><span class="token string">'Senior Engineer'</span> <span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> emp_no <span class="token operator">></span> ‘<span class="token number">10001</span><span class="token string">';SELECT * FROM titles WHERE emp_no > ‘10001'</span> <span class="token operator">and</span> title<span class="token operator">=</span><span class="token string">'Senior Engineer'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> emp_no <span class="token operator">></span> ‘<span class="token number">10001</span>' <span class="token keyword">order</span> <span class="token keyword">BY</span> title<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/56891307BDC64F33A02FBC942C108A50.jpg" alt="image"></p><h2 id="二、索引到底是什么"><a href="#二、索引到底是什么" class="headerlink" title="二、索引到底是什么"></a>二、索引到底是什么</h2><p>索引是帮助MySQL高效获取数据的排好序的数据结构<br>,索引存储在文件里。</p><ul><li>索引结构 二叉树、红黑树、HASH、Btree(B+tree)</li></ul><h3 id="磁盘存储原理"><a href="#磁盘存储原理" class="headerlink" title="磁盘存储原理"></a>磁盘存储原理</h3><p>磁盘存储耗时分为两个部分：</p><ol><li>寻道时间，指针移动时间(速度慢，费时)</li><li>旋转时间，磁盘旋转(速度较快)<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/AF528CD17AC44F86A458243B4FBC4268.jpg" alt="image"></li></ol><p>所以从mysql索引的角度，要减少寻道时间。</p><p>磁盘IO 以页为单位（固定大小 4KB）。所以一次数据库查询或写入操作，要尽可能的减少IO 次数，则每页包含的尽量多的要操作的目标数据。</p><h2 id="三、索引底层数据结构与算法"><a href="#三、索引底层数据结构与算法" class="headerlink" title="三、索引底层数据结构与算法"></a>三、索引底层数据结构与算法</h2><p>树简单分为：二叉树、B树、B+树。<br>度(Degree)-代表节点的数据存储个数，也指代节点最大的子节点个数。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><ol><li>每个节点都（包含叶子节点）存储数据</li><li>节点中的数据 key 从左到右递增排列</li><li>叶子节点不存储指针。</li><li>每个节点的子节点个数m/2&lt;= 个数 &lt;=m,但根节点的节点个数可以不超过m/2。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A27A5822516D41ADA83D082A07ADF8D1.jpg" alt="image"></p><h3 id="B-Tree-B-Tree变种"><a href="#B-Tree-B-Tree变种" class="headerlink" title="B+Tree(B-Tree变种)"></a>B+Tree(B-Tree变种)</h3><ol><li>一般情况下，根节点存储在内存中，其他节点存储在磁盘中</li><li>非叶子节点不存储数据，只存储索引，可以增大度，类似跳表。</li><li>叶子节点不存储指针，存储数据</li><li>每个节点的子节点个数m/2&lt;= 个数 &lt;=m,但根节点的节点个数可以不超过m/2。</li><li>叶子节点不存储指针</li><li>叶子节点是通过链表串在一起（方便区间查找）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CF305DBAECD843518162BBF1F15DD14A.jpg" alt="image"></p><h3 id="B与-B-树的区别"><a href="#B与-B-树的区别" class="headerlink" title="B与 B+树的区别"></a>B与 B+树的区别</h3><ol><li>B+树中的节点不存储数据，只是索引,而 B 树中的节点存储数据。</li><li>B 树中的叶子节点不需要链表来串联。</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="B-Tree-索引的性能分析"><a href="#B-Tree-索引的性能分析" class="headerlink" title="B+Tree 索引的性能分析"></a>B+Tree 索引的性能分析</h4><p>一般使用磁盘I/O次数评价索引结构的优劣</p><ul><li>预读：磁盘一般会顺序向后读取一定长度的数据(页的整数倍)放入内存。</li><li>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用B+Tree节点的大小设为等于一个页，每次新建节点直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点的载入只需一次I/O。</li><li>B+Tree的度d一般会超过100，因此h非常小(一般为3到5之间)</li></ul><h2 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h2><p>Mysql 常用存储引擎为：MyISAM 和 InnoDB。在创建表的时候指定存储引擎，</p><h3 id="MyISAM索引实现-非聚集"><a href="#MyISAM索引实现-非聚集" class="headerlink" title="MyISAM索引实现(非聚集)"></a>MyISAM索引实现(非聚集)</h3><p>MyISAM索引文件和数据文件是分离的</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0619AC2863944836AFA2B35232B777E0.jpg" alt="image"></p><h3 id="InnoDB索引实现-聚集"><a href="#InnoDB索引实现-聚集" class="headerlink" title="InnoDB索引实现(聚集)"></a>InnoDB索引实现(聚集)</h3><ol><li>数据文件本身就是索引文件。</li><li>表数据文件本身就是按B+Tree组织的一个索引结构文件。</li><li>聚集索引-叶节点包含了完整的数据记录。</li><li>为什么 InnoDB表必须有主键，并且推荐使用整型的自增主键？<blockquote><p>因为主键索引存储的有数据，基于这个原因，必须要有主键，如果没主键会默认添加一个整型自增主键。</p></blockquote></li><li>为什么非主键索引结构叶子节点存储的是主键值？<br>基于一致性和节省存储空间的考虑，非主键索引节点存储主键值。<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E57C60E2EDAA4863ADBEF76B2A5EAC01.jpg" alt="image"></li></ol><h2 id="联合索引，索引最左前缀原理"><a href="#联合索引，索引最左前缀原理" class="headerlink" title="联合索引，索引最左前缀原理"></a>联合索引，索引最左前缀原理</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/341B6DF11EB34172BA8DA3C2D7BA79B5.jpg" alt="image"></p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从引的最左前列开始并且不跳过索引中的列。</p><p>例：<br>idx(a,b,c)</p><pre><code>select * from table where a=10002 and b=&#39;staff&#39; and c=&#39;199600823&#39;;(Y)select * from table where a=10002;(Y)select * from table where a=10002 and c = &#39;199600823&#39;;(部分索引Y,部分 N)select * from table where b=&#39;staff&#39; and c = &#39;199600823&#39;;(N)elect * from table where b=&#39;staff&#39;;(N)elect * from table where c = &#39;199600823&#39;;(N)</code></pre><table><thead><tr><th>语句</th><th>是否用到索引</th><th>使用的索引</th></tr></thead><tbody><tr><td>where a=3</td><td>Y</td><td>a</td></tr><tr><td>where a=3 and b = 5</td><td>Y</td><td>a，b</td></tr><tr><td>where a=3 and b = 5 and c = 4</td><td>Y</td><td>a，b, c</td></tr><tr><td>where b=3 或者 where b = 3 and c = 4 或者 where c=4</td><td>N</td><td></td></tr><tr><td>where a=3 and c = 5</td><td>Y</td><td>使用到 a,但 c 没有使用，b中间断了</td></tr><tr><td>where a=3 and b&gt;4 and c = 5</td><td>Y</td><td>使用到 a,b,但 c 不能用在范围之后，所以 b 断了。</td></tr><tr><td>where a=3 and b like ‘kk%’ and c = 5</td><td>Y</td><td>只用到 a，b ,c</td></tr><tr><td>where a=3 and b like ‘%kk’ and c = 5</td><td>Y</td><td>只用到 a</td></tr><tr><td>where a=3 and b like ‘%kk%’ and c = 5</td><td>Y</td><td>只用到 a</td></tr><tr><td>where a=3 and b like ‘k%kk%’ and c = 5</td><td>Y</td><td>只用到 a,b,c</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/9AAD735E36F94A52AFDEDD8B3D2DAA07.jpg" alt="image"></td><td></td><td></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。</p></li><li><p>order by满足两种情况会使用Using index。<br>#1.order by语句使用索引最左前列。<br>#2.使用where子句与order by子句条件列组合满足索引最左前列。</p></li><li><p>尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最佳左前缀法则。</p></li><li><p>如果order by的条件不在索引列上，就会产生Using filesort。</p></li><li><p>group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最佳左前缀法则。注意where高于having，能写在where中的限定条件就不要去having限定了。</p></li></ol><p>通俗理解口诀：</p><blockquote></blockquote><pre><code>全值匹配我最爱，最左前缀要遵守；带头大哥不能死，中间兄弟不能断；索引列上少计算，范围之后全失效；LIKE百分写最右，覆盖索引不写星；不等空值还有or，索引失效要少用。</code></pre><p><strong>补充：in和exsits优化</strong></p><p>原则：小表驱动大表，即小的数据集驱动大的数据集</p><p>in：当B表的数据集必须小于A表的数据集时，in优于exists</p><pre><code>select * from A where id in (select id from B)#等价于：　　for select id from B　　for select * from A where A.id = B.id</code></pre><p>exists：当A表的数据集小于B表的数据集时，exists优于in<br>　　将主查询A的数据，放到子查询B中做条件验证，根据验证结果（true或false）来决定主查询的数据是否保留</p><pre><code>select * from A where exists (select 1 from B where B.id = A.id)#等价于    for select * from A    for select * from B where B.id = A.id</code></pre><p>A表与B表的ID字段应建立索引</p><blockquote></blockquote><ol><li>EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以是SELECT 1或select X,官方说法是实际执行时会忽略SELECT清单,因此没有区别</li><li>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比</li><li>EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、索引优化面试题分析&quot;&gt;&lt;a href=&quot;#一、索引优化面试题分析&quot; class=&quot;headerlink&quot; title=&quot;一、索引优化面试题分析&quot;&gt;&lt;/a&gt;一、索引优化面试题分析&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://brokge.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>深入理解MySql锁 和事物隔离级别</title>
    <link href="https://brokge.github.io/2020/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySql%E9%94%81-%E5%92%8C%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://brokge.github.io/2020/08/05/深入理解MySql锁-和事物隔离级别/</id>
    <published>2020-08-05T15:36:29.000Z</published>
    <updated>2020-08-21T05:02:27.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><a id="more"></a><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul><li>从性能上分为乐观锁(用版本对比来实现)和悲观锁</li><li>从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)<ol><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</li><li>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ol></li><li>从对数据操作的粒度分，分为表锁和行锁</li></ul><h1 id="二、三种锁"><a href="#二、三种锁" class="headerlink" title="二、三种锁"></a>二、三种锁</h1><h2 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h2><p>表锁偏向MyISAM存储引擎，开销小，加锁快，无思索，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>建表SQL<pre><code>CREATE TABLE `mylock` (`id` INT (11) NOT NULL AUTO_INCREMENT,`NAME` VARCHAR (20) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE = MyISAM DEFAULT CHARSET = utf8;</code></pre></li><li>插入数据<pre><code>INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;1&#39;, &#39;a&#39;);INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;2&#39;, &#39;b&#39;);INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;3&#39;, &#39;c&#39;);INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;4&#39;, &#39;d&#39;);</code></pre></li><li>手动增加表锁<pre><code>lock table 表名称 read(write),表名称2 read(write);</code></pre></li><li>查看表上加过的锁<pre><code>show open tables;</code></pre></li><li>删除表锁<pre><code>unlock tables;</code></pre></li></ul><h3 id="案例分析-加读-写锁）"><a href="#案例分析-加读-写锁）" class="headerlink" title="案例分析(加读/写锁）"></a>案例分析(加读/写锁）</h3><ul><li><p>添加读锁<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BFE8ADDD90014C6BBB0BBE036AD3A63D.jpg" alt="image"><br>当前session和其他session都可以读该表<br>当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待</p></li><li><p>加写锁<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C461F77F31324DD18959B693CBE9F650.jpg" alt="image"><br>当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞</p></li></ul><h3 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h3><p>MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作前,会自动给涉及的表加写锁。</p><ol><li>对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。</li><li>对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作</li></ol><p><strong>总结：</strong><br>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p><h2 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h2><p>行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。InnoDB 与 MYISAM 的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p><h3 id="行锁支持事务"><a href="#行锁支持事务" class="headerlink" title="行锁支持事务"></a>行锁支持事务</h3><ul><li>事务（Transaction）及其ACID属性</li></ul><p>事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。</p><p>**原子性(Atomicity)**：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。</p><p>**一致性(Consistent)**：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性;事务结束时,所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。</p><p>**隔离性(Isolation)**：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</p><p>**持久性(Durable)**：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</p><ul><li>并发事务处理带来的问题</li></ul><p>更新丢失（Lost Update）当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p><ol><li><strong>脏读(Dirty Reads)</strong><br>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。<br>==一句话==：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</li><li><strong>不可重读(Non-Repeatable Reads)</strong><br>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。<br>==一句话==：事务A读取到了事务B已经提交的修改数据，不符合隔离性。</li><li><strong>幻读（Phantom Reads）</strong><br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。<br>==一句话==：事务A读取到了事务B提交的新增数据，不符合隔离性，脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。</li></ol><p>事务隔离级别<br>脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/93E21899E14C49588AA24EDA089B6AC7.jpg" alt="image"></p><p>数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。</p><p>同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读”和“幻读”并不敏感,可能更关心数据并发访问的能力。</p><p>常看当前数据库的事务隔离级别: </p><pre><code>show variables like &#39;tx_isolation&#39;;</code></pre><p>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</p><h3 id="行锁案例分析结论"><a href="#行锁案例分析结论" class="headerlink" title="行锁案例分析结论"></a>行锁案例分析结论</h3><p>在开启事务的情况下，Session_1 更新某一行，Session_2 更新同一行被阻塞，但是更新其他行正常。</p><h3 id="隔离级别案例分析"><a href="#隔离级别案例分析" class="headerlink" title="隔离级别案例分析"></a>隔离级别案例分析</h3><pre><code>CREATE TABLE `account` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `balance` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;lilei&#39;, &#39;450&#39;);INSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;hanmei&#39;, &#39;16000&#39;);INSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;lucy&#39;, &#39;2400&#39;);</code></pre><ul><li>读未提交：</li></ul><ol><li><p>打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），查询表account的初始值：</p><pre><code>set tx_isolation=&#39;read-uncommitted&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CDED85F0DF60461A9E2D7092AB8EF2FA.jpg" alt="image"></p></li><li><p>在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/403767AE76FE45DDA2BA39966EBB504E.jpg" alt="image"></p><ol start="3"><li>这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/699F1A3528B746EFA38CC4C0AF87F450.jpg" alt="image"></p><ol start="4"><li>一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A7C1D41774A1443BAF3405874BBAD8EE.jpg" alt="image"></p><ol start="5"><li>在客户端A执行更新语句<code>update account set balance = balance - 50 where id =1</code>，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，==如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别==</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/74461B8919624E67A96DD8B617151680.jpg" alt="image"></p><ul><li>读已提交</li></ul><ol><li><p>打开一个客户端A，并设置当前事务模式为read committed（未提交读），查询表account的所有记录：</p><pre><code>set tx_isolation=&#39;read-committed&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3CF7411455184AB69905A49EAE33799C.jpg" alt="image"></p></li><li><p>在客户端A的事务提交之前，打开另一个客户端B，更新表account.</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F9521950E2204FBDAC8B87285480D4B9.jpg" alt="image"></p><ol start="3"><li>这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1A9DE283DA394653B31752A9AC6A7441.jpg" alt="image"></p><ol start="4"><li>客户端B的事务提交</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BA04776FFF0A49879D440E0ABB1CFF87.jpg" alt="image"><br>5. 客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1CB8D92B7BC5412F8A9C85397AF40B51.jpg" alt="image"></p><ul><li>可重复读</li></ul><ol><li>打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录</li></ol><pre><code>set tx_isolation=&#39;repeatable-read&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5A48F50168B249F18207E466FC05F3DA.jpg" alt="image"></p><ol start="2"><li>在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BF5B9C07539B450BB6E35AE36C1DD2B1.jpg" alt="image"></p><ol start="3"><li>在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/074ED7B01BE74D57A896ABA9CDB2C19E.jpg" alt="image"></p><ol start="4"><li>在客户端A，接着执行update balance = balance - 50 where id = 1，balance没有变成400-50=350，lilei的balance值用的是步骤（2）中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3D0CF09EA3324E4FB7CA05DD2A1E2E85.jpg" alt="image"></p><ol start="5"><li>重新打开客户端B，插入一条新数据后提交</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/9F567B7BC1314EE6A95B27595003AACD.jpg" alt="image"></p><ol start="6"><li>在客户端A查询表account的所有记录，没有 查出 新增数据，所以没有出现幻读</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7962D7EB0B33471DB68CDE7650782F1C.jpg" alt="image"> </p><ol start="7"><li>验证幻读<br>在客户端A执行update account set balance=888 where id = 4;能更新成功，再次查询能查到客户端B新增的数据.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/DB875DCAD8124843AD598E2C2F592D94.jpg" alt="image"></p><ul><li>串行化</li></ul><ol><li>打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：</li></ol><pre><code>set tx_isolation=&#39;serializable&#39;; mysql&gt; set session transaction isolation level serializable; Query OK, 0 rows affected (0.00 sec)  mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec)  mysql&gt; select * from account; +------+--------+---------+| id   | name   | balance |+------+--------+---------+|    1 | lilei  |   10000 ||    2 | hanmei |   10000 ||    3 | lucy   |   10000 ||    4 | lily   |   10000 |+------+--------+---------+4 rows in set (0.00 sec)</code></pre><ol start="2"><li>打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。</li></ol><pre><code>mysql&gt; set session transaction isolation level serializable; Query OK, 0 rows affected (0.00 sec)  mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into account values(5,&#39;tom&#39;,0); ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</code></pre><ol start="3"><li>Mysql默认级别是repeatable-read，有办法解决幻读问题吗？</li></ol><p>间隙锁在某些情况下可以解决幻读问题, 要避免幻读可以用间隙锁在Session_1下面执行</p><pre><code>update account set name = &#39;zhuge&#39; where id &gt; 10 and id &lt;=20;</code></pre><p>则其他Session没法插入这个范围内的数据</p><h3 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h3><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和MYISAM相比就会有比较明显的优势了。</p><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。</p><h3 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h3><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><pre><code>show status like&#39;innodb_row_lock%&#39;;</code></pre><p>对各个状态量的说明如下：</p><blockquote><p>Innodb_row_lock_current_waits: 当前正在等待锁定的数量</p><p>Innodb_row_lock_time: 从系统启动到现在锁定总时间长度</p><p>Innodb_row_lock_time_avg: 每次等待所花平均时间</p><p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间</p><p>Innodb_row_lock_waits:系统启动后到现在总共等待的次数</p><p>对于这5个状态变量，比较重要的主要是：</p><p>Innodb_row_lock_time_avg （等待平均时长）</p><p>Innodb_row_lock_waits （等待总次数）</p><p>Innodb_row_lock_time（等待总时长）</p></blockquote><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><pre><code>set tx_isolation=&#39;repeatable-read&#39;;Session_1执行：select * from account where id=1 for update;Session_2执行：select * from account where id=2 for update;Session_1执行：select * from account where id=2 for update;Session_2执行：select * from account where id=1 for update;</code></pre><p>查看近期死锁日志信息：</p><pre><code>show engine innodb status; </code></pre><p>大多数情况mysql可以自动检测死锁并回滚产生死锁的那个事务，但是有些情况mysql没法自动检测死锁</p><h1 id="三、关于锁的优化建议"><a href="#三、关于锁的优化建议" class="headerlink" title="三、关于锁的优化建议"></a>三、关于锁的优化建议</h1><ol><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;锁是计算机协调多个进程或线程并发访问某一资源的机制。&lt;br&gt;在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://brokge.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>线程通信的方式</title>
    <link href="https://brokge.github.io/2020/07/31/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://brokge.github.io/2020/07/31/线程通信的方式/</id>
    <published>2020-07-31T09:49:53.000Z</published>
    <updated>2020-08-21T04:40:32.285Z</updated>
    
    <content type="html"><![CDATA[<p>线程通信也就是线程之间的协作方式。</p><a id="more"></a><h1 id="1-线程协作的方式"><a href="#1-线程协作的方式" class="headerlink" title="1. 线程协作的方式"></a>1. 线程协作的方式</h1><p>要想实现多个线程之间的通信协作<br>如： 线程执行的先后顺序、获取某个线程执行的结果等。</p><p>涉及到线程之间的相互通信/协作，可以分为 以下四类：</p><ol><li><p>文件共享</p></li><li><p>网络共享</p></li><li><p>共享变量</p></li><li><p>JDK 提供的线程协同 API </p><ol><li>suppend/resume  (已经弃用)</li><li>wait/notify</li><li>park/unpark</li></ol></li><li><p>管道通信</p></li></ol><p>下面主要针对 共享变量 和 JDK 提供的线程协作 API 来做个梳理。</p><h1 id="2-共享变量"><a href="#2-共享变量" class="headerlink" title="2. 共享变量"></a>2. 共享变量</h1><p>所谓共享变量，即通过一个线程之间可以共享的变量来达到线程之间通信的目的。</p><p>根据 JVM 的特性，线程之间能够共享的变量方式，即 静态变量。</p><h2 id="共享变量代码示例"><a href="#共享变量代码示例" class="headerlink" title="共享变量代码示例"></a>共享变量代码示例</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>hc<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>chapter1<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 定义共享变量</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> String content <span class="token operator">=</span> <span class="token string">"空"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 线程1 - 写入数据</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          content <span class="token operator">=</span> <span class="token string">"当前时间"</span> <span class="token operator">+</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 线程2 - 读取数据</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程 1 对静态变量 content 做更改，则 线程 2 可以访问更改过的值。</p><h1 id="3-JDK-提供的线程协同-API"><a href="#3-JDK-提供的线程协同-API" class="headerlink" title="3. JDK 提供的线程协同 API"></a>3. JDK 提供的线程协同 API</h1><p>JDK 中对于需要多线程协作完成某一任务的场景，提供了对应的 API 支持。多线程协作的典型场景是：生产者-消费者模型。（线程阻塞、线程唤醒）。</p><p>下面通过一个场景来看 jdk 提供的线程协同 api 并做个对比。</p><p>场景是这样子：</p><blockquote><p>线程-1 去买包子，没有包子，则不再执行。线程-2 生产包子，通知线程继续执行，线程1收到通知继续买包子。</p></blockquote><p>流程图如下</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C7A478DEEB2D4E9482227967CCCA941E.jpg" alt="image"></p><h2 id="3-1-suspend-resume"><a href="#3-1-suspend-resume" class="headerlink" title="3.1 suspend/resume"></a>3.1 suspend/resume</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo6</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 包子店 */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object baozidian <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 正常的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动一个线程 consumerThread 购买包子，如果没包子，则进入等待 调用 <code>suspend()</code>,主线程 3秒之后生产一个包子，然后唤醒其他线程<code>resume()</code>。consumerThread 被唤醒继续执行 <code>3、买到包子，回家</code>。</p><p>按照正常逻辑以上代码没有问题，但是如果是以下方式呢？</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** 死锁的suspend/resume。 suspend并不会像wait一样释放锁，故此容易写出死锁代码 */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 导致程序永久挂起的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、没包子，进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 为这个线程加上一点延时</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 这里的挂起执行在resume后面</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上两种方式都是死锁的写法。</p><ul><li>suspendResumeDeadLockTest 写法中 suspend 并不释放锁，一直持有锁，导致主线程获取不到锁，不能执行 <code>resume()</code>唤醒操作， 故此容易写出死锁代码 。</li><li>suspendResumeDeadLockTest2 写法种，由于线程休眠的问题，导致<code>resume()</code> 再 <code>suspend()</code>之前调用，由于后续没有调用 <code>resume()</code>的操作，导致死锁。</li></ul><h2 id="3-2-notify-wait"><a href="#3-2-notify-wait" class="headerlink" title="3.2 notify/wait"></a>3.2 notify/wait</h2><p>notify / wait 必须再 synchronized 代码块中才会有效，而且 <code>wait</code> 和 <code>notify()</code> 调用之后会自动释放持有的锁。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 正常的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是也会写出死锁的代码，比如以下写法：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** 会导致程序永久等待的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然 <code>wait()</code> 会自动解锁，但是对顺序有要求。 如果 <code>wait()</code> 方法，是在 <code>notify</code> 之后调用，则线程会永远处于 <code>waitting</code> 状态。</p><h2 id="3-3-park-unpark"><a href="#3-3-park-unpark" class="headerlink" title="3.3 park/unpark"></a>3.3 park/unpark</h2><p><code>park</code> 是等待许可，<code>unpark</code> 是为指定线程提供许可，他的主要特性就是对顺序没有要求，调用<code>park</code>时候，如果调用过 <code>unpark</code> 则，线程直接执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 正常的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是 <code>unpark</code> 调用之后，许可只能使用一次。即只要调一次park，则许可就会失效。后续调用 <code>park</code>，则该线程会进入等待状态。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** 死锁的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-所有代码"><a href="#3-4-所有代码" class="headerlink" title="3.4 所有代码"></a>3.4 所有代码</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>hc<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>chapter1<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>LockSupport<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 三种线程协作通信的方式：suspend/resume、wait/notify、park/unpark */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo6</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 包子店 */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object baozidian <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 正常的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 死锁的suspend/resume。 suspend并不会像wait一样释放锁，故此容易写出死锁代码 */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 导致程序永久挂起的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、没包子，进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 为这个线程加上一点延时</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 这里的挂起执行在resume后面</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 正常的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 会导致程序永久等待的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 正常的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 死锁的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对调用顺序有要求，也要开发自己注意锁的释放。这个被弃用的API， 容易死锁，也容易导致永久挂起。</span><span class="token comment" spellcheck="true">//         new Demo6().suspendResumeTest();</span><span class="token comment" spellcheck="true">//         new Demo6().suspendResumeDeadLockTest();</span><span class="token comment" spellcheck="true">//         new Demo6().suspendResumeDeadLockTest2();</span>        <span class="token comment" spellcheck="true">// wait/notify要求再同步关键字里面使用，免去了死锁的困扰，但是一定要先调用wait，再调用notify，否则永久等待了</span>        <span class="token comment" spellcheck="true">// new Demo6().waitNotifyTest();</span><span class="token comment" spellcheck="true">//         new Demo6().waitNotifyDeadLockTest();</span>        <span class="token comment" spellcheck="true">// park/unpark没有顺序要求，但是park并不会释放锁，所有再同步代码中使用要注意</span><span class="token comment" spellcheck="true">//         new Demo6().parkUnparkTest();</span>         <span class="token keyword">new</span> <span class="token class-name">Demo6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parkUnparkDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol><li><p><strong>suspend 和 resume</strong> 容易写出死锁代码所以被弃用，导致死锁的原因： suspend 挂起之后不会释放锁；suspend 和 resume 先后顺序不保证。</p></li><li><p><strong>wait 和 notify</strong>。只能由同一对象锁的持有者线程调用，也就是说写在代码同步块里，否则会抛出 IllegalMonitorStateException 异常。wait 方法导致当前线程等待，加入该对象的等待集合中，并且 放弃当前持有的对象锁。notify 和 notifyAll 方法唤醒一个或所有正在等待这个对象锁的线程。</p><blockquote><p>注意：虽然  wait 会自动解锁，但是对顺序有要求。 如果 wait 方法，是在 notify 之后调用，则线程会永远处于 waitting 状态。</p></blockquote></li><li><p><strong>park / unpark</strong> park 是等待许可，unpark 是为指定线程提供许可，对顺序没有要求，调用park时候，如果调用过 unpark 则，线程直接执行。但由于许可的一次有效性，即只要调一次park，则许可就会失效。后续调用park，则该线程会进入等待状态。</p></li></ol><p><strong>伪唤醒问题</strong> 由于 jvm 在实现机制问题，通过以上三种方式会出现错误警报或伪唤醒的问题，这时并不是真正的满足条件唤醒。如果 通过 if 语句判断是否为空，来使线程进入等待状态，则会也会出现异常情况。</p><p>所以建议 通过 while 循环的写法，然后设置 flag 来检测线程的等待条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程通信也就是线程之间的协作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="并发编程" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>kafka 集群搭建</title>
    <link href="https://brokge.github.io/2020/07/25/kafka-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://brokge.github.io/2020/07/25/kafka-集群搭建/</id>
    <published>2020-07-25T04:30:57.000Z</published>
    <updated>2020-08-21T04:54:27.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装前的环境准备"><a href="#1-安装前的环境准备" class="headerlink" title="1. 安装前的环境准备"></a>1. 安装前的环境准备</h1><p>由于Kafka是用Scala语言开发的，运行在JVM上，因此在安装Kafka之前需要先安装JDK。</p><a id="more"></a><pre><code># yum install java-1.8.0-openjdk* -y</code></pre><p>kafka依赖zookeeper，所以需要先安装zookeeper</p><pre><code># wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz# tar -zxvf zookeeper-3.4.12.tar.gz# cd zookeeper-3.4.12# cp conf/zoo_sample.cfg conf/zoo.cfg</code></pre><p>启动zookeeper</p><pre><code># bin/zkServer.sh start# bin/zkCli.sh # ls /            #查看zk的根目录相关节点</code></pre><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="第一步：下载安装包"><a href="#第一步：下载安装包" class="headerlink" title="第一步：下载安装包"></a>第一步：下载安装包</h2><p>下载1.1.0 release版本，并解压：</p><pre><code># wget https://archive.apache.org/dist/kafka/1.1.0/kafka_2.11-1.1.0.tgz# tar -xzf kafka_2.11-1.1.0.tgz# cd kafka_2.11-1.1.0</code></pre><h2 id="第二步：启动服务"><a href="#第二步：启动服务" class="headerlink" title="第二步：启动服务"></a>第二步：启动服务</h2><p>现在来启动kafka服务：<br>启动脚本语法：</p><pre><code>kafka-server-start.sh [-daemon] server.properties</code></pre><p>可以看到，server.properties的配置路径是一个强制的参数，-daemon表示以后台进程运行，否则ssh客户端退出后，就会停止服务。(注意，在启动kafka时会使用linux主机名关联的ip地址，所以需要把主机名和linux的ip映射配置到本地host里，用vim /etc/hosts)</p><pre><code># bin/kafka-server-start.sh -daemon config/server.properties</code></pre><p>我们进入zookeeper目录通过zookeeper客户端查看下zookeeper的目录树</p><pre><code># bin/zkCli.sh # ls /            #查看zk的根目录kafka相关节点# ls /brokers/ids    #查看kafka节点</code></pre><h1 id="3-创建主题"><a href="#3-创建主题" class="headerlink" title="3. 创建主题"></a>3. 创建主题</h1><p>现在我们来创建一个名字为“test”的Topic，这个topic只有一个partition，并且备份因子也设置为1：</p><pre><code># bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre><p>现在我们可以通过以下命令来查看kafka中目前存在的topic</p><pre><code># bin/kafka-topics.sh --list --zookeeper localhost:2181</code></pre><p>除了我们通过手工的方式创建Topic，我们可以配置broker，当producer发布一个消息某个指定的Topic，但是这个Topic并不存在时，就自动创建。</p><h1 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4. 发送消息"></a>4. 发送消息</h1><p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。<br>首先我们要运行发布消息的脚本，然后在命令中输入要发送的消息的内容：</p><pre><code># bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test &gt;this is a msg&gt;this is a another msg </code></pre><h1 id="5-消费消息"><a href="#5-消费消息" class="headerlink" title="5. 消费消息"></a>5. 消费消息</h1><p>对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输出：</p><pre><code># bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test   --from-beginning #老版本# bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --consumer-property group.id=testGroup --consumer-property client.id=consumer-1  --topic test    #新版本</code></pre><p>如果你是通过不同的终端窗口来运行以上的命令，你将会看到在producer终端输入的内容，很快就会在consumer的终端窗口上显示出来。<br>以上所有的命令都有一些附加的选项；当我们不携带任何参数运行命令的时候，将会显示出这个命令的详细用法。<br>还有一些其他命令如下：<br>查看组名</p><pre><code>#  bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list --new-consumer</code></pre><p>查看消费者的消费偏移量</p><pre><code># bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group testGroup</code></pre><p>消费多主题</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --whitelist &quot;test|test-2&quot;</code></pre><h2 id="5-1-单播消费"><a href="#5-1-单播消费" class="headerlink" title="5.1 单播消费"></a>5.1 单播消费</h2><p>一条消息只能被某一个消费者消费的模式，类似queue模式，只需让所有消费者在同一个消费组里即可<br>分别在两个客户端执行如下消费命令，然后往主题里发送消息，结果只有一个客户端能收到消息</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --consumer-property group.id=testGroup --topic test </code></pre><h2 id="5-2-多播消费"><a href="#5-2-多播消费" class="headerlink" title="5.2 多播消费"></a>5.2 多播消费</h2><p>一条消息能被多个消费者消费的模式，类似publish-subscribe模式费，针对Kafka同一条消息只能被同一个消费组下的某一个消费者消费的特性，要实现多播只要保证这些消费者属于不同的消费组即可。我们再增加一个消费者，该消费者属于testGroup-2消费组，结果两个客户端都能收到消息</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --consumer-property group.id=testGroup-2 --topic test </code></pre><h1 id="6-kafka集群配置"><a href="#6-kafka集群配置" class="headerlink" title="6. kafka集群配置"></a>6. kafka集群配置</h1><p>到目前为止，我们都是在一个单节点上运行broker，这并没有什么意思。对于kafka来说，一个单独的broker意味着kafka集群中只有一个接点。要想增加kafka集群中的节点数量，只需要多启动几个broker实例即可。为了有更好的理解，现在我们在一台机器上同时启动三个broker实例。</p><h2 id="6-1-第一步配置文件"><a href="#6-1-第一步配置文件" class="headerlink" title="6.1 第一步配置文件"></a>6.1 第一步配置文件</h2><p>我们需要建立好其他2个broker的配置文件：</p><pre><code># cp config/server.properties config/server-1.properties# cp config/server.properties config/server-2.properties</code></pre><pre><code>配置文件的内容分别如下：config/server-1.properties:    broker.id=1    listeners=PLAINTEXT://:9093    log.dir=/tmp/kafka-logs-1config/server-2.properties:    broker.id=2    listeners=PLAINTEXT://:9094    log.dir=/tmp/kafka-logs-2</code></pre><p><strong>broker.id</strong> 属性在kafka集群中必须要是唯一的。</p><p>我们需要重新指定port和log目录，因为我们是在同一台机器上运行多个实例。如果不进行修改的话，consumer 只能获取到一个 instance 实例的信息，或者是相互之间的数据会被影响。<br>目前我们已经有一个zookeeper实例和一个broker实例在运行了.</p><h2 id="6-2-第二步-启动实例"><a href="#6-2-第二步-启动实例" class="headerlink" title="6.2 第二步 启动实例"></a>6.2 第二步 启动实例</h2><p>现在我们只需要在启动2个broker实例即可：</p><pre><code># bin/kafka-server-start.sh -daemon config/server-1.properties# bin/kafka-server-start.sh -daemon config/server-2.properties</code></pre><h2 id="6-3-第三步-创建新的topic"><a href="#6-3-第三步-创建新的topic" class="headerlink" title="6.3 第三步 创建新的topic"></a>6.3 第三步 创建新的topic</h2><p>现在我们创建一个新的topic，备份因子设置为3：</p><pre><code># bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</code></pre><p>现在我们已经有了集群，并且创建了一个3个备份因子的topic，但是到底是哪一个broker在为这个topic提供服务呢(因为我们只有一个分区，所以肯定同时只有一个broker在处理这个topic)？</p><pre><code># bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/4A84105C94DF433286557C4A47EB2087.jpg" alt="image"></p><blockquote><p>以下是输出内容的解释，第一行是所有分区的概要信息，之后的每一行表示每一个partition的信息。因为目前我们只有一个partition，因此关于partition的信息只有一行。<br>leader节点负责给定partition的所有读写请求。<br>replicas 表示某个partition在哪几个broker上存在备份。不管这个几点是不是”leader“，甚至这个节点挂了，也会列出。<br>isr 是replicas的一个子集，它只列出当前还存活着的，并且备份了该partition的节点。</p></blockquote><p>现在我们的案例中，0号节点是leader，即使用server.properties 启动的那个进程。</p><h2 id="6-4-第四步-发送消息"><a href="#6-4-第四步-发送消息" class="headerlink" title="6.4 第四步 发送消息"></a>6.4 第四步 发送消息</h2><p>现在我们向新建的topic中发送一些message：</p><pre><code># bin/kafka-console-producer.sh --broker-list localhost:9092 --topic my-replicated-topic&gt;my test msg 1&gt;my test msg 2</code></pre><h2 id="6-5-第五步-消费消息"><a href="#6-5-第五步-消费消息" class="headerlink" title="6.5 第五步 消费消息"></a>6.5 第五步 消费消息</h2><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic my-replicated-topicmy test msg 1my test msg 2</code></pre><h2 id="6-6-第六步-测试容错性"><a href="#6-6-第六步-测试容错性" class="headerlink" title="6.6 第六步 测试容错性"></a>6.6 第六步 测试容错性</h2><p>现在我们来测试我们容错性，因为broker0目前是leader，所以我们要将其kill</p><pre><code># ps -ef | grep server.properties# kill -9 1177</code></pre><p>现在再执行命令：</p><pre><code># bin/kafka-topics.sh --describe --zookeeper localhost:9092 --topic my-replicated-topic</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F9EE7EAD337748ABB25CB8BE81179AC8.jpg" alt="image"></p><blockquote><p>我们可以看到，leader节点已经变成了broker 2.要注意的是，在Isr中，已经没有了0号节点。leader的选举也是从ISR(in-sync replica)中进行的。</p></blockquote><p>此时，我们依然可以 消费新消息</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic my-replicated-topicmy test msg 1my test msg 2</code></pre><p>查看主题分区对应的leader信息：</p><p>需要通过zk 客户端查看：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1A9C68F18131409E844516D103E78B50.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-安装前的环境准备&quot;&gt;&lt;a href=&quot;#1-安装前的环境准备&quot; class=&quot;headerlink&quot; title=&quot;1. 安装前的环境准备&quot;&gt;&lt;/a&gt;1. 安装前的环境准备&lt;/h1&gt;&lt;p&gt;由于Kafka是用Scala语言开发的，运行在JVM上，因此在安装Kafka之前需要先安装JDK。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="MQ" scheme="https://brokge.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>kafka 概念和原理详解</title>
    <link href="https://brokge.github.io/2020/07/22/kafka-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://brokge.github.io/2020/07/22/kafka-概念和原理详解/</id>
    <published>2020-07-22T04:28:51.000Z</published>
    <updated>2020-08-21T04:56:34.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，使用Scala编写。<br>对于熟悉JMS（Java Message Service）规范的同学来说，消息系统已经不是什么新概念了(例如ActiveMQ，RabbitMQ等)。</p><a id="more"></a><p>Kafka 拥有作为一个消息系统应该具备的功能，但是确有着独特的设计。可以这样来说，Kafka 借鉴了JMS规范的思想，但是确并没有完全遵循JMS规范。</p><p>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该具备的功能，但是确有着独特的设计。</p><h2 id="1-1-首先，让我们来看一下基础的消息-Message-相关术语"><a href="#1-1-首先，让我们来看一下基础的消息-Message-相关术语" class="headerlink" title="1.1 首先，让我们来看一下基础的消息(Message)相关术语"></a>1.1 首先，让我们来看一下基础的消息(Message)相关术语</h2><ul><li>Topic: Kafka按照Topic分类来维护消息</li><li>Producer： 我们将发布(publish)消息到Topic的进程称之为生产者(producer)</li><li>Consumer： 我们将订阅(subscribe)Topic并且处理Topic中消息的进程称之为消费者(consumer)</li><li>Broker：Kafka以集群的方式运行，集群中的每一台服务器称之为一个代理(broker)。</li></ul><p>因此，从一个较高的层面上来看，producers通过网络发送消息到Kafka集群，然后consumers来进行消费，</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/94E20F013CAA4F3694867F196F09F9D7.jpg" alt="image"></p><p>服务端(brokers)和客户端(producer、consumer)之间通信通过TCP协议来完成。Kafka提供了一个Java客户端，但是也可以使用其他语言编写的客户端。</p><h3 id="1-1-1-Topic和Log"><a href="#1-1-1-Topic和Log" class="headerlink" title="1.1.1 Topic和Log"></a>1.1.1 Topic和Log</h3><p>让我们首先深入理解Kafka提出一个高层次的抽象概念-Topic。<br>可以理解Topic是一个类别的名称，所有的message发送到Topic下面。对于每一个Topic，kafka集群按照如下方式维护一个分区(Partition,可以就理解为一个队列Queue)日志文件:</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7E80C11FB6AE43B1A579D9A283331D43.jpg" alt="image"></p><p>partition是一个有序的message序列，这些message按顺序添加到一个叫做commit log的文件中。每个partition中的消息都有一个唯一的编号，称之为offset，用来唯一标示某个分区中的message。</p><blockquote><p>提示：每个 partition ，都对应一个commit-log。一个 partition 中的message的offset都是唯一的，但是不同的partition中的message的offset可能是相同的。</p></blockquote><p><strong>kafka集群</strong>，在配置的时间范围内，维护所有的由producer生成的消息，而不管这些消息有没有被消费。例如日志保留( log retention )时间被设置为2天。kafka会维护最近2天生产的所有消息，而2天前的消息会被丢弃。==kafka 的性能与保留的数据量的大小没有关系==，因此保存大量的数据(日志信息)不会有什么影响。</p><p><strong>关于 consumer</strong> ，每个consumer是基于自己在commit log 中的消费进度(offset)来进行工作的。在kafka中，offset由consumer来维护：一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息，或者跳过某些消息。</p><p>这意味 kafka 中的 consumer 对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer来说，都是没有影响的，因此==每个consumer维护各自的offset==。</p><p><strong>对log进行分区（partitioned）目的是什么？</strong></p><ul><li>首先，当log文件大小超过系统文件系统的限制时，可以自动拆分。每个partition对应的log都受到所在机器的文件系统大小的限制，但是一个Topic中是可以有很多分区的，因此可以处理任意数量的数据。</li><li>另一个方面，是为了提高并行度。</li></ul><h3 id="1-1-3-Distribution"><a href="#1-1-3-Distribution" class="headerlink" title="1.1.3 Distribution"></a>1.1.3 Distribution</h3><p>log的partitions分布在kafka集群中不同的broker上，每个broker可以请求备份其他broker上partition上的数据。kafka集群支持配置一个partition备份的数量。</p><p>针对每个partition，都有一个broker起到“leader”的作用，0个多个其他的broker作为“follwers”的作用。leader处理所有的针对这个partition的读写请求，而==followers被动复制leader的结果==。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。==每个broker都是自己所管理的partition的leader，同时又是其他broker所管理partitions的followers，kafka通过这种方式来达到负载均衡。==</p><h3 id="1-1-3-Producers"><a href="#1-1-3-Producers" class="headerlink" title="1.1.3 Producers"></a>1.1.3 Producers</h3><p>生产者将消息发送到topic中去，同时负责选择将message发送到topic的哪一个partition中。通过round-robin（轮询）做简单的负载均衡。也可以根据消息中的某一个关键字来进行区分，比如指定定key 通过 hash 取模。通常第二种方式使用的更多。</p><h3 id="1-1-4-Consumers-和-Consumer-Group"><a href="#1-1-4-Consumers-和-Consumer-Group" class="headerlink" title="1.1.4 Consumers 和 Consumer Group"></a>1.1.4 Consumers 和 Consumer Group</h3><p>传统的消息传递模式有2种：队列( queuing )和（ publish-subscribe）。<br>在queuing模式中，多个consumer从服务器中读取数据，消息只会到达一个consumer。在 publish-subscribe 模型中，消息会被广播给所有的consumer。==Kafka基于这2种模式提供了一种consumer的抽象概念==：==consumer group==。</p><p>每个consumer都要标记自己属于哪一个 consumer group。发布到 topic 中的 message 中 message 会被传递到 consumer group 中的一个 consumer 实例。consumer实例可以运行在不同的进程上，也可以在不同的物理机器上。<br>如果所有的consumer都位于同一个consumer group 下，这就类似于传统的queue模式，并在众多的consumer instance之间进行负载均衡。<br>如果所有的consumer都有着自己唯一的consumer group，这就类似于传统的publish-subscribe模型。</p><p>更一般的情况是，通常一个topic会有几个consumer group，每个consumer group都是一个逻辑上的订阅者（ logical subscriber ）。每个consumer group由多个consumer instance 组成，从而达到可扩展和容灾的功能。这并没有什么特殊的地方，仅仅是将publish-subscribe模型中的运行在单个进程上的consumers中的consumer替换成一个consumer group。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/79D77C03B804413AB5D481ACDBBA0FC6.jpg" alt="image"></p><blockquote><p>说明：由2个broker组成的kafka集群，总共有4个 Parition (P0-P3)。这个集群由2个Consumer Group， A有2个 consumer instances ，而B有四个.consumer instances的个数不能大于对应topic 的 Parition 个数。</p></blockquote><h2 id="1-2-消费顺序"><a href="#1-2-消费顺序" class="headerlink" title="1.2  消费顺序"></a>1.2  消费顺序</h2><p>Kafka 比传统的消息系统有着更强的顺序保证。</p><p><strong>在传统的情况下</strong>：服务器按照顺序保留消息到队列，如果有多个consumer来消费队列中的消息，服务器 会接受消息的顺序向外提供消息。但是，尽管服务器是按照顺序提供消息，但是消息传递到每一个consumer是异步的，这可能会导致先消费的 consumer获取到消息时间可能比后消费的consumer获取到消息的时间长，导致不能保证顺序性。这表明，当进行并行的消费的时候，消息在多个 consumer之间可能会失去顺序性。消息系统通常会采取一种“ exclusive consumer”的概念，来确保同一时间内只有一个consumer能够从队列中进行消费，但是这实际上意味着在消息处理的过程中是不支持并行的。</p><p><strong>Kafka</strong>：在这方面做的更好。通过Topic中并行度的概念，即partition，Kafka可以同时提供顺序性保证和多个consumer同时消费时的负载均衡。实现的原理是通过将一个topic中的partition分配给一个consumer group中的不同consumer instance。<br>通过这种方式，我们可以保证一个partition在同一个时刻只有一个consumer instance在消息，从而保证顺序。虽然一个topic中有多个partition，但是一个consumer group中同时也有多个consumer instance，通过合理的分配依然能够保证负载均衡。需要注意的是，一个consumer group中的consumer instance的数量不能比一个Topic中的partition的数量多。</p><p>Kafka只在 partition 的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。</p><p>通常来说，这已经可以满足大部分应用的需求。但是，如果的确有在总体上保证消费的顺序的需求的话，那么我们可以通过将 topic 的 partition 数量设置为1，将 consumer group 中的 consumer instance 数量也设置为1.</p><h2 id="1-3-Guarantees（担保）"><a href="#1-3-Guarantees（担保）" class="headerlink" title="1.3 Guarantees（担保）"></a>1.3 Guarantees（担保）</h2><p>从较高的层面上来说的话，Kafka提供了以下的保证：</p><p><strong>发送顺序保证:</strong> 发送到一个Topic中的message会按照发送的顺序添加到commit log 中。意思是，如果消息 M1，M2 由同一个producer发送，M1 比 M2 发送的早的话，那么在 commit log 中，M1的 offset一定比commit M2的 offset 小。</p><p><strong>消息容灾保证:</strong> 一个consumer在commit log中可以按照发送顺序来消费message<br>如果一个 topic 的备份因子( replication factor )设置为N，那么Kafka可以容忍N-1个服务器的失败，而存储在commit log中的消息不会丢失。</p><h1 id="2-Kafka设计原理分析"><a href="#2-Kafka设计原理分析" class="headerlink" title="2. Kafka设计原理分析"></a>2. Kafka设计原理分析</h1><h2 id="2-1-kafka-拓扑结构"><a href="#2-1-kafka-拓扑结构" class="headerlink" title="2.1 kafka 拓扑结构"></a>2.1 kafka 拓扑结构</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/04CD2B96DA934EC8A301480B308A9DE7.jpg" alt="image"></p><h2 id="2-2-kafka-zoopeeper-节点结构"><a href="#2-2-kafka-zoopeeper-节点结构" class="headerlink" title="2.2 kafka zoopeeper 节点结构"></a>2.2 kafka zoopeeper 节点结构</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5C5F8A937B9245F7956014A6010F9E0E.jpg" alt="image"></p><ul><li>topics 节点为永久节点类型（防止数据丢失）。</li><li>ids 为临时节点（节点挂掉，就需要删除id）</li></ul><h2 id="2-3-producer-发布消息"><a href="#2-3-producer-发布消息" class="headerlink" title="2.3 producer 发布消息"></a>2.3 producer 发布消息</h2><h3 id="2-3-1-写入方式"><a href="#2-3-1-写入方式" class="headerlink" title="2.3.1 写入方式"></a>2.3.1 写入方式</h3><p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。</p><h3 id="2-3-2-消息路由"><a href="#2-3-2-消息路由" class="headerlink" title="2.3.2 消息路由"></a>2.3.2 消息路由</h3><p>producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。<br>其路由机制为：</p><ol><li>指定了 patition，则直接使用；</li><li>未指定 patition 但指定 key，通过对 key 的 value 进行hash 选出一个 patition</li><li>patition 和 key 都未指定，使用轮询选出一个 patition。<br>3、写入流程</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5575DC56967641BC9AF89F9C8078E6B9.jpg" alt="image"></p><blockquote><ol><li>producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader</li><li>producer 将消息发送给该 leader</li><li>leader 将消息写入本地 log</li><li>followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK</li><li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK</li></ol></blockquote><h2 id="2-4-kafka分区leader选举原理"><a href="#2-4-kafka分区leader选举原理" class="headerlink" title="2.4 kafka分区leader选举原理"></a>2.4 kafka分区leader选举原理</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/10991B022F3F4E829DEFB78EA4228095.jpg" alt="image"></p><p>选举原理：是根据 zookeeper 的锁机制来实现，同一时间创建临时节点写入参选信息，只有一个flower 能写入成功，写入成功的即为  leader。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Kafka是一种高吞吐量的分布式发布订阅消息系统，使用Scala编写。&lt;br&gt;对于熟悉JMS（Java Message Service）规范的同学来说，消息系统已经不是什么新概念了(例如ActiveMQ，RabbitMQ等)。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="MQ" scheme="https://brokge.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>JVM- 虚拟机调优工具</title>
    <link href="https://brokge.github.io/2020/07/10/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
    <id>https://brokge.github.io/2020/07/10/JVM-虚拟机调优工具/</id>
    <published>2020-07-10T12:46:00.000Z</published>
    <updated>2020-08-21T04:56:55.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JVM-调优监控命令行工具介绍"><a href="#1-JVM-调优监控命令行工具介绍" class="headerlink" title="1. JVM 调优监控命令行工具介绍"></a>1. JVM 调优监控命令行工具介绍</h1><a id="more"></a><h2 id="1-1-jps"><a href="#1-1-jps" class="headerlink" title="1.1 jps"></a>1.1 jps</h2><p>查看运行进程 以及进程 id。</p><h2 id="1-2-Jinfo"><a href="#1-2-Jinfo" class="headerlink" title="1.2 Jinfo"></a>1.2 Jinfo</h2><p>查看正在运行的Java应用程序的扩展参数</p><ol><li>查看jvm的参数</li></ol><pre><code>jinfo -flags 30880</code></pre><ol start="2"><li><p>查看java系统参数</p><pre><code>jinfo -sysprops 30880</code></pre><h2 id="1-3-jstat"><a href="#1-3-jstat" class="headerlink" title="1.3 jstat"></a>1.3 jstat</h2><p>jstat 命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：<br>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]<br>注意：使用的jdk版本是jdk8.</p></li><li><p>类加载统计</p><pre><code>jstat -class 5989</code></pre></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B3B456FC88EE4870A8C30E2E785ECED4.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>Loaded</td><td>加载class的数量</td></tr><tr><td>Bytes</td><td>所占用空间大小</td></tr><tr><td>Unloaded</td><td>未加载数量</td></tr><tr><td>Bytes</td><td>未加载占用空间</td></tr><tr><td>Time</td><td>时间</td></tr></tbody></table><ol start="2"><li>垃圾回收统计</li></ol><pre><code>jstat -gc 5989</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/84830F699417470C859862202F3AA646.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>S0C</td><td>第一个幸存区的大小</td></tr><tr><td>S1C</td><td>第二个幸存区的大小</td></tr><tr><td>S0U</td><td>第一个幸存区的使用大小</td></tr><tr><td>S1U</td><td>第二个幸存区的使用大小</td></tr><tr><td>EC</td><td>伊甸园区的大小</td></tr><tr><td>EU</td><td>伊甸园区的使用大小</td></tr><tr><td>OC</td><td>老年代大小</td></tr><tr><td>OU</td><td>老年代使用大小</td></tr><tr><td>MC</td><td>方法区大小(元空间)</td></tr><tr><td>MU</td><td>方法区使用大小</td></tr><tr><td>CCSC</td><td>压缩类空间大小</td></tr><tr><td>CCSU</td><td>压缩类空间使用大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table><ol start="3"><li>堆内存统计</li></ol><pre><code>jstat -gccapacity 5989</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E033D8E689C4436D81692D953BD25632.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>NGCMN</td><td>新生代最小容量</td></tr><tr><td>NGCMX</td><td>新生代最大容量</td></tr><tr><td>NGC</td><td>当前新生代容量</td></tr><tr><td>S0C</td><td>第一个幸存区大小</td></tr><tr><td>S1C</td><td>第二个幸存区的大小</td></tr><tr><td>EC</td><td>伊甸园区的大小</td></tr><tr><td>OGCMN</td><td>老年代最小容量</td></tr><tr><td>OGCMX</td><td>老年代最大容量</td></tr><tr><td>OGC</td><td>当前老年代大小</td></tr><tr><td>OC</td><td>当前老年代大小</td></tr><tr><td>MCMN</td><td>最小元数据容量</td></tr><tr><td>MCMX</td><td>最大元数据容量</td></tr><tr><td>MC</td><td>当前元数据空间大小</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小</td></tr><tr><td>CCSMX</td><td>最大压缩类空间大小</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小</td></tr><tr><td>YGC</td><td>年轻代gc次数</td></tr><tr><td>FGC</td><td>老年代GC次数</td></tr></tbody></table><ol start="4"><li>新生代垃圾回收统计</li></ol><pre><code>jstat -gcnew 13988</code></pre><ol start="5"><li>新生代内存统计</li></ol><pre><code>jstat -gcnewcapacity 13988</code></pre><ol start="6"><li>老年代垃圾回收统计</li></ol><pre><code>jstat -gcold 13988</code></pre><ol start="7"><li>老年代内存统计<pre><code>jstat -gcoldcapacity 13988</code></pre></li><li>元数据空间统计<pre><code>jstat -gcmetacapacity 13988</code></pre></li></ol><h2 id="1-4-jmap"><a href="#1-4-jmap" class="headerlink" title="1.4 jmap"></a>1.4 jmap</h2><p>此命令可以用来查看内存信息,查询内存溢出（OOM）可以通过这个命令。</p><ol><li>实例个数以及占用内存大小</li></ol><pre><code>jmap -histo 8899 &gt;./log.txt</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7B15E576C60E4DCA9B09712C6D9930E6.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>num</td><td>序号</td></tr><tr><td>instances</td><td>实例数量</td></tr><tr><td>bytes</td><td>占用空间大小</td></tr><tr><td>class name</td><td>类名称</td></tr></tbody></table><ol start="2"><li>堆信息</li></ol><pre><code>jmap -heap 8899</code></pre><ol start="3"><li>堆内存dump</li></ol><pre><code>jmap -dump:format=b,file = log.hprof 8899</code></pre><p>也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)</p><pre><code>-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=./ （路径）</code></pre><p>可以用 <code>jvisualvm</code> 命令工具导入该 dump文件分析</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0843F9809FB540259A749275DFCEF883.jpg" alt="image"></p><h2 id="1-5-Jstack"><a href="#1-5-Jstack" class="headerlink" title="1.5 Jstack"></a>1.5 Jstack</h2><p>查看堆栈信息,<strong>栈溢出或死锁可以通过这个工具</strong>。</p><pre><code>jstack 88999</code></pre><p>用 jstack 查找死锁，见如下示例，也可以用<code>jvisualvm</code> 查看死锁</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread1 begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread1 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread2 begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread2 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0EB4FF290AC94746BAF3745D7CA1948F.jpg" alt="image"></p><h1 id="2-可视化工具-jvisualvm"><a href="#2-可视化工具-jvisualvm" class="headerlink" title="2. 可视化工具 jvisualvm"></a>2. 可视化工具 jvisualvm</h1><pre><code>jvisualvm</code></pre><h2 id="2-1-启动jvisualvm的远程链接"><a href="#2-1-启动jvisualvm的远程链接" class="headerlink" title="2.1 启动jvisualvm的远程链接"></a>2.1 启动jvisualvm的远程链接</h2><p>启动普通的jar程序JMX端口配置：</p><pre><code>java -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -jar foo.jar</code></pre><p>tomcat的JMX配置</p><pre><code>JAVA_OPTS=-Dcom.sun.management.jmxremote.port=8999-Dcom.sun.management.jmxremote.ssl=false-Dcom.sun.management.jmxremote.authenticate=false</code></pre><p>jvisualvm 远程连接服务需要在远程服务器上配置host(连接ip 主机名)，并且要关闭防火墙。</p><h1 id="3-jstack找出占用cpu最高的堆栈信息"><a href="#3-jstack找出占用cpu最高的堆栈信息" class="headerlink" title="3. jstack找出占用cpu最高的堆栈信息"></a>3. jstack找出占用cpu最高的堆栈信息</h1><ol><li><p>使用命令<code>top -p &lt;pid&gt;</code> ，显示你的java进程的内存情况，pid是你的java进程号，比如4977</p></li><li><p>按H，获取每个线程的内存情况 </p></li><li><p>找到内存和cpu占用最高的线程tid，比如4977 </p></li><li><p>转为十六进制得到 0x1371 ,此为线程id的十六进制表示</p></li><li><p>执行 <code>jstack 4977|grep -A 10 1371</code>，得到线程堆栈信息中1371这个线程所在行的后面10行 </p></li><li><p>查看对应的堆栈信息找出可能存在问题的代码</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JVM-调优监控命令行工具介绍&quot;&gt;&lt;a href=&quot;#1-JVM-调优监控命令行工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1. JVM 调优监控命令行工具介绍&quot;&gt;&lt;/a&gt;1. JVM 调优监控命令行工具介绍&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="虚拟机" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://brokge.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM- 内存回收机制</title>
    <link href="https://brokge.github.io/2020/07/08/JVM-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://brokge.github.io/2020/07/08/JVM-内存回收机制/</id>
    <published>2020-07-08T08:44:57.000Z</published>
    <updated>2020-08-21T04:57:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/84A35B9748EC46758F35BA070CBA4564.jpg" alt="image"></p><h1 id="2-JVM内存分配与回收"><a href="#2-JVM内存分配与回收" class="headerlink" title="2. JVM内存分配与回收"></a>2. JVM内存分配与回收</h1><h2 id="2-1-Minor-Gc-和-Full-GC-有什么不同呢？"><a href="#2-1-Minor-Gc-和-Full-GC-有什么不同呢？" class="headerlink" title="2.1 Minor Gc 和 Full GC 有什么不同呢？"></a>2.1 Minor Gc 和 Full GC 有什么不同呢？</h2><p>垃圾回收方式有两种 MinorGC 和 Full GC</p><p><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。通常 Minor GC 也叫做 Young GC.</p><p><strong>老年代GC（Major GC/Full GC</strong>）:指发生在老年代的 GC，出现了Major GC经常会伴随至少一次的 Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。老年代 GC 也可称为 Old GC.</p><h2 id="2-2-对象优先在Eden区分配"><a href="#2-2-对象优先在Eden区分配" class="headerlink" title="2.2 对象优先在Eden区分配"></a>2.2 对象优先在Eden区分配</h2><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次<strong>Minor GC</strong></p><h3 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h3><pre><code>public static void main(String[] args) throws InterruptedException {        byte[] allocation1, allocation2;        allocation1 = new byte[20231 * 1024];        //allocation2 = new byte[10000*1024];        try {            System.in.read();        } catch (IOException e) {            e.printStackTrace();        }    }</code></pre><pre><code>Heap PSYoungGen      total 38400K, used 26468K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)  eden space 33280K, 79% used [0x0000000795580000,0x0000000796f59348,0x0000000797600000)  from space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)  to   space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000) ParOldGen       total 87552K, used 0K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)  object space 87552K, 0% used [0x0000000740000000,0x0000000740000000,0x0000000745580000) Metaspace       used 3600K, capacity 4536K, committed 4864K, reserved 1056768K  class space    used 401K, capacity 428K, committed 512K, reserved 1048576K</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A58B033A8C194AF7BC9AC2684D048B35.jpg" alt="image"></p><p>从上图我们可以看出eden区内存已经被分配79%（即使程序什么也不做，新生代也会使用至少2000多k内存）。<br>假如我们再为allocation2分配内存会出现什么情况呢？  </p><pre><code>Heap PSYoungGen      total 38400K, used 3190K [0x0000000795580000, 0x000000079a080000, 0x00000007c0000000)  eden space 33280K, 8% used [0x0000000795580000,0x0000000795819a30,0x0000000797600000)  from space 5120K, 10% used [0x0000000797600000,0x0000000797684010,0x0000000797b00000)  to   space 5120K, 0% used [0x0000000799b80000,0x0000000799b80000,0x000000079a080000) ParOldGen       total 87552K, used 30239K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)  object space 87552K, 34% used [0x0000000740000000,0x0000000741d87c20,0x0000000745580000) Metaspace       used 3600K, capacity 4536K, committed 4864K, reserved 1056768K  class space    used 401K, capacity 428K, committed 512K, reserved 1048576K</code></pre><p>简单解释一下为什么会出现这种情况： 因为给 allocation2 分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survior 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现Full GC。执行 Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。</p><p>发生 Minor GC的次数 也可以通过下面的统计信息看到，<code>YGC = 1</code>。<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D005CBE2829A445E89EE71A29C44F692.jpg" alt="image"></p><h2 id="2-3-对象进入老年的方式"><a href="#2-3-对象进入老年的方式" class="headerlink" title="2.3 对象进入老年的方式"></a>2.3 对象进入老年的方式</h2><h3 id="2-3-1-大对象直接进入老年代"><a href="#2-3-1-大对象直接进入老年代" class="headerlink" title="2.3.1 大对象直接进入老年代"></a>2.3.1 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<br>为什么要这样呢？<br>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="2-3-2-长期存活的对象将进入老年代"><a href="#2-3-2-长期存活的对象将进入老年代" class="headerlink" title="2.3.2 长期存活的对象将进入老年代"></a>2.3.2 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。<br>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold </code>来设置。</p><h2 id="2-4-如何判断对象可以被回收"><a href="#2-4-如何判断对象可以被回收" class="headerlink" title="2.4 如何判断对象可以被回收"></a>2.4 如何判断对象可以被回收</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><h3 id="2-4-1-引用计数法"><a href="#2-4-1-引用计数法" class="headerlink" title="2.4.1 引用计数法"></a>2.4.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。<br>这个方法实现简单，效率高，==但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，== 如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</p><pre><code>public class ReferenceCountingGc {    Object instance = null;    public static void main(String[] args) {        ReferenceCountingGc objA = new ReferenceCountingGc();        ReferenceCountingGc objB = new ReferenceCountingGc();        objA.instance = objB;        objB.instance = objA;        objA = null;        objB = null;    }}</code></pre><h3 id="2-4-2-可达性分析算法"><a href="#2-4-2-可达性分析算法" class="headerlink" title="2.4.2 可达性分析算法"></a>2.4.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><strong>GC Roots根节点</strong>：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等等</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A5C7B9534B934431A6328BBAEE20FE9F.jpg" alt="image"></p><h3 id="2-4-3-finalize-方法最终判定对象是否存活"><a href="#2-4-3-finalize-方法最终判定对象是否存活" class="headerlink" title="2.4.3 finalize()方法最终判定对象是否存活"></a>2.4.3 finalize()方法最终判定对象是否存活</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FCBB514303EA44C79F7FD4315F15F2EC.jpg" alt="image"><br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，还可以再抢救以下，至少要经历再次标记过程。标记的前提是对象在进行可达性分析后发现没有与 GCRoots 相连接的引用链。</p><p>两次标记 。</p><ol><li><p>第一次标记并进行一次筛选。<br>筛选的条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。</p></li><li><p>第二次标记<br>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</p></li></ol><p>finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己(只要重新与引用链上的任何的一个对象建立关联即可)，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。</p><p>如果对象这时候还没逃脱，那基本上它就真的被回收了。</p><p> 测试代码：</p><pre><code>public class OOMTest {    // JVM设置    // -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\jvm.dump    public static void main(String[] args) {        List list = new ArrayList();        int i = 0;        int j = 0;        while (true) {            list.add(new User(i++, UUID.randomUUID().toString()));            new User(j--, UUID.randomUUID().toString());        }    }}</code></pre><h3 id="2-4-4-如何判断一个常量是废弃常量"><a href="#2-4-4-如何判断一个常量是废弃常量" class="headerlink" title="2.4.4 如何判断一个常量是废弃常量"></a>2.4.4 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？<br>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><h3 id="2-4-5-如何判断一个类是无用的类"><a href="#2-4-5-如何判断一个类是无用的类" class="headerlink" title="2.4.5 如何判断一个类是无用的类"></a>2.4.5 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？<br>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 “无用的类” ：</p><ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h1 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h1><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CF04E79D16864FCDAB9BCA4AED74A82E.jpg" alt="image"></p><h2 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h2><p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：</p><ol><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D20509B98FA94400B0119A7F96237875.jpg" alt="image"> </p><h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/63CB574DAD564B5483B146B5D49DDF14.jpg" alt="image"></p><h2 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h2><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F3E25E0FA9F84E2DA27673E094DF04E5.jpg" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/146612F58E97421CA4EB3ACC2A630B77.jpg" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5C04D60F7EA64FBB9A7CD1EDAA232368.jpg" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E82EA683993C42109AB7CBBDAC405717.jpg" alt="image"></p><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h1 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4. 垃圾收集器"></a>4. 垃圾收集器</h1><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/81F9203653EF45968896617D2F39B6FB.jpg" alt="image"></p><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>先对 并行和并发概念进行了解：</p><ul><li>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。适合科学计算、后台处理等弱交互场景。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。适合Web应用。</li></ul><p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。</p><h2 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a>4.1 Serial收集器</h2><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p><p>++新生代采用复制算法，老年代采用标记-整理算法。++</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C6E4EECA4B7544B4B00A334485A89AEA.jpg" alt="image"></p><p>虚拟机的设计者们当然知道 <code>Stop The World</code> 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。<br>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p><h2 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a>4.2 ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。<br>==新生代采用复制算法，老年代采用标记-整理算法。==</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/EF654130AB66417EAFEFC1C1F8C20338.jpg" alt="image"></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><h2 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a>4.3 Parallel Scavenge收集器</h2><p>Parallel Scavenge 收集器类似于 ParNew 收集器，是 Server 模式（内存大于 2G，2 个 cpu）下的默认收集器，那么它有什么特别之处呢？</p><p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。<br>==新生代采用复制算法，老年代采用标记-整理算法。==</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CB2FC5646BCD4E00973AD3CF38DF1D2F.jpg" alt="image"></p><h2 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a>4.4 Serial Old收集器</h2><p>Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h2 id="4-5-Parallel-Old收集器"><a href="#4-5-Parallel-Old收集器" class="headerlink" title="4.5 Parallel Old收集器"></a>4.5 Parallel Old收集器</h2><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h2 id="4-6-CMS收集器-XX-UseConcMarkSweepGC-主要是old区使用"><a href="#4-6-CMS收集器-XX-UseConcMarkSweepGC-主要是old区使用" class="headerlink" title="4.6 CMS收集器(-XX:+UseConcMarkSweepGC(主要是old区使用))"></a>4.6 CMS收集器(-XX:+UseConcMarkSweepGC(主要是old区使用))</h2><p>CMS（Concurrent MarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。</p><p>整个过程分为四个步骤：</p><ul><li>初始标记：暂停所有的其他线程(STW)，并记录下直接与root相连的对象，速度很快 ；</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除：开启用户线程，同时GC线程开始对未标记的区域做清扫。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8036227F2EE742D6AB5D0510FB5DD71D.jpg" alt="image"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。</p><p>但是它有下面三个明显的缺点：</p><ol><li>对CPU资源敏感（会和服务抢资源）；</li><li>无法处理浮动垃圾(在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li><li></li></ol><p>CMS的相关参数</p><pre><code>-XX:+UseConcMarkSweepGC 启用cms-XX:ConcGCThreads:并发的GC线程数（并非STW时间，而是和服务一起执行的线程数）-XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩（减少碎片）-XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次（因压缩非常的消耗时间，所以不能每次FullGC都做）-XX:CMSInitiatingOccupancyFraction:触发FulGC条件（默认是92）-XX:+UseCMSInitiatingOccupancyOnly:是否动态调节-XX:+CMSScavengeBeforeRemark:FullGC之前先做YGC（一般这个参数是打开的）-XX:+CMSClassUnloadingEnabled:启用回收Perm区（jdk1.7及以前）</code></pre><h2 id="4-7-G1收集器-XX-UseG1GC"><a href="#4-7-G1收集器-XX-UseG1GC" class="headerlink" title="4.7 G1收集器(-XX:+UseG1GC)"></a>4.7 G1收集器(-XX:+UseG1GC)</h2><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/4421E80B1A4F4438AA637E46B2197F51.jpg" alt="image"></p><p>G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p><p>分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。</p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备以下特点：<br>并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p><ul><li>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内完成垃圾收集。</li></ul><h3 id="G1收集器的运作大致分为以下几个步骤："><a href="#G1收集器的运作大致分为以下几个步骤：" class="headerlink" title="G1收集器的运作大致分为以下几个步骤："></a>G1收集器的运作大致分为以下几个步骤：</h3><ol><li><p>初始标记（initial mark，STW）：在此阶段，G1 GC对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</p></li><li><p>并发标记（Concurrent Marking）：G1 GC在整个堆中查找可访问的（存活的）对象。</p></li><li><p>最终标记（Remark，STW）：该阶段是 STW 回收，帮助完成标记周期。</p></li><li><p>筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 </p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/319BBC12D56C4BE7929004D4648023D3.jpg" alt="image"></p><p><strong>G1收集器在后台维护了一个优先列表</strong>，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率。</p><h1 id="5-如何选择垃圾收集器"><a href="#5-如何选择垃圾收集器" class="headerlink" title="5. 如何选择垃圾收集器"></a>5. 如何选择垃圾收集器</h1><ol><li>优先调整堆的大小让服务器自己来选择</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li><li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li></ol><p>下图有连线的可以搭配使用，官方推荐使用G1，因为性能高</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/18D6A441DD6E4B6E8EAB4CD6085053E4.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-内存结构&quot;&gt;&lt;a href=&quot;#JVM-内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM 内存结构&quot;&gt;&lt;/a&gt;JVM 内存结构&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="虚拟机" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://brokge.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM-Java 虚拟机入门</title>
    <link href="https://brokge.github.io/2020/07/01/JVM-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%A5%E9%97%A8/"/>
    <id>https://brokge.github.io/2020/07/01/JVM-Java-虚拟机入门/</id>
    <published>2020-06-30T18:43:39.000Z</published>
    <updated>2020-08-21T04:56:47.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JVM-整体架构"><a href="#1-JVM-整体架构" class="headerlink" title="1. JVM 整体架构"></a>1. JVM 整体架构</h1><a id="more"></a><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>**JVM(虚拟机)**：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。常用的虚拟机有VMWare，Virtual Box，Java Virtual Machine</p><p><strong>Java虚拟机阵营</strong>：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、Azul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B6C4C346061744E49EFACF2AFD644161.jpg" alt="image"></p><h2 id="1-2-JVM-构成"><a href="#1-2-JVM-构成" class="headerlink" title="1.2 JVM 构成"></a>1.2 JVM 构成</h2><p>由三个主要的子系统</p><ol><li>类加载器子系统</li><li>运行时数据区（内存结构）</li><li>执行引擎</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8276252A099C4767B0824412B5AC790E.jpg" alt="image"></p><h2 id="1-3-Java-编译器"><a href="#1-3-Java-编译器" class="headerlink" title="1.3 Java 编译器"></a>1.3 Java 编译器</h2><p>Java  Compiler 运行时编译源码(.java)成字节码(.class)，由jre（Java Run Environment）运行。jre由java虚拟机（jvm）实现。Jvm 分析字节码，后解释并执行。</p><p>编译流程如下：<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/ACA7583FB3E9488D96C6D3E9B3D0C96B.jpg" alt="image"></p><h1 id="2-JVM类加载器"><a href="#2-JVM类加载器" class="headerlink" title="2. JVM类加载器"></a>2. JVM类加载器</h1><h2 id="2-1-类加载过程"><a href="#2-1-类加载过程" class="headerlink" title="2.1 类加载过程"></a>2.1 类加载过程</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B3DF1EEF61FD424C8D38E4737D702F62.jpg" alt="image"><br>类加载过程：类加载器将class文件加载到虚拟机的内存的过程。</p><p>步骤如下：</p><ol><li>加载：在硬盘上查找并通过IO读入字节码文件</li><li>连接：执行校验、准备、解析（可选）步骤</li><li>校验：校验字节码文件的正确性</li><li>准备：给类的静态变量分配内存，并赋予默认值</li><li>解析：类装载器装入类所引用的其他所有类</li><li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li></ol><h2 id="2-2-加载器种类"><a href="#2-2-加载器种类" class="headerlink" title="2.2 加载器种类"></a>2.2 加载器种类</h2><ul><li>启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等</li><li>扩展类加载器：负责加载JRE扩展目录ext中JAR类包</li><li>系统类加载器：负责加载ClassPath路径下的类包</li><li>用户自定义加载器：负责加载用户自定义路径下的类包</li></ul><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/99121BE919D44D7FA55CF8B574A4221C.jpg" alt="image"><br>示例代码可以输出加载器名称：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/92E7D1EEA0B5442288B29BB6D0AD315E.jpg" alt="image"></p><h2 id="2-3-类加载机制"><a href="#2-3-类加载机制" class="headerlink" title="2.3 类加载机制"></a>2.3 类加载机制</h2><p>类加载过程种，有两种机制来保证加载的安全与避免重复加载：</p><ol><li><strong>全盘负责委托机制</strong>：当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入。</li><li><strong>双亲委派机制</strong>：指先委托父类加载器寻找目标类，而不是自己先找，在父类找不到的情况下，才不得已在自己的路径中查找并载入目标类。</li></ol><p>上面两条机制可以简单总结就是：一人得道鸡犬升天 和 败家子模型。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F39CDE3D07DE4FCB9AB2A2EF3DAE5600.jpg" alt="image"></p><p><strong>双亲委派模式优势：</strong></p><p>沙箱安全机制：自己写的String.class类不会被加载，这样便可以防止核心API库被随意篡改<br>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再 加载一次。</p><h2 id="2-4-JVM加载jar包是否会将包里的所有类全部加载进内存？"><a href="#2-4-JVM加载jar包是否会将包里的所有类全部加载进内存？" class="headerlink" title="2.4 JVM加载jar包是否会将包里的所有类全部加载进内存？"></a>2.4 JVM加载jar包是否会将包里的所有类全部加载进内存？</h2><p>先说答案： JVM 对 class 文件是按需加载(运行期间动态加载)，非一次性加载。</p><p>下面通过一个例子来测试，注意：(启动需要加上参数：-verbose:class)</p><pre><code>public class TestDynamicLoad {    static {        System.out.println(&quot;*************static code************&quot;);    }    public static void main(String[] args){        new A();        System.out.println(&quot;*************load test************&quot;);        new B();    }}class A{    public A(){        System.out.println(&quot;*************initial A************&quot;);    }}class B{    public B(){        System.out.println(&quot;*************initial B************&quot;);    }}[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/jre/lib/rt.jar]*************static code************[Loaded com.study.jvm.A from file:/U/jvmtest/out/production/jvmtest/]*************initial A*************************load test************[Loaded com.study.jvm.B from file:/Us/jvmtest/out/production/jvmtest/]*************initial B************</code></pre><p>从上面输入日志可以发现，A 和 B 都是在加载之后开始输出构造函数内的日志。</p><h2 id="2-5-jvm-如何知道我们的类在何方？"><a href="#2-5-jvm-如何知道我们的类在何方？" class="headerlink" title="2.5 jvm 如何知道我们的类在何方？"></a>2.5 jvm 如何知道我们的类在何方？</h2><p>我们的 class 信息存放在不同的地方，如不同文件夹里面的jar，项目bin目录，target目录等，jvm 怎么知道都需要加载哪些路径呢？</p><p>通过查看 sun.misc.Launcher.AppClassLoader 源码可以发现，是通过读取<code> java.class.path</code> 配置，通过这个指定去特定配置目录去加载。</p><p>通过 <code>jps</code> 和 <code>jcmd</code> 两个命令来验证</p><pre class="line-numbers language-bash"><code class="language-bash">jpsjcmd pid <span class="token function">help</span>jcmd pid VM.system_properties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/6BACF4F6B07B4C518CE7820CDBAD22A0.jpg" alt="image"></p><h1 id="3-JVM-内存结构"><a href="#3-JVM-内存结构" class="headerlink" title="3. JVM 内存结构"></a>3. JVM 内存结构</h1><h2 id="3-1-内存结构结构图"><a href="#3-1-内存结构结构图" class="headerlink" title="3.1 内存结构结构图"></a>3.1 内存结构结构图</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/50969016BB3446248562F165B43F902F.jpg" alt="image"></p><ol><li><p>本地方法栈(线程私有)：登记native方法，在Execution Engine执行时加载本地方法库</p></li><li><p>程序计数器（线程私有）：就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p></li><li><p>Java栈（线程私有）：Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）==不存在垃圾回收问题==，只要线程一结束该栈就释放，生命周期和线程一致。</p></li><li><p>方法区(线程共享)：类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p></li><li><p>堆(线程共享)：虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆</p></li></ol><p>JVM 对该区域规范了两种异常：</p><ol><li>针对与栈：线程请求的栈深度大于虚拟机栈所允许的深度，将抛出 StackOverFlowError 异常</li><li>针对堆：若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError，通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度<h2 id="3-2-Java-栈"><a href="#3-2-Java-栈" class="headerlink" title="3.2 Java 栈"></a>3.2 Java 栈</h2></li></ol><p>每个线程都有自己私有的栈，栈内部是由n个栈帧（函数/方法）组成。<br>栈帧（函数/方法）内部又包含：局部变量表、操作数栈、动态链接、返回地址。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5B247C51135C4A00B2B9A3F77D109081.jpg" alt="image"></p><h2 id="3-3-栈-堆-方法区的交互关系"><a href="#3-3-栈-堆-方法区的交互关系" class="headerlink" title="3.3 栈+堆+方法区的交互关系"></a>3.3 栈+堆+方法区的交互关系</h2><p>HotSpot 是使用==指针==的方式来访问对象<br>Java堆中会存放访问==类元数据==的地址<br>reference存储的就直接是对象的地址</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D2B31A961A53482A9FB921AA929285EA.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B803B954C8254EF18A95473BF80D015A.jpg" alt="image"></p><h2 id="3-4-堆"><a href="#3-4-堆" class="headerlink" title="3.4 堆"></a>3.4 堆</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/84A35B9748EC46758F35BA070CBA4564.jpg" alt="image"></p><h3 id="3-4-1-Young-Generation-新生区"><a href="#3-4-1-Young-Generation-新生区" class="headerlink" title="3.4.1 Young Generation 新生区"></a>3.4.1 Young Generation 新生区</h3><p>类诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生区分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。</p><p>幸存区有两个： 0(From)区（Survivor 0 space）和1(To)区（Survivor 1 space）。</p><p>当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。<br>若幸存 0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？则 移动到 老年代。</p><h3 id="3-4-2-old-Generation-老年区"><a href="#3-4-2-old-Generation-老年区" class="headerlink" title="3.4.2 old Generation 老年区"></a>3.4.2 old Generation 老年区</h3><p>新生区经过多次GC仍然存活的对象移动到老年区。<br>若老年区也满了，那么这个时候将产生MajorGC（FullGC），进行老年区的内存清理。若老年区执行了Full GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常“OutOfMemoryError”</p><h3 id="3-4-3-MetaDataSpace-元数据区"><a href="#3-4-3-MetaDataSpace-元数据区" class="headerlink" title="3.4.3 MetaDataSpace 元数据区"></a>3.4.3 MetaDataSpace 元数据区</h3><p>元数据区取代了永久代(jdk1.8以前)，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存，永久代在虚拟机中，永久代逻辑结构上属于堆，但是物理上不属于堆，堆大小=新生代+老年代。元数据区也有可能发生OutOfMemory异常。</p><table><thead><tr><th>JAVA 版本</th><th>是否有永久代</th></tr></thead><tbody><tr><td>Jdk1.6及之前</td><td>有永久代, 常量池在方法区</td></tr><tr><td>Jdk1.7</td><td>有永久代，但已经逐步“去永久代”，常量池在堆</td></tr><tr><td>Jdk1.8及之后</td><td>无永久代，常量池在元空间.</td></tr></tbody></table><p>元数据区的动态扩展，默认 –XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。</p><p><strong>为什么jdk1.8用元数据区取代了永久代？</strong></p><p>官方解释：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</p><h1 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a>JVM执行引擎</h1><p>执行引擎：读取运行时数据区的Java字节码并逐个执行</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BE6F2D2F39AF4F80A6D80BA8807A8A67.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JVM-整体架构&quot;&gt;&lt;a href=&quot;#1-JVM-整体架构&quot; class=&quot;headerlink&quot; title=&quot;1. JVM 整体架构&quot;&gt;&lt;/a&gt;1. JVM 整体架构&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="虚拟机" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://brokge.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 动态页面缓存方式实现</title>
    <link href="https://brokge.github.io/2020/06/25/Nginx-%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://brokge.github.io/2020/06/25/Nginx-动态页面缓存方式实现/</id>
    <published>2020-06-24T18:40:22.000Z</published>
    <updated>2020-08-21T05:05:00.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="具体实现步骤："><a href="#具体实现步骤：" class="headerlink" title="具体实现步骤："></a>具体实现步骤：</h2><p>依托于 OpenResty 框架实现</p><a id="more"></a><h3 id="一、Openresty安装"><a href="#一、Openresty安装" class="headerlink" title="一、Openresty安装"></a>一、Openresty安装</h3><pre class="line-numbers language-sh"><code class="language-sh">mkdir ‐p /usr/servers cd  /usr/servers/yum install‐y readline‐devel pcre‐devel openssl‐devel gccwget http://openresty.org/download/ngx_openresty‐1.7.7.2.tar.gz tar ‐xzvf ngx_openresty‐1.7.7.2.tar.gzcd  /usr/servers/ngx_openresty‐1.7.7.2/cd  bundle/LuaJIT‐2.1‐20150120/ make clean && make&& make install ln ‐sf luajit‐2.1.0‐alpha /usr/local/bin/luajitcd  /usr/servers/ngx_openresty‐1.7.7.2/bundle wget  https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz tar‐xvf 2.3.tar.gzcd  bundle wget  https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz tar  ‐xvf  v0.3.0.tar.gzcd  /usr/servers/ngx_openresty‐1.7.7.2 ./configure‐‐prefix=/usr/servers‐‐with‐http_realip_module‐‐with‐pcre‐‐with‐luajit‐‐add‐module=./bundle/ngx_cache_purge‐2.3/ ‐‐add‐module=./bundle/nginx_upstream_check_module‐0.3.0/ ‐j2 24 make&&makeinstallcd /usr/servers/ll/usr/servers/luajit/usr/servers/lualib/usr/servers/nginx/usr/servers/nginx/sbin/nginx ‐V##启动nginx: /usr/servers/nginx/sbin/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、-Nginx-lua-开发-hello-world"><a href="#二、-Nginx-lua-开发-hello-world" class="headerlink" title="二、 Nginx + lua 开发 hello world"></a>二、 Nginx + lua 开发 hello world</h3><pre class="line-numbers language-sh"><code class="language-sh">cd /usr/servers/nginx/confvim  lua.conf server{    listen 80;    server_name _;    location /lua { default_type 'text/html';    content_by_lua 'ngx.say("helloworld")';    } }vim  nginx.conf##在http部分引入lua包lua_package_path"/usr/servers/lualib/?.lua;;";lua_package_cpath"/usr/servers/lualib/?.so;;"; include lua.conf;../sbin/nginx‐sreload #访问:http://192.168.0.60/lua<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、Nginx-lua开发的流量分发逻辑，可以根据商品id-进行-hash-然后取模分发。"><a href="#三、Nginx-lua开发的流量分发逻辑，可以根据商品id-进行-hash-然后取模分发。" class="headerlink" title="三、Nginx+lua开发的流量分发逻辑，可以根据商品id 进行 hash 然后取模分发。"></a>三、Nginx+lua开发的流量分发逻辑，可以根据商品id 进行 hash 然后取模分发。</h3><pre class="line-numbers language-sh"><code class="language-sh">#流量分发的nginx，会发送http请求到后端的应用层nginx上去，所以要先引入lua http lib包 cd /usr/servers/lualib/resty wget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http_headers.lua wget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http.luacd  /usr/servers/nginx/conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lua-distribution.lua</p><pre class="line-numbers language-SH"><code class="language-SH">vim lua‐distribution.lua# lua-distribution.lualocal uri_args=ngx.req.get_uri_args()local productId=uri_args["productId"] local host={"192.168.0.61","192.168.0.62"}local hash=ngx.crc32_long(productId) hash = (hash%2)+1backend="http://"..host[hash]local method = uri_args["method"] local requestBody="/"..method.."?productId="..productIdlocal http=require("resty.http") localhttpc=http.new()local resp,err=httpc:request_uri(backend,{      method = "GET", path = requestBody, keepalive=false})if not resp then    ngx.say("request error :", err)    returnend ngx.say(resp.body) httpc:close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开 lua.conf</p><pre class="line-numbers language-sh"><code class="language-sh">vim lua.conf 在server部分加入 location/product{    default_type 'text/html';    content_by_lua_file /usr/servers/nginx/conf/lua‐distribution.lua; }../sbin/nginx‐sreload#访问:http://192.168.0.60/lua?productId=XX 会根据productId将请求分发到不同的应用层nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、Nginx-lua开发应用层页面缓存与模板动态渲染逻辑"><a href="#四、Nginx-lua开发应用层页面缓存与模板动态渲染逻辑" class="headerlink" title="四、Nginx+lua开发应用层页面缓存与模板动态渲染逻辑"></a>四、Nginx+lua开发应用层页面缓存与模板动态渲染逻辑</h3><pre class="line-numbers language-sh"><code class="language-sh">##应用层需要访问服务http接口，所以也需要引入lua http lib包cd /usr/servers/lualib/resty wget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http_headers.luawget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http.lua##应用层还需要用到模板动态渲染技术，所以还需要引入lua的template包cd  /usr/servers/lualib/resty wget https://raw.githubusercontent.com/bungle/lua‐resty‐template/master/lib/resty/template.lua mkdir/usr/servers/lualib/resty/htmlcd /usr/servers/lualib/resty/html wget https://raw.githubusercontent.com/bungle/lua‐resty‐template/master/lib/resty/template/html.luacd /usr/servers/templates vim product.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>增加html静态模板 </li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http‐equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content‐Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html; charset<span class="token punctuation">=</span>utf‐8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>商品id: {* productId *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品名称: {* productName *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品原价: {* productPrice *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品现价: {* productNowPrice *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品库存: {* productStock *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品描述: {* productHTML *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">cd  /usr/servers/nginx/confvim lua.conf## 在server部分加入set $template_location"/templates";set $template_root"/usr/servers/templates";## 增加ngxin缓存配置vim lua.conf## 在最前面加入lua_shared_dictmy_cache  128m;## 增加商品详情页渲染的lua脚本vim lua.conf## 在server部分增加location/product{  default_type 'text/html';  content_by_lua_file /usr/servers/nginx/conf/product.lua;}## 最后，编写商品详情页渲染lua脚本vim product.lualocal uri_args=ngx.req.get_uri_args()local productId=uri_args["productId"]local cache_ngx=ngx.shared.my_cachelocal productCacheKey="product_info_"..productIdlocal productCache=cache_ngx:get(productCacheKey)if productCache == "" or productCache == nil then   local http=require("resty.http")   local httpc=http.new()   local resp,err=httpc:request_uri("http://192.168.0.175:8080",{   method="GET", path="/shop‐web/product/cache/"..productId,keepalive=false   })   productCache = resp.body   local expireTime = math.random(600,1200)   cache_ngx:set(productCacheKey,productCache,expireTime)endngx.log(ngx.ERR,"json‐‐‐‐‐‐‐‐2",productCache)local cjson=require("cjson")local productCacheJSON=cjson.decode(productCache)local context={    productId=productCacheJSON.id,    productName=productCacheJSON.name,    productPrice=productCacheJSON.price,    productNowPrice=productCacheJSON.nowPrice,    productStock=productCacheJSON.stock,    productHTML=productCacheJSON.productHTML}local template=require("resty.template")template.render("product.html",context)../sbin/nginx‐sreload ## 访问:http://192.168.0.60/product?productId=XX&method=product## 会根据productId将请求分发到不同的应用层nginx获取相应的商品详情页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;具体实现步骤：&quot;&gt;&lt;a href=&quot;#具体实现步骤：&quot; class=&quot;headerlink&quot; title=&quot;具体实现步骤：&quot;&gt;&lt;/a&gt;具体实现步骤：&lt;/h2&gt;&lt;p&gt;依托于 OpenResty 框架实现&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>网络协议梳理</title>
    <link href="https://brokge.github.io/2020/06/06/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/"/>
    <id>https://brokge.github.io/2020/06/06/网络协议梳理/</id>
    <published>2020-06-06T09:35:01.000Z</published>
    <updated>2020-07-24T14:12:49.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、OSI-网络七层模型"><a href="#一、OSI-网络七层模型" class="headerlink" title="一、OSI 网络七层模型"></a>一、OSI 网络七层模型</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0A162883B11F412DBAF35E4FDB31D054.jpg" alt="image"></p><p><strong>应用层</strong>：<br>决定向用户提供应用服务时通信的活动，此处的活动包括比如待传送数据的处理（应用内部生成特定格式的数据，后对数据进行标准协议的格式的编码）。</p><p><strong>表示层</strong><br>负责数据格式转换、数据加密与解密、压缩解压缩等</p><p><strong>会话层</strong><br>负责建立、管理和终止进程之间的会话和数据交换。</p><p><strong>传输层：</strong><br>对上层应用层，提供处于网络连接种的两台计算机之间的数据传输（TCP、UDP）。</p><p><strong>网络层：</strong><br>用来处理网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。<br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><p><strong>链路层</strong>（又名数据链路层，网络接口层）：<br>用来管理／操作连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡、光纤等物理可见部分。</p><a id="more"></a><h2 id="二、-OSI-七层模型对应的协议"><a href="#二、-OSI-七层模型对应的协议" class="headerlink" title="二、 OSI 七层模型对应的协议"></a>二、 OSI 七层模型对应的协议</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/2B803AB503B144418B043A283CC22B3A.jpg" alt="image"> </p><h2 id="TCP-UDP-网络请求过程"><a href="#TCP-UDP-网络请求过程" class="headerlink" title="TCP/UDP 网络请求过程"></a>TCP/UDP 网络请求过程</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/451F2587D1F4416198ED3CEACAB3052B.jpg" alt="image"> </p><p>发送端：在层与层之间传输数据时，每一层都会被打上当前层所属的头部信息。</p><p>接收端：在层与层之间传输数据时，每一层都会取消当前层所属的头部信息。</p><h3 id="TCP-头部信息"><a href="#TCP-头部信息" class="headerlink" title="TCP 头部信息"></a>TCP 头部信息</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8890607AEBBB48C286631BC8087B2941.jpg" alt="image"> </p><h3 id="TCP-可靠性保证"><a href="#TCP-可靠性保证" class="headerlink" title="TCP 可靠性保证"></a>TCP 可靠性保证</h3><ul><li><p>三次握手和四次挥手机制</p><blockquote><p>在建立连接的时候，通过3 次握手机制。在结束连接的时候通过4次挥手。这样保证连接的可靠性。</p></blockquote></li><li><p>校验和</p><blockquote><p>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p></blockquote></li><li><p>确认应答+序列号</p><blockquote><p>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p></blockquote></li><li><p>超时重传</p><blockquote><p>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p><p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p><p>超时以500ms（0.5秒）为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2<em>500ms的时间后，再次重传。等待4</em>500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。</p></blockquote></li><li><p>流量控制</p><blockquote><p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。接收方有即时窗口（滑动窗口），随ACK报文发送。</p></blockquote></li><li><p>拥塞控制</p><blockquote><p>而且 TCP 引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。发送过程中当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的及时窗口。</p></blockquote></li></ul><h3 id="TCP-握手和挥手机制"><a href="#TCP-握手和挥手机制" class="headerlink" title="TCP 握手和挥手机制"></a>TCP 握手和挥手机制</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3467CABB79EC412A955A981B18752DE3.jpg" alt="image"> </p><h2 id="三、-浏览器中输入一个域名地址-发生了什么？"><a href="#三、-浏览器中输入一个域名地址-发生了什么？" class="headerlink" title="三、 浏览器中输入一个域名地址 发生了什么？"></a>三、 浏览器中输入一个域名地址 发生了什么？</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/9FF77B5A7DF74377A11A7049C637C1C6.jpg" alt="image"> </p><pre class="line-numbers language-shell"><code class="language-shell">$ nslookup www.baidu.comServer:        192.168.1.1Address:    192.168.1.1#53Non-authoritative answer:www.baidu.com    canonical name = www.a.shifen.com.Name:    www.a.shifen.comAddress: 36.152.44.95Name:    www.a.shifen.comAddress: 36.152.44.96<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、-WebSocket-和-HTTP-Socket-区别"><a href="#四、-WebSocket-和-HTTP-Socket-区别" class="headerlink" title="四、 WebSocket 和 HTTP, Socket 区别"></a>四、 WebSocket 和 HTTP, Socket 区别</h2><p>WebSocket 同 HTTP 一样也是应用层的协议,但是它是一种双向通信协议,是建立在TCP之上的。</p><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol><li><p>浏览器、服务器通过三次握手建立TCP连接 。这是通信的基础,若失败后续都不执行。</p></li><li><p>TCP连接成功后,浏览器通过HTTP协议向服务器传送WebSocket 支持的版本号等信息。(开始前的HTTP握手）</p></li><li><p>服务器收到客户端的握手请求后,同样采用HTTP协议回馈数据。</p></li><li><p>当收到了连接成功的消息后,通过TCP通道进行传输通信。</p></li></ol><h3 id="WebSocket与HTTP的相同点和不同点"><a href="#WebSocket与HTTP的相同点和不同点" class="headerlink" title="WebSocket与HTTP的相同点和不同点"></a>WebSocket与HTTP的相同点和不同点</h3><ul><li>相同点</li></ul><ol><li>都是一样基于TCP的,都是可靠性传输协议。</li><li>都是应用层协议</li></ol><ul><li>不同点</li></ul><ol><li>WebSocket是双向通信协议,模拟Socket协议,可以双向发送或接受信息,HTTP是单向的。</li><li>WebSocket是需要握手进行建立连接的 ，WebSocket在建立握手时,数据是通过HTTP传输的。但是建立之后,在真正传输时候是不需要HTTP协议的。</li></ol><h3 id="WebSocket-与-Socket的关系"><a href="#WebSocket-与-Socket的关系" class="headerlink" title="WebSocket 与 Socket的关系"></a>WebSocket 与 Socket的关系</h3><p>Socket 其实并不是一个协议,而是为了方便使用 TCP 或 UDP 而抽象出来的层,是位于应用层和传输控制层之间的—组接口。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5F3C32A779AF4085B1EFA79585EFA7F0.jpg" alt="image"> </p><blockquote><p>Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层,它是一组接口。在设计模式中, Socket其实就是一个门面模式,它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面,对用户来说,一组简单的接口就是全部,让 Socket去组织数据,以符合指定的协议。</p></blockquote><p>当两台主机通信时,必须通过 Socket 连接, Socket则利用 TCP/IP 协议建立 TCP 连接。TCP连接则更依靠于底层的 IP 协议, IP 协议的连接则依赖于链路层等更低层次。</p><p>WebSocket 则是一个典型的应用层协议。</p><ul><li>区别</li></ul><p>Socket是传输控制层协议, WebSocket是应用层协议。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>图解 http</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、OSI-网络七层模型&quot;&gt;&lt;a href=&quot;#一、OSI-网络七层模型&quot; class=&quot;headerlink&quot; title=&quot;一、OSI 网络七层模型&quot;&gt;&lt;/a&gt;一、OSI 网络七层模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/brokge/drawio/img/0A162883B11F412DBAF35E4FDB31D054.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：&lt;br&gt;决定向用户提供应用服务时通信的活动，此处的活动包括比如待传送数据的处理（应用内部生成特定格式的数据，后对数据进行标准协议的格式的编码）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示层&lt;/strong&gt;&lt;br&gt;负责数据格式转换、数据加密与解密、压缩解压缩等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话层&lt;/strong&gt;&lt;br&gt;负责建立、管理和终止进程之间的会话和数据交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层：&lt;/strong&gt;&lt;br&gt;对上层应用层，提供处于网络连接种的两台计算机之间的数据传输（TCP、UDP）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络层：&lt;/strong&gt;&lt;br&gt;用来处理网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。&lt;br&gt;与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路层&lt;/strong&gt;（又名数据链路层，网络接口层）：&lt;br&gt;用来管理／操作连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡、光纤等物理可见部分。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://brokge.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络编程" scheme="https://brokge.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程如何确定线程个数</title>
    <link href="https://brokge.github.io/2020/06/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E4%B8%AA%E6%95%B0/"/>
    <id>https://brokge.github.io/2020/06/05/多线程编程如何确定线程个数/</id>
    <published>2020-06-05T13:08:38.000Z</published>
    <updated>2020-08-21T04:44:45.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-多线程编程如何确定线程个数？"><a href="#1-多线程编程如何确定线程个数？" class="headerlink" title="1. 多线程编程如何确定线程个数？"></a>1. 多线程编程如何确定线程个数？</h1><p>在具体的优化场景中，可以分为以下两种场景着手。</p><ol><li><p>CPU 密集型程序</p></li><li><p>I/O 密集型程序</p><a id="more"></a></li></ol><h2 id="1-1-CPU-密集型"><a href="#1-1-CPU-密集型" class="headerlink" title="1.1 CPU 密集型"></a>1.1 CPU 密集型</h2><blockquote><ol><li>单核CPU处理 CPU 密集型程序，这种情况并不太适合使用多线程。</li><li>如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率</li></ol></blockquote><p>线程数量 = CPU 核数（逻辑） 就可以了，但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1, 这是因为：计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p><h2 id="1-2-I-O密集型"><a href="#1-2-I-O密集型" class="headerlink" title="1.2 I/O密集型"></a>1.2 I/O密集型</h2><blockquote><p>与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分</p></blockquote><p>线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程。</p><p>最佳线程数 = CPU核心数 *  (1/CPU利用率) =  CPU核心数 * (1 + (I/O耗时/CPU耗时))</p><p>假如几乎全是 I/O耗时，所以纯理论你就可以说是 2N（N=CPU核数），当然也有说 2N + 1的。</p><h2 id="1-3-问题"><a href="#1-3-问题" class="headerlink" title="1.3 问题"></a>1.3 问题</h2><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为 20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>答案：<br>因为 一个线程处理一个 Transaction 时间是4秒，那1秒 处理 0.25 个 Transaction；</p><p>所以 ： 20 / 0.25 = 80（个）。</p><p>但是，这是因为没有考虑到CPU数目。一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销。</p><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><blockquote><p>那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？</p></blockquote><p>答案： 因为 1 s = 1000ms  完成一个完整的db 操作等于 100+5  =105 ms。 那一个线程一秒可以处理的任务数是  1000/105。168 个线程 就是 168 * 1000/105 = 1600（QPS）。</p><p>如果 db 的QPS 上限是 1000 ，则168*1000/1600 = 105 个。</p><h1 id="1-4-增加-CPU-核数一定能解决问题吗"><a href="#1-4-增加-CPU-核数一定能解决问题吗" class="headerlink" title="1.4 增加 CPU 核数一定能解决问题吗"></a>1.4 增加 CPU 核数一定能解决问题吗</h1><p>即便我算出了理论线程数，但实际CPU核数不够，会带来线程上下文切换的开销，所以下一步就需要增加 CPU 核数，那我们盲目的增加 CPU 核数就一定能解决问题吗？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/21A8D6F6DF074BAB8A79192C8190C38E.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/DC07610E6E0E4003B7B1F29B8219F936.jpg" alt="image"></p><p>假如我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。</p><p>所谓串行率： 临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行率</p><p>因为临界区的大小往往就是瓶颈问题的所在，所以尽可能的最小化临界区范围</p><h1 id="2-动态线程池"><a href="#2-动态线程池" class="headerlink" title="2. 动态线程池"></a>2. 动态线程池</h1><p>所谓动态线程池，是动态设置线程池的核心线程数、最大线程数、有界队列。</p><h2 id="2-1-动态设置核心线程数-corePoolSize-和-MaxmumPoolSize"><a href="#2-1-动态设置核心线程数-corePoolSize-和-MaxmumPoolSize" class="headerlink" title="2.1 动态设置核心线程数 corePoolSize 和 MaxmumPoolSize"></a>2.1 动态设置核心线程数 corePoolSize 和 MaxmumPoolSize</h2><pre><code>ThreadPoolExecutor.setCorePoolSize();</code></pre><p>并且 Spring 的 ThreadPoolTaskExecutor类 （就是对JDK ThreadPoolExecutor 的一层包装，可以理解为装饰者模式）也提供了的 setCorePoolSize ；</p><pre><code>ThreadPoolExecutor.setMaxmumPoolSize();</code></pre><h3 id="调整的时候注意点："><a href="#调整的时候注意点：" class="headerlink" title="调整的时候注意点："></a>调整的时候注意点：</h3><h4 id="1-调整核心线程数之后无效的情况"><a href="#1-调整核心线程数之后无效的情况" class="headerlink" title="1. 调整核心线程数之后无效的情况"></a>1. 调整核心线程数之后无效的情况</h4><p>这是因为，核心线程数大于最大线程数，在操作的过程中，有个增减操作，具体流程如下：</p><ol><li>创建新的工作线程 worker，然后工作线程数进行加一操作。</li><li>运行创建的工作线程 worker，开始获取任务 task。</li><li>工作线程数量大于最大线程数，对工作线程数进行减一操作。</li><li>返回 null，即没有获取到 task。</li><li>清理该任务，流程结束。</li></ol><p>针对这个情况，应该 setCorePoolSize和 setMaxmumPoolSize 一起调用。</p><h4 id="2-如果调整之后把活动线程数设置的值太大了，岂不是业务低峰期我们还需要人工把值调的小一点？"><a href="#2-如果调整之后把活动线程数设置的值太大了，岂不是业务低峰期我们还需要人工把值调的小一点？" class="headerlink" title="2. 如果调整之后把活动线程数设置的值太大了，岂不是业务低峰期我们还需要人工把值调的小一点？"></a>2. 如果调整之后把活动线程数设置的值太大了，岂不是业务低峰期我们还需要人工把值调的小一点？</h4><p>当 allowCoreThreadTimeOut 参数设置为 true 的时候，核心线程在空闲了 keepAliveTime 的时间后也会被回收的，相当于线程池自动给你动态修改了。</p><h4 id="3-线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？"><a href="#3-线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？" class="headerlink" title="3. 线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？"></a>3. 线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？</h4><p>线程池被创建后如果没有任务过来，里面是不会有线程的。如果需要预热的话可以调用下面的两个方法来进行预热：</p><pre><code>prestartAllCoreThreads();prestartCoreThread();</code></pre><h4 id="4-核心线程数会被回收吗？需要什么设置？"><a href="#4-核心线程数会被回收吗？需要什么设置？" class="headerlink" title="4. 核心线程数会被回收吗？需要什么设置？"></a>4. 核心线程数会被回收吗？需要什么设置？</h4><p>核心线程数默认是不会被回收的，如果需要回收核心线程数，需要调用下面的方法：</p><pre><code>allowCoreThreadTimeOut()// 该值默认为 false。</code></pre><p>allowCoreThreadTimeOut 默认为false，设置true，会在过期时间之后回收 核心线程。</p><h2 id="2-2-动态指定队列长度"><a href="#2-2-动态指定队列长度" class="headerlink" title="2.2 动态指定队列长度"></a>2.2 动态指定队列长度</h2><p>首先通过源码api，来看没有提供修改队列长度的方法。这是由于 ThreadPoolExecutor  内部的 capacity 变量被 final修饰。</p><p>由于这个因素，可以采用自定义队列的方式</p><p>可以把 LinkedBlockingQueue 粘贴一份出来，修改个名字，然后把 Capacity 参数的 final 修饰符去掉，并提供其对应的 get/set 方法。</p><p>然后在程序里面把原来的队列换掉新创建的自定义队列，达到动态设置队列长度的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-多线程编程如何确定线程个数？&quot;&gt;&lt;a href=&quot;#1-多线程编程如何确定线程个数？&quot; class=&quot;headerlink&quot; title=&quot;1. 多线程编程如何确定线程个数？&quot;&gt;&lt;/a&gt;1. 多线程编程如何确定线程个数？&lt;/h1&gt;&lt;p&gt;在具体的优化场景中，可以分为以下两种场景着手。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CPU 密集型程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I/O 密集型程序&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="并发编程" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="优化" scheme="https://brokge.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo详解</title>
    <link href="https://brokge.github.io/2020/06/02/Dubbo%E8%AF%A6%E8%A7%A3/"/>
    <id>https://brokge.github.io/2020/06/02/Dubbo详解/</id>
    <published>2020-06-02T08:28:45.000Z</published>
    <updated>2020-08-21T04:58:28.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/64A03BA7F21B4BB29F4ABC5F11140870.jpg" alt="image"></p><h4 id="分布式架构的-有-3-种解决方案"><a href="#分布式架构的-有-3-种解决方案" class="headerlink" title="分布式架构的 有 3 种解决方案"></a><strong>分布式架构的 有 3 种解决方案</strong></h4><ol><li>基于反向代理的中心化架构</li><li>嵌入应用内部的去中心化架构</li><li>基于独立代理进程的Service Mesh架构<a id="more"></a></li></ol><h4 id="基于反向代理的集中式分布式架构"><a href="#基于反向代理的集中式分布式架构" class="headerlink" title="基于反向代理的集中式分布式架构"></a>基于反向代理的集中式分布式架构</h4><p>这是最简单和传统做法，在服务消费者和生产者之间，代理作为独立一层集中部署，由独立团队(一般是运维或框架)负责治理和运维。常用的集中式代理有硬件负载均衡器(如F5)，或者软件负载均衡器(如Nginx)，这种软硬结合两层代理也是业内常见做法，兼顾配置的灵活性(Nginx比F5易于配置)。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/29E919D8DA684D4E99671F5A16013855.jpg" alt="image"></p><p><strong>Http+Nginx 方案总结</strong></p><p><strong>优点：</strong> 简单快速、几乎没有学习成本</p><p><strong>适用场景：</strong> 轻量级分布式系统、局部分布式架构。</p><p><strong>瓶颈：</strong> Nginx中心负载、Http传输、JSON序列化、开发效率、运维效率。</p><h3 id="嵌入应用内部的去中心化架构"><a href="#嵌入应用内部的去中心化架构" class="headerlink" title="嵌入应用内部的去中心化架构"></a>嵌入应用内部的去中心化架构</h3><p>这是很多互联网公司比较流行的一种做法，代理(包括服务发现和负载均衡逻辑)以客户库的形式嵌入在应用程序中。这种模式一般需要独立的服务注册中心组件配合，服务启动时自动注册到注册中心并定期报心跳，客户端代理则发现服务并做负载均衡。我们所熟悉的 duboo 和spring cloud Eureka +Ribbon/‘rɪbən/ 都是这种方式实现。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/91E7A4D0836A49B395A817DDC2CF2376.jpg" alt="image"><br>相比第一代架构它有以下特点几点：</p><ul><li>去中心化，客户端直连服务端</li><li>动态注册和发现服务</li><li>高效稳定的网络传输</li><li>高效可容错的序列化</li></ul><h3 id="基于独立代理进程的架构-Service-Mesh"><a href="#基于独立代理进程的架构-Service-Mesh" class="headerlink" title="基于独立代理进程的架构(Service Mesh)"></a>基于独立代理进程的架构(Service Mesh)</h3><p>这种做法是上面两种模式的一个折中，代理既不是独立集中部署，也不嵌入在客户应用程序中，而是作为独立进程部署在每一个主机上，一个主机上的多个消费者应用可以共用这个代理，实现服务发现和负载均衡，如下图所示。这个模式一般也需要独立的服务注册中心组件配合，作用同第二代架构。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E7DE6B068DC74C7D8AE0808F46AB24AF.jpg" alt="image"></p><h4 id="三种架构的比较"><a href="#三种架构的比较" class="headerlink" title="三种架构的比较"></a>三种架构的比较</h4><table><thead><tr><th align="left"><strong>模式</strong></th><th align="left"><strong>优点</strong></th><th align="left"><strong>缺点</strong></th><th align="left"><strong>适应场景</strong></th><th align="left"><strong>案例</strong></th></tr></thead><tbody><tr><td align="left">集中式负载架构</td><td align="left">简单  集中式治理  与语言无关</td><td align="left">配置维护成本高  多了一层IO  单点问题</td><td align="left">大部分公司都适用，对运维有要求</td><td align="left">亿贝、携程、早期互联网公司</td></tr><tr><td align="left">客户端嵌入式架构</td><td align="left">无单点  性能更好</td><td align="left">客户端复杂  语言栈要求</td><td align="left">中大规模公司、语言栈统一</td><td align="left">Dubbo    、  Twitter finagle、  Spring Cloud Ribbon</td></tr><tr><td align="left">独立进程代理架构</td><td align="left">无单点  性能更好  与语言无关</td><td align="left">运维部署复杂  开发联调复杂</td><td align="left">中大规模公司  对运维有要求</td><td align="left">Smart Stack  Service Mesh</td></tr></tbody></table><h2 id="二、什么是-Dubbo"><a href="#二、什么是-Dubbo" class="headerlink" title="二、什么是 Dubbo"></a>二、什么是 Dubbo</h2><p>dubbo 阿里开源的一个 SOA（面向服务的架构） 服务治理框架，从目前来看把它称作是一个RPC远程调用框架更为贴切。单从RPC框架来说，功能较完善，支持多种传输和序列化方案。所以想必大家已经知道他的核心功能了：就是远程调用。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/81A705F26C0346EA871AB8936296BFE1.jpg" alt="image"></p><p><strong>流程说明：</strong></p><ol><li>Provider(提供者)绑定指定端口并启动服务</li><li>指供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储</li><li>Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心</li><li>注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。</li><li>Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。</li><li>Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer</li></ol><p><strong>这么设计的意义：</strong></p><ol><li>Consumer 与Provider 解偶，双方都可以横向增减节点数。</li><li>注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台</li><li>去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li></ol><p><strong>Dubbo 设计层级</strong></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/60BD217B1ED345898A01578CF19291CB.jpg" alt="image"></p><ul><li>config <strong>配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li>proxy <strong>服务代理层</strong>：服务接口透明代理，生成动态代理 扩展接口为 ProxyFactory</li><li>registry <strong>注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li><li>cluster <strong>路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li><li>monitor <strong>监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li><li>protocol <strong>远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li><li>exchange <strong>信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li><li>transport <strong>网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li><li>serialize <strong>数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li></ul><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7DC769031DD64DDABC42BDFBC7384599.jpg" alt="image"></p><h3 id="Dubbo-SPI-机制"><a href="#Dubbo-SPI-机制" class="headerlink" title="Dubbo SPI 机制"></a>Dubbo SPI 机制</h3><p>Java SPI 的具体约定为:当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类java.util.ServiceLoader</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0723FDE7587148BAB47925D8471D652D.jpg" alt="image"></p><p>META-INF/services/xxx.dubbo.server.UserService 中的值：</p><pre><code>xxx.dubbo.server.impl.UserServiceImpl2</code></pre><p>装载获取SPI实现类：</p><pre><code>public static void main(String[] args) {    Iterator&lt;UserService&gt; services = ServiceLoader.load(UserService.class).iterator();    UserService service = null;    while (services.hasNext()) {        service = services.next();    }    System.out.println(service.getUser(111));}</code></pre><p>Dubbo SPI 在JAVA自带的SPI基础上加入了扩展点的功能，即每个实现类都会对应至一个扩展点名称，其目的是 应用可基于此名称进行相应的装配。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B158D3A511A54EE0819951B33A188F0D.jpg" alt="image"><br>dubbo spi  文件内容：</p><pre><code>luban=xxx.dubbo.server.LubanFilter</code></pre><p>装配自定义Filter</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/17D1822AA2FB4427A92566F2E64917B7.jpg" alt="image"></p><p>想了解更详细信息：<br><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html">官方文档</a></p><h2 id="三、Dubbo注册中心详解"><a href="#三、Dubbo注册中心详解" class="headerlink" title="三、Dubbo注册中心详解"></a>三、Dubbo注册中心详解</h2><h3 id="注册中心的作用"><a href="#注册中心的作用" class="headerlink" title="注册中心的作用"></a>注册中心的作用</h3><p>为了到达服务集群动态扩容的目的，注册中心存储了服务的地址信息与可用状态信息，并实时推送给订阅了相关服务的客户端。<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8638BBF57BF946769ABFCE0DAF896809.jpg" alt="image"></p><p><strong>一个完整的注册中心需要实现以下功能：</strong></p><ol><li>接收服务端的注册与客户端的引用，即将引用与消费建立关联，并支持多对多。</li><li>当服务非正常关闭时能即时清除其状态</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>注册中心本身的集群 。</li></ol><h3 id="Dubbo所支持的注册中心"><a href="#Dubbo所支持的注册中心" class="headerlink" title="Dubbo所支持的注册中心"></a>Dubbo所支持的注册中心</h3><ol><li><strong>Multicast 注册中心</strong><ol><li>基于组网广播技术，只能用在局域网内，一般用于简单的测试服务</li></ol></li><li><strong>Zookeeper 注册中心(**</strong>推荐**<strong>)</strong><ol><li><a href="http://zookeeper.apache.org/">Zookeeper</a> 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用</li></ol></li><li><strong>Redis 注册中心</strong><ol><li>基于Redis的注册中心</li></ol></li><li><strong>Simple 注册中心</strong><ol><li>基于本身的Dubbo服务实现（SimpleRegistryService），不支持集群可作为自定义注册中心的参考，但不适合直接用于生产环境。 </li></ol></li></ol><h3 id="Redis-注册中心"><a href="#Redis-注册中心" class="headerlink" title="Redis 注册中心"></a><strong>Redis 注册中心</strong></h3><p>关于Redis注册中心我们需要了解两点，</p><h4 id="1-如何存储服务的注册与订阅关系"><a href="#1-如何存储服务的注册与订阅关系" class="headerlink" title="1. 如何存储服务的注册与订阅关系"></a>1. 如何存储服务的注册与订阅关系</h4><p>redis 注册中心配置</p><pre><code>&lt;dubbo:registry protocol=&quot;redis&quot; address=&quot;192.168.0.147:6379&quot;/&gt;</code></pre><p>当我们启动两个服务端后发现，Reids中增加了一个Hash 类型的记录，其key为/dubbo/xxx.dubbo.server.UserService/providers。Value中分别存储了两个服务提供者的URL和有效期。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/89233BE1BB03402C9224A6348FAA7007.jpg" alt="image"></p><p><strong>同样消费者也是类似其整体结构如下：</strong></p><pre><code>//服务提供者注册信息 /dubbbo/com.xxx.teach.service.DemoService/providers  dubbo://192.168.246.1:20880/XXX.DemoService=1542619052964   dubbo://192.168.246.2:20880/XXX.DemoService=1542619052964 //服务消费订阅信息/dubbbo/com.xxx.teach.service.DemoService/consumers  dubbo://192.168.246.1:20880/XXX.DemoService=1542619788641</code></pre><ul><li>主 Key 为服务名和类型</li><li>Map 中的 Key 为 URL 地址</li><li>Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除</li></ul><h4 id="2-是当服务状态改变时如何即时更新？"><a href="#2-是当服务状态改变时如何即时更新？" class="headerlink" title="2. 是当服务状态改变时如何即时更新？"></a>2. 是当服务状态改变时如何即时更新？</h4><p>第二个问题 <strong>当提供者突然 宕机状态能即里变更吗</strong>？<br>这里Dubbo采用的是<strong>定时心跳的机制</strong> 来维护服务URL的有效期，默认<strong>每30秒更新一次有效期</strong>。即URL对应的毫秒值。具体代码参见：com.alibaba.dubbo.registry.redis.RedisRegistry#expireExecutor</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F32248B7D113492EBC48590051A3CD04.jpg" alt="image"></p><p>com.alibaba.dubbo.registry.redis.RedisRegistry#deferExpired<br>com.alibaba.dubbo.registry.integration.RegistryDirectory<br>com.alibaba.dubbo.registry.support.ProviderConsumerRegTable</p><h3 id="Zookeeper-注册中心"><a href="#Zookeeper-注册中心" class="headerlink" title="Zookeeper 注册中心"></a><strong>Zookeeper 注册中心</strong></h3><p>关于Zookeeper 注册中心同样需要了解其存储结构和更新机制。<br>Zookeper是一个树型的目录服务，本身支持变更推送相比 redis 的实现 Publish/Subscribe 功能更稳定。</p><ol><li>Provider和Consumer向Zookeeper注册临时节点，当连接断开时删除相应的注册节点。</li><li>Consumer订阅 Providers节点的子节点，通过 watch 事件，当 Zookeeper 删除临时节点时，实时感知 Provider 的变化情况，实时同步自身的Invoker对象，保证 RPC的可用性。</li></ol><p>结构：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D8B581F4BF944E94AF6382ECA1CB770F.jpg" alt="image"></p><h4 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h4><pre class="line-numbers language-java"><code class="language-java"> <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doRegister</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            zkClient<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token function">toUrlPath</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>DYNAMIC_KEY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RpcException</span><span class="token punctuation">(</span><span class="token string">"Failed to register "</span> <span class="token operator">+</span> url <span class="token operator">+</span> <span class="token string">" to zookeeper "</span> <span class="token operator">+</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">create</span><span class="token punctuation">(</span>String path<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ephemeral<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ephemeral<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkExists</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把前面的先创建好   dubbo/com.xx.xx/providers</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 创建持久节点</span>            <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ephemeral<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建一个临时节点,node 节点（保存具体地址）。</span>            <span class="token function">createEphemeral</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 创建持久节点</span>            <span class="token function">createPersistent</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>失败重连：</strong><br>com.alibaba.dubbo.registry.support.FailbackRegistry</p><p><strong>提供者突然断开：</strong><br>存储基于Zookeeper 临时节点机制实现，在客户端会话超时后（默认为40秒） Zookeeper 会自动删除所有临时节点。 </p><pre><code>// 创建临时节点com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient#createEphemeral</code></pre><p><strong>在 zookeeper 断开的40秒内 如果 有客户端加入 会调用 已失效的提供者连接吗？</strong></p><blockquote><p>答：不会，提供者宕机后 ，其与客户端的链接也随即断开，客户端在调用前会检测长连接是否可用状态的方法。</p><pre><code>// 检测连接是否有效 com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker#isAvailable</code></pre></blockquote><p>创建 configurators与 routers  会通过 <strong>持久节点</strong>来创建, 比如：“dubbo/com.xx.xx/providers”</p><pre><code>com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient#createPersistent</code></pre><p><strong>服务订阅机制实现：</strong></p><pre><code>// 注册目录com.alibaba.dubbo.registry.integration.RegistryDirectory</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7903EF7E728C436EBABA5AB637CB1588.jpg" alt="image"></p><h2 id="三、-Dubbo-调用模块"><a href="#三、-Dubbo-调用模块" class="headerlink" title="三、 Dubbo 调用模块"></a>三、 Dubbo 调用模块</h2><p>dubbo调用模块核心功能是发起一个远程方法的调用并顺利拿到返回结果，其体系组成如下：</p><ol><li><strong>透明代理：</strong> 通过动态代理技术，屏蔽远程调用细节以提高编程友好性。</li><li><strong>负载均衡：</strong> 当有多个提供者是，如何选择哪个进行调用的负载算法。</li><li><strong>容错机制：</strong> 当服务调用失败时采取的策略</li><li><strong>调用方式：</strong> 支持同步调用、异步调用</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C29CEB5BE9E4479EA5988A07FC429C28.jpg" alt="image"></p><h3 id="透明代理："><a href="#透明代理：" class="headerlink" title="透明代理："></a>透明代理：</h3><p>针对代理 dubbo 提供 三种方式：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BCE9E2B8BB9F4E1DBE9E0249FCE1D4C7.jpg" alt="image"></p><p>默认方式是：</p><pre><code>    public static final String DEFAULT_PROXY = &quot;javassist&quot;;</code></pre><p>调用链如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>config<span class="token punctuation">.</span>ReferenceConfig#createProxy<span class="token operator">--</span><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>javassist<span class="token punctuation">.</span>JavassistProxyFactory<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>bytecode<span class="token punctuation">.</span>Proxy#<span class="token function">getProxy</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>bytecode<span class="token punctuation">.</span>ClassGenerator#<span class="token function">newInstance</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/2835D117E1FE424F84ED8907FC986A2B.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5B1BA7C374ED444DAFD557DF5055D4D9.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B8DCD49FB51847ED97BBA2C316A5BCDF.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E7EF7C875FBD48A4B2037B3A74D5BC62.jpg" alt="image"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>Dubbo 目前官方支持以下负载均衡策略：</p><ol><li><strong>随机</strong>(random)：按权重设置随机概率。此为默认算法.</li><li><strong>轮循</strong>(roundrobin):按公约后的权重设置轮循比率。</li><li><strong>最少活跃调用数</strong>(leastactive):相同活跃数的随机，活跃数指调用前后计数差。</li><li><strong>一致性Hash</strong>(consistenthash ):相同的参数总是发到同一台机器</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/EDE99CF742414CB5921E56E2BD341282.jpg" alt="image"><br>设置方式支持如下四种方式设置，优先级由低至高</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 服务端级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 客户端级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 服务端方法级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>service</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 客户端方法级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a><strong>容错</strong></h3><p>Dubbo 官方目前支持以下容错策略：</p><ol><li><strong>失败自动切换：</strong> 调用失败后基于retries=“2” 属性重试其它服务器</li><li><strong>快速失败：</strong> 快速失败，只发起一次调用，失败立即报错。</li><li><strong>勿略失败：</strong> 失败后勿略，不抛出异常给客户端。</li><li><strong>失败重试：</strong> 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作</li><li><strong>并行调用:</strong> 只要一个成功即返回，并行调用指定数量机器，可通过 forks=”2” 来设置最大并行数。</li><li><strong>广播调用：</strong> 广播调用所有提供者，逐个调用，任意一台报错则报错</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CD04A0766E944919A0D62EBFE9F964C6.jpg" alt="image"><br>设置方式支持如下两种方式设置，优先级由低至高</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>Failover 失败自动切换 retries<span class="token operator">=</span><span class="token string">"1"</span> 切换次数Failfast 快速失败Failsafe 勿略失败Failback 失败重试，<span class="token number">5</span>秒后仅重试一次Forking 并行调用 forks<span class="token operator">=</span><span class="token string">"2"</span> 最大并行数Broadcast 广播调用<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dubbo<span class="token operator">:</span>service <span class="token keyword">interface</span><span class="token operator">=</span><span class="token string">"..."</span> cluster<span class="token operator">=</span><span class="token string">"broadcast"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>dubbo<span class="token operator">:</span>reference <span class="token keyword">interface</span><span class="token operator">=</span><span class="token string">"..."</span> cluster<span class="token operator">=</span><span class="token string">"broadcast"</span><span class="token operator">/</span> <span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：容错机制 在基于 API设置时无效 如  referenceConfig.setCluster(“failback”); 经测试不启作用 </p><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a><strong>异步调用</strong></h3><p>异步调用是指发起远程调用之后获取结果的方式。</p><ol><li>同步等待结果返回（默认）</li><li>异步等待结果返回</li><li>不需要返回结果</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F1C320C5A219405B8EFC66F1FE4CC78B.jpg" alt="image"></p><p>异步调用配置:</p><pre><code>&lt;dubbo:reference id=&quot;asyncDemoService&quot;    interface=&quot;com.xxx.teach.service.async.AsyncDemoService&quot;&gt;   &lt;!-- 异步调async：true 异步调用 false 同步调用--&gt;   &lt;dubbo:method name=&quot;sayHello1&quot; async=&quot;false&quot;/&gt;   &lt;dubbo:method name=&quot;sayHello2&quot; async=&quot;false&quot;/&gt;   &lt;dubbo:method name=&quot;notReturn&quot; return=&quot;false&quot;/&gt;&lt;/dubbo:reference&gt;</code></pre><p>注：在进行异步调用时 容错机制不能为  cluster=”forking” 或  cluster=”broadcast”</p><p><em>异步调用结果获取Demo</em></p><pre class="line-numbers language-java"><code class="language-java">demoService<span class="token punctuation">.</span><span class="token function">sayHello1</span><span class="token punctuation">(</span><span class="token string">"han"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future1 <span class="token operator">=</span> RpcContext<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>demoService<span class="token punctuation">.</span><span class="token function">sayHello2</span><span class="token punctuation">(</span><span class="token string">"han2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future2 <span class="token operator">=</span> RpcContext<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object r1 <span class="token operator">=</span> null<span class="token punctuation">,</span> r2 <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// wait 直到拿到结果 或超时</span>r1 <span class="token operator">=</span> future1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// wait 直到拿到结果 或超时</span>r2 <span class="token operator">=</span> future2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a><strong>过滤器</strong></h3><p>** 类似于 WEB 中的Filter ，Dubbo本身提供了Filter 功能用于拦截远程方法的调用。其支持自定义过滤器与官方的过滤器使用：**<br>#TODO 演示添加日志访问过滤:</p><pre><code>&lt;dubbo:provider  filter=&quot;accesslog&quot; accesslog=&quot;logs/dubbo.log&quot;/&gt;</code></pre><p>以上配置 就是 为 服务提供者 添加 日志记录过滤器， 所有访问日志将会集中打印至 accesslog 当中。</p><h2 id="调用通信-内部实现原理"><a href="#调用通信-内部实现原理" class="headerlink" title="调用通信  内部实现原理"></a>调用通信  内部实现原理</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/17E56F436154424BA5E8AAC97BD84B13.jpg" alt="image"></p><p><strong>IO模型：</strong></p><ol><li>BIO 同步阻塞</li><li>NIO 同步非阻塞</li><li>AIO 异步非阻塞</li></ol><p><strong>连接模型：</strong></p><ol><li>长连接</li><li>短连接</li></ol><p><strong>线程分类：</strong></p><ol><li>IO线程</li><li>服务端业务线程</li><li>客户端调度线程</li><li>客户端结果exchange线程。</li><li>保活心跳线程</li><li>重连线程</li></ol><p><strong>线程池模型：</strong></p><ol><li>固定数量线程池</li><li>缓存线程池</li><li>有限线程池</li></ol><h3 id="Dubbo-长连接实现与配置"><a href="#Dubbo-长连接实现与配置" class="headerlink" title="Dubbo 长连接实现与配置"></a><strong>Dubbo 长连接实现与配置</strong></h3><p><strong>初始连接：</strong></p><p>引用服务增加提供者 —&gt; 获取连接 –&gt; 是否获取共享连接 –&gt;创建连接客户端–&gt;开启心跳检测状态检查定时任务–&gt; 开启连接状态检测.</p><blockquote><p>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#getClients</p></blockquote><p><strong>心跳发送：</strong><br>在创建一个连接客户端同时也会创建一个心跳客户端，客户端默认基于60秒发送一次心跳来保持连接的存活，可通过 heartbeat 设置。</p><blockquote><p>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeClient#startHeatbeatTimer</p></blockquote><p><strong>断线重连：</strong><br>每创建一个客户端连接都会启动一个定时任务每两秒中检测一次当前连接状态，如果断线则自动重连。</p><blockquote><p>com.alibaba.dubbo.remoting.transport.AbstractClient#initConnectStatusCheckCommand</p></blockquote><p><strong>连接销毁:</strong><br>基于注册中心通知，服务端断开后销毁</p><blockquote><p>com.alibaba.dubbo.remoting.transport.AbstractClient#close()</p></blockquote><h3 id="Dubbo-传输协作线程"><a href="#Dubbo-传输协作线程" class="headerlink" title="Dubbo 传输协作线程"></a><strong>Dubbo 传输协作线程</strong></h3><ol><li><strong>客户端调度线程</strong>：用于发起远程方法调用的线程。</li><li><strong>客户端结果Exchange线程：</strong> 当远程方法返回response后由该线程填充至指定ResponseFuture，并叫醒等待的调度线程。</li><li><strong>客户端IO线程</strong> 由传输框架实现，用于request 消息流发送、response 消息流读取与解码等操作。</li><li><strong>服务端IO线程</strong>：由传输框架实现，用于request消息流读取与解码 与Response发送。</li><li><strong>业务执行线程：</strong> 服务端具体执行业务方法的线程</li></ol><p><strong>客户端线程协作：</strong><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/9564293312B2420DB80E156C7FB00CF5.jpg" alt="image"></p><ol><li><strong>调度线程</strong><ol><li>调用远程方法</li><li>对request 进行协议编码</li><li>发送request 消息至IO线程</li><li>等待结果的获取</li></ol></li><li><strong>IO线程</strong><ol><li>读取response流</li><li>response 解码</li><li>提交Exchange 任务</li></ol></li><li><strong>Exchange线程</strong><ol><li>填写response值 至 ResponseFuture</li><li>唤醒调度线程，通知其获取结果</li></ol></li></ol><p><strong>服务端线程协作：</strong><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/6E0C6D20EF8C4276B16C4BCF37D183CF.jpg" alt="image"></p><ol><li><strong>IO线程：</strong><ol><li>request 流读取</li><li>request 解码</li><li>提交业务处理任务</li></ol></li><li><strong>业务线程：</strong><ol><li>业务方法执行</li><li>response 编码</li><li>回写结果至channel</li></ol></li></ol><p><strong>线程池</strong></p><ol><li><strong>fixed：</strong> 固定线程池,此线程池启动时即创建固定大小的线程数，不做任何伸缩，</li><li><strong>cached：</strong> 缓存线程池,此线程池可伸缩，线程空闲一分钟后回收，新请求重新创建线程</li><li><strong>Limited：</strong> 有限线程池,此线程池一直增长，直到上限，增长后不收缩。</li></ol><h2 id="四、Dubbo-协议"><a href="#四、Dubbo-协议" class="headerlink" title="四、Dubbo 协议"></a>四、Dubbo 协议</h2><h3 id="RPC-协议名词解释"><a href="#RPC-协议名词解释" class="headerlink" title="RPC 协议名词解释"></a><strong>RPC 协议名词解释</strong></h3><p>在一个典型RPC的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中RPC协议就指明了程序如何进行网络传输和序列化 。也就是说一个RPC协议的实现就等于一个非透明的远程调用实现，如何做到的的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/AFE8EDF1A5B0427FA856137A2B9C6B12.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/35AAA35E698A442687702615820C1AD7.jpg" alt="image"></p><ol><li>地址：服务提供者地址</li><li>端口：协议指定开放的端口</li><li>报文编码：协议报文编码 ，分为请求头和请求体两部分。</li><li>序列化方式：将请求体序列化成对象<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A8AA0D50758B4D9BA51737391F3AE4CE.jpg" alt="image"></li><li>运行服务: 网络传输实现<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3DC6FD7E7BFB4F4786B0CCD6A9BF87DA.jpg" alt="image"></li></ol><h3 id="dubbo-支持的RPC协议"><a href="#dubbo-支持的RPC协议" class="headerlink" title="dubbo 支持的RPC协议"></a>dubbo 支持的RPC协议</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/DC0DB69BE0F449DF870E40A1093A57CC.jpg" alt="image"></p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>实现描述</strong></th><th align="left"><strong>连接描述</strong></th><th align="left"><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>dubbo</strong></td><td align="left">传输服务: mina, netty(默认), grizzy序列化: hessian2(默认), java, fastjson自定义报文</td><td align="left">单个长连接NIO异步传输</td><td align="left">1、常规RPC调用2、传输数据量小3、提供者少于消费者</td></tr><tr><td align="left"><strong>rmi</strong></td><td align="left">传输：java rmi 服务序列化：java原生二进制序列化</td><td align="left">多个短连接BIO同步传输</td><td align="left">1、常规RPC调用2、与原RMI客户端集成3、可传少量文件4、不支持防火墙穿透</td></tr><tr><td align="left"><strong>hessian</strong></td><td align="left">传输服务：servlet容器序列化：hessian二进制序列化</td><td align="left">基于Http 协议传输，依懒servlet容器配置</td><td align="left">1、提供者多于消费者2、可传大字段和文件3、跨语言调用</td></tr><tr><td align="left"><strong>http</strong></td><td align="left">传输服务：servlet容器序列化：java原生二进制序列化</td><td align="left">依懒servlet容器配置</td><td align="left">1、数据包大小混合</td></tr><tr><td align="left"><strong>thrift</strong></td><td align="left">与thrift RPC 实现集成，并在其基础上修改了报文头</td><td align="left">长连接、NIO异步传输</td><td align="left"></td></tr></tbody></table><p><strong><em>关于RMI不支持防火墙穿透的补充说明：</em></strong><br>    原因在于RMI 底层实现中会有两个端口，一个是固定的用于服务发现的注册端口，另外会生成一个**<em>随机**</em>端口用于网络传输。因为这个随机端口就不能在防火墙中提前设置开放开。所以存在<em>防火墙穿透问题</em></p><h3 id="协议的使用与配置"><a href="#协议的使用与配置" class="headerlink" title="协议的使用与配置:"></a><strong>协议的使用与配置:</strong></h3><p>Dubbo框架配置协议非常方便，用户只需要在 provider 应用中 配置*&lt;**dubbo:protocol&gt;*元素即可。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- name: 协议名称 dubbo|rmi|hessian|http|host:本机IP可不填，则系统自动获取port：端口、填-1表示系统自动选择server：运行服务 mina|netty|grizzy|servlet|jetty serialization：序列化方式 hessian2|java|compactedjava|fastjson 详细配置参见dubbo 官网 dubbo.io--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>192.168.0.11<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20880<span class="token punctuation">"</span></span> <span class="token attr-name">server</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>netty<span class="token punctuation">"</span></span> <span class="token attr-name">serialization</span><span class="token attr-value"><span class="token punctuation">=</span>“hessian2”</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span>“UTF-8”</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="dubbo-支持的序列化："><a href="#dubbo-支持的序列化：" class="headerlink" title="dubbo 支持的序列化："></a>dubbo 支持的序列化：</h3><table><thead><tr><th align="left"></th><th align="left">特点</th></tr></thead><tbody><tr><td align="left">fastjson</td><td align="left">文本型：体积较大，性能慢、跨语言、可读性高</td></tr><tr><td align="left">fst</td><td align="left">二进制型：体积小、兼容 JDK 原生的序列化。要求 JDK 1.7 支持。</td></tr><tr><td align="left">hessian2</td><td align="left">二进制型：跨语言、容错性高、体积小</td></tr><tr><td align="left">java</td><td align="left">二进制型：在JAVA原生的基础上 可以写入Null</td></tr><tr><td align="left">compactedjava</td><td align="left">二进制型：与java 类似，内容做了压缩</td></tr><tr><td align="left">nativejava</td><td align="left">二进制型：原生的JAVA 序列化</td></tr><tr><td align="left">kryo</td><td align="left">二进制型：体积比hessian2 还要小，但容错性 没有hessian2 好</td></tr></tbody></table><h3 id="Hessian-序列化"><a href="#Hessian-序列化" class="headerlink" title="Hessian 序列化"></a>Hessian 序列化</h3><ul><li>参数及返回值需实现 Serializable 接口</li><li>参数及返回值不能自定义实现 List,Map,Number,Date,Calendar等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。</li><li>Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况 <a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn1">[1]</a><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn2">[2]</a>：</li></ul><table><thead><tr><th align="left"><strong>数据通讯</strong></th><th align="left"><strong>情况</strong></th><th align="left"><strong>结果</strong></th></tr></thead><tbody><tr><td align="left">A-&gt;B</td><td align="left">类A多一种 属性（或者说类B少一种 属性）</td><td align="left">不抛异常，A多的那 个属性的值，B没有， 其他正常</td></tr><tr><td align="left">A-&gt;B</td><td align="left">枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输</td><td align="left">抛异常</td></tr><tr><td align="left">A-&gt;B</td><td align="left">枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输</td><td align="left">不抛异常，B正常接 收数据</td></tr><tr><td align="left">A-&gt;B</td><td align="left">A和B的属性 名相同，但类型不相同</td><td align="left">抛异常</td></tr><tr><td align="left">A-&gt;B</td><td align="left">serialId 不相同</td><td align="left">正常传输</td></tr></tbody></table><blockquote><p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。<br>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。</p></blockquote><p>总结：服务器端和客户端对领域对象并不需要完全一致，而是按照最大匹配原则。</p><h2 id="五、RPC协议报文编码与实现详解"><a href="#五、RPC协议报文编码与实现详解" class="headerlink" title="五、RPC协议报文编码与实现详解"></a>五、RPC协议报文编码与实现详解</h2><h3 id="RPC-传输实现："><a href="#RPC-传输实现：" class="headerlink" title="RPC 传输实现："></a><strong>RPC 传输实现：</strong></h3><p>RPC的协议的传输是基于 TCP/IP 做为基础使用Socket 或Netty、mina等网络编程组件实现。但有个问题是TCP是面向字节流的无边边界协议，其只管负责数据传输并不会区分每次请求所对应的消息，这样就会出现TCP协义传输当中的拆包与粘包问题</p><h3 id="拆包与粘包产生的原因："><a href="#拆包与粘包产生的原因：" class="headerlink" title="拆包与粘包产生的原因："></a><strong>拆包与粘包产生的原因：</strong></h3><p>我们知道tcp是以流动的方式传输数据，传输的最小单位为一个报文段（segment）。tcp Header中有个Options标识位，常见的标识为mss(Maximum Segment Size)指的是，连接层每次传输的数据有个最大限制MTU(Maximum Transmission Unit)，一般是1500比特，超过这个量要分成多个报文段，mss则是这个最大限制减去TCP的header，光是要传输的数据的大小，一般为1460比特。换算成字节，也就是180多字节。</p><p>tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。这时就会出现以下情况：</p><ol><li>应用程序写入的数据大于MSS大小，这将会发生拆包。</li><li>应用程序写入数据小于MSS大小，这将会发生粘包。</li><li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li></ol><h3 id="拆包与粘包解决办法："><a href="#拆包与粘包解决办法：" class="headerlink" title="拆包与粘包解决办法："></a><strong>拆包与粘包解决办法：</strong></h3><ol><li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。</li><li>{“type”:”message”,”content”:”hello”}\n</li><li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li></ol><p><strong>比如：</strong> Http协议 heade 中的 Content-Length 就表示消息体的大小。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1627E3D71B36459393AAD1066002AFE6.jpg" alt="image"></p><h3 id="Dubbo-协议报文编码："><a href="#Dubbo-协议报文编码：" class="headerlink" title="Dubbo 协议报文编码："></a>Dubbo 协议报文编码：</h3><p><strong>dubbo 协议报文编码：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/25B9C2C5C20C46168D641144B2B6A07E.jpg" alt="image"></p><ul><li><strong>magic</strong>：类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包。魔数是常量0xdabb,用于判断报文的开始。</li><li><strong>flag</strong>：标志位, 一共8个地址位。低四位用来表示消息体数据用的序列化工具的类型（默认hessian），高四位中，第一位为1表示是request请求，第二位为1表示双向传输（即有返回response），第三位为1表示是心跳ping事件。</li><li><strong>status</strong>：状态位, 设置请求响应状态，dubbo定义了一些响应的类型。具体类型见 com.alibaba.dubbo.remoting.exchange.Response</li><li><strong>invoke id：</strong> 消息id, long 类型。每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）</li><li><strong>body length：</strong> 消息体 body 长度, int 类型，即记录Body Content有多少个字节。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B37D5C57C013452AA75C1DCB90F2766A.jpg" alt="image"></p><ul><li>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#encodeRequestData()</li></ul><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">encodeRequestData</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> ObjectOutput out<span class="token punctuation">,</span> Object data<span class="token punctuation">,</span> String version<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        RpcInvocation inv <span class="token operator">=</span> <span class="token punctuation">(</span>RpcInvocation<span class="token punctuation">)</span> data<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//版本号</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//接口路径</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getAttachment</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>PATH_KEY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//接口版本</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getAttachment</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>VERSION_KEY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//方法名称</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//参数类型</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>ReflectUtils<span class="token punctuation">.</span><span class="token function">getDesc</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//参数值</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> inv<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token function">encodeInvocationArgument</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> inv<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#encodeResponseData()</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">encodeResponseData</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> ObjectOutput out<span class="token punctuation">,</span> Object data<span class="token punctuation">,</span> String version<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>      Result result <span class="token operator">=</span> <span class="token punctuation">(</span>Result<span class="token punctuation">)</span> data<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// currently, the version value in Response records the version of Request</span>      <span class="token keyword">boolean</span> attach <span class="token operator">=</span> Version<span class="token punctuation">.</span><span class="token function">isSupportResponseAttatchment</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>      Throwable th <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>th <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          Object ret <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              out<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span>attach <span class="token operator">?</span> RESPONSE_NULL_VALUE_WITH_ATTACHMENTS <span class="token operator">:</span> RESPONSE_NULL_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              out<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span>attach <span class="token operator">?</span> RESPONSE_VALUE_WITH_ATTACHMENTS <span class="token operator">:</span> RESPONSE_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>              out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          out<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span>attach <span class="token operator">?</span> RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS <span class="token operator">:</span> RESPONSE_WITH_EXCEPTION<span class="token punctuation">)</span><span class="token punctuation">;</span>          out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>attach<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// returns current version of Response to consumer side.</span>          result<span class="token punctuation">.</span><span class="token function">getAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>DUBBO_VERSION_KEY<span class="token punctuation">,</span> Version<span class="token punctuation">.</span><span class="token function">getProtocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>解码</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Object <span class="token function">decodeBody</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> InputStream is<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> header<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">byte</span> flag <span class="token operator">=</span> header<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> proto <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> SERIALIZATION_MASK<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取 request id</span>        <span class="token keyword">long</span> id <span class="token operator">=</span> Bytes<span class="token punctuation">.</span><span class="token function">bytes2long</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断是request 解码还是 response 解码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_REQUEST<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//客户端： 解码 response.</span>            Response res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_EVENT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">setEvent</span><span class="token punctuation">(</span>Response<span class="token punctuation">.</span>HEARTBEAT_EVENT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// get status.</span>            <span class="token keyword">byte</span> status <span class="token operator">=</span> header<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> Response<span class="token punctuation">.</span>OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Object data<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">isHeartbeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        data <span class="token operator">=</span> <span class="token function">decodeHeartbeatData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span>  CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">isEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        data <span class="token operator">=</span> <span class="token function">decodeEventData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span>  CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        DecodeableRpcResult result<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>                                Constants<span class="token punctuation">.</span>DECODE_IN_IO_THREAD_KEY<span class="token punctuation">,</span>                                Constants<span class="token punctuation">.</span>DEFAULT_DECODE_IN_IO_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcResult</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> res<span class="token punctuation">,</span> is<span class="token punctuation">,</span>                                    <span class="token punctuation">(</span>Invocation<span class="token punctuation">)</span> <span class="token function">getRequestData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                            result<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcResult</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> res<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">UnsafeByteArrayInputStream</span><span class="token punctuation">(</span><span class="token function">readMessageData</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    <span class="token punctuation">(</span>Invocation<span class="token punctuation">)</span> <span class="token function">getRequestData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        data <span class="token operator">=</span> result<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    res<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">setErrorMessage</span><span class="token punctuation">(</span>CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Decode response failed: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>Response<span class="token punctuation">.</span>CLIENT_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">setErrorMessage</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 服务端 ：解码 request.</span>            Request req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            req<span class="token punctuation">.</span><span class="token function">setVersion</span><span class="token punctuation">(</span>Version<span class="token punctuation">.</span><span class="token function">getProtocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            req<span class="token punctuation">.</span><span class="token function">setTwoWay</span><span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_TWOWAY<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_EVENT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                req<span class="token punctuation">.</span><span class="token function">setEvent</span><span class="token punctuation">(</span>Request<span class="token punctuation">.</span>HEARTBEAT_EVENT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Object data<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">isHeartbeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    data <span class="token operator">=</span> <span class="token function">decodeHeartbeatData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">isEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    data <span class="token operator">=</span> <span class="token function">decodeEventData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    DecodeableRpcInvocation inv<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>                            Constants<span class="token punctuation">.</span>DECODE_IN_IO_THREAD_KEY<span class="token punctuation">,</span>                            Constants<span class="token punctuation">.</span>DEFAULT_DECODE_IN_IO_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        inv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcInvocation</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> req<span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                        inv<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        inv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcInvocation</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> req<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">UnsafeByteArrayInputStream</span><span class="token punctuation">(</span><span class="token function">readMessageData</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    data <span class="token operator">=</span> inv<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Decode request failed: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// bad request</span>                req<span class="token punctuation">.</span><span class="token function">setBroken</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> req<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/298139E160AA428486709FD4E1641C6A.jpg" alt="image"></p><h2 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h2><ol><li>负载均衡：多个机器调用哪一台?<blockquote><p>答：多种负载均衡策略。</p></blockquote></li><li>服务发现：怎样发现新的服务地址呢？<blockquote><p>答：服务注册与发现。</p></blockquote></li><li>健康检测：服务关宕机或恢复后怎么办？<blockquote><p>答：两种情况，消费者还是用老的请求，则</p></blockquote></li><li>容错：如果调用其中一台调用出错了怎么办？<blockquote><p>答：容错策略。</p></blockquote></li></ol><ul><li><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html">Dubbo官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/brokge/drawio/img/64A03BA7F21B4BB29F4ABC5F11140870.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;分布式架构的-有-3-种解决方案&quot;&gt;&lt;a href=&quot;#分布式架构的-有-3-种解决方案&quot; class=&quot;headerlink&quot; title=&quot;分布式架构的 有 3 种解决方案&quot;&gt;&lt;/a&gt;&lt;strong&gt;分布式架构的 有 3 种解决方案&lt;/strong&gt;&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;基于反向代理的中心化架构&lt;/li&gt;
&lt;li&gt;嵌入应用内部的去中心化架构&lt;/li&gt;
&lt;li&gt;基于独立代理进程的Service Mesh架构
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="微服务" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="https://brokge.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis核心原理详解</title>
    <link href="https://brokge.github.io/2020/02/11/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://brokge.github.io/2020/02/11/Redis核心原理详解/</id>
    <published>2020-02-11T12:04:17.000Z</published>
    <updated>2020-08-21T04:55:10.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Redis-基础数据结构"><a href="#一、Redis-基础数据结构" class="headerlink" title="一、Redis 基础数据结构"></a>一、Redis 基础数据结构</h2><p>Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)，下面就详细说说这几种数据结构。<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0A3FCFF09EFA4D6A8B1F6D5CCCF848A8.jpg" alt="image"></p><a id="more"></a><h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>我们先来看列表。列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是压缩列表（ziplist），另一种是双向循环链表。当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><ol><li>列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；</li><li>列表中数据个数少于 512 个。</li></ol><p>所谓压缩列表，它并不是基础数据结构，而是 Redis为了<strong>压缩内存和支持存储不同类型的数据</strong>， 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同,由于分配的空间不同，所以不能通过地址索引随机访问。<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5909E6B696754BF0BD809353853E6B34.jpg" alt="image"><br>如果不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了。</p><h3 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h3><p>典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的压缩列表，另一种是散列表。同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。<br>具体需要满足两个条件：</p><ol><li>字典中保存的键和值的大小都要小于 64 字节；</li><li>字典中键值对的个数要小于 512 个。</li></ol><p>当不能同时满足上面两个条件的时候 Redis 就使用散列表来实现字典类型。Redis 使用<strong>MurmurHash2</strong>这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。</p><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。</p><ol><li>存储的数据都是整数；</li><li>存储的数据元素个数不超过 512个。</li></ol><p>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</p><h3 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h3><p>有序集合这种数据类型，它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，进行数据结构组织。当数据量比较小的时候，Redis 会用压缩列表来实现有序集合。</p><ol><li>所有数据的大小都要小于 64 字节；</li><li>元素个数要小于 128 个。</li></ol><p>当两者都不满足时，会采用跳表这样的数据结构来存储。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p><h2 id="一些高级命令"><a href="#一些高级命令" class="headerlink" title="一些高级命令"></a>一些高级命令</h2><ul><li>keys：全量遍历键，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用</li></ul><ul><li><p>scan：渐进式遍历键，scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。</p></li><li><p>Info：查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是: </p><blockquote><p>Server 服务器运行的环境参数<br>  Clients 客户端相关信息<br>  Memory 服务器运行内存统计数据<br>  Persistence 持久化信息<br>  Stats 通用统计数据<br>  Replication 主从复制相关信息<br>  CPU CPU 使用情况<br>  Cluster 集群信息 </p></blockquote></li></ul><h2 id="二、线程模型核心原理"><a href="#二、线程模型核心原理" class="headerlink" title="二、线程模型核心原理"></a>二、线程模型核心原理</h2><p>Redis的单线程和高性能</p><p>Redis 单线程为什么还能这么快？</p><blockquote><p>因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。 </p></blockquote><p>Redis 单线程如何处理那么多的并发客户端连接？</p><blockquote><p>Redis的IO多路复用：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</p></blockquote><p>Nginx也是采用IO多路复用原理解决C10K问题</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F5F6FED5FA534F7CA467AD6D634E8E49.jpg" alt="image"></p><h2 id="三、持久化"><a href="#三、持久化" class="headerlink" title="三、持久化"></a>三、持久化</h2><h3 id="RDB快照（snapshot）"><a href="#RDB快照（snapshot）" class="headerlink" title="RDB快照（snapshot）"></a>RDB快照（snapshot）</h3><p>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。<br>你可以对 Redis 进行设置， 让它在“N秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。<br>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：</p><blockquote><p> save 60 1000</p></blockquote><h3 id="AOF（append-only-file）"><a href="#AOF（append-only-file）" class="headerlink" title="AOF（append-only file）"></a>AOF（append-only file）</h3><p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将修改的每一条指令记录进文件<br>你可以通过修改配置文件来打开 AOF 功能：</p><blockquote><p>appendonly yes</p></blockquote><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。<br>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。<br>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。</p><p>有三个选项：</p><ol><li>每次有新命令追加到 AOF 文件时就执行一次 fsync：非常慢，也非常安全。</li><li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li><li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。<br>推荐（并且也是默认）的措施为每秒 fsync一次， 这种 fsync 策略可以兼顾速度和安全性。 </li></ol><h3 id="RDB-和-AOF-，我应该用哪一个？"><a href="#RDB-和-AOF-，我应该用哪一个？" class="headerlink" title="RDB 和 AOF ，我应该用哪一个？"></a>RDB 和 AOF ，我应该用哪一个？</h3><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。<br>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h3 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h3><p>重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。AOF在重写(aof文件里可能有太多没用指令，所以aof会定期根据内存的最新数据生成aof文件)时将重写这一刻之前的内存rdb快照文件的内容和增量的 AOF修改内存数据的命令日志文件存在一起，都写入新的aof文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换；<br>AOF根据配置规则在后台自动重写，也可以人为执行命令bgrewriteaof重写AOF。 于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><p>开启混合持久化：</p><blockquote><p>aof-use-rdb-preamble yes   </p></blockquote><p>混合持久化aof文件结构</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/00BB6062917B4FC4A6F72ADD90007BB4.jpg" alt="image"></p><h2 id="四、缓存淘汰策略"><a href="#四、缓存淘汰策略" class="headerlink" title="四、缓存淘汰策略"></a>四、缓存淘汰策略</h2><p>当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样龟速的存取效率基本上等于不可用。<br>在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小。<br>当实际内存超出 maxmemory 时，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务。</p><ul><li>noeviction 不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。</li><li>volatile-lru 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。</li><li>volatile-ttl 跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰。</li><li>volatile-random 跟上面一样，不过淘汰的 key 是过期 key 集合中随机的 key。</li><li>allkeys-lru 区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。</li><li>allkeys-random 跟上面一样，不过淘汰的策略是随机的 key。</li></ul><blockquote><p>volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。</p></blockquote><h2 id="五、Redis集群原理分析"><a href="#五、Redis集群原理分析" class="headerlink" title="五、Redis集群原理分析"></a>五、Redis集群原理分析</h2><p>redis cluster 是 redis 分布式集群解决方案，从 3.0 之后推出解决 redis 分布式方面需求，实现数据分片、故障转移、扩容所容机制等。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7EDE606229F6415BBA9A4C7A9FB975FB.jpg" alt="image"></p><p>Redis Cluster 将所有数据划分为 16384 的 slots(槽位)，每个节点负责其中一部分槽 位。槽位的信息存储于每个节点中。 当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将 其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。 同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实 现槽位信息的校验调整。</p><ul><li>redis集群大小的选择,可以装多少数据?<blockquote><p>理论是可以做到16384个集群,每个槽对应一个实例,但是redis官方建议是最大1000个实例。存储足够大了。另外：节点之间会有频繁通信，传递的包括槽位信息，集群太大会有带宽消耗。</p></blockquote></li></ul><h3 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a>槽位定位算法</h3><p>槽位定位算法 也就是常说的 一致性Hash算法<br>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整 数值对 16384 进行取模来得到具体槽位。 HASH_SLOT = CRC16(key) mod 16384</p><ul><li>那么增加了slot槽的计算,是不是比单机性能差?<blockquote><p>共16384个槽, slots槽计算方式公开的,<br>为了避免每次都需要服务器计算重定向,优秀的java客户端都实现了本地计算,并且缓存服务器slots分配,有变动时再更新本地内容,从而避免了多次重定向带来的性能损耗</p></blockquote></li></ul><ul><li>访问倾斜和数据存储倾斜问题怎么处理？<blockquote><p>倾斜导致某些节点量大，压力大 可以从两方面着手</p><ol><li>事前预测数据哪些会是热点数据，设计的时候规避。</li><li>事后 通过 slot 调整，压力分摊（slot 调整：rebalance 和 reshared）</li></ol></blockquote></li></ul><h3 id="跳转重定位"><a href="#跳转重定位" class="headerlink" title="跳转重定位"></a>跳转重定位</h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归 自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告 诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操 作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射 表。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F13207F13DBB421EAD5B865697A65B79.jpg" alt="image"></p><ul><li>ask和moved重定向的区别<blockquote><p>重定向包括两种情况,若确定slot不属于当前节点, redis会返回moved<br>,若当煎redis节点正在处理slot迁移,则代表此处请求对应的key暂时不在此节定向。</p></blockquote></li></ul><h3 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h3><p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比 如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又 恢复正常。 为解决这种问题，Redis Cluster 提供了一种选项cluster node timeout，表示当某 个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切 换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p><h3 id="主从切换-选举原理"><a href="#主从切换-选举原理" class="headerlink" title="主从切换 选举原理"></a>主从切换 选举原理</h3><p>Redis 集群使用一个类似于木筏算法（Raft algorithm）概念。如果没有了解过可以看看这个  <a href="http://thesecretlivesofdata.com/raft/">Raft</a>, 在 Redis 集群中这个术语叫做 阶段（epoch）。</p><p>Redis 集群中的每个节点，包括主节点和从节点，都在创建的时候设置了 currentEpoch 为0。每次主从选举之后 Epoch 会相应的加 1。如果出现脑裂的情况，其他主节点只认 epoch 最大的那个。</p><p>Redis集群选举原理分析当 slave 发现自己的 master 变为FAIL状态时，便尝试进行 Failover，以期成为新的 master。由于挂掉的master 可能会有多个 slave，从而存在多个 slave 竞争成为 master节点的过程， 其过程如下：</p><ol><li>slave 发现自己的 master变为FAIL</li><li>将自己记录的集群currentEpoch（年代，纪元）加 1，并广播FAILOVER_AUTH_REQUEST 信息</li><li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试failover的slave收集FAILOVER_AUTH_ACK</li><li>超过半数后变成新Master</li><li>广播 Pong 通知其他集群节点。</li></ol><p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p><ul><li>延迟计算公式：<blockquote><p>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p></blockquote></li><li>SLAVE_RANK 表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</li></ul><h2 id="发布订阅机制"><a href="#发布订阅机制" class="headerlink" title="发布订阅机制"></a>发布订阅机制</h2><p>发布/订阅（Publish/Subscribe）<br>在一个 Redis 集群中，客户端能订阅任何一个节点，也能发布消息给任何一个节点。集群会确保发布的消息都会按需进行转发。 目前的实现方式是单纯地向所有节点广播所有的发布消息，在将来的实现中会用 bloom filters 或其他算法来优化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://redis.cn/topics/cluster-tutorial.html">Redis 集群教程</a></li><li>数据结构与算法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Redis-基础数据结构&quot;&gt;&lt;a href=&quot;#一、Redis-基础数据结构&quot; class=&quot;headerlink&quot; title=&quot;一、Redis 基础数据结构&quot;&gt;&lt;/a&gt;一、Redis 基础数据结构&lt;/h2&gt;&lt;p&gt;Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)，下面就详细说说这几种数据结构。&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/brokge/drawio/img/0A3FCFF09EFA4D6A8B1F6D5CCCF848A8.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="缓存" scheme="https://brokge.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://brokge.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis5 集群搭建</title>
    <link href="https://brokge.github.io/2020/02/10/redis5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://brokge.github.io/2020/02/10/redis5集群搭建/</id>
    <published>2020-02-10T04:50:24.000Z</published>
    <updated>2020-08-21T04:55:02.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、-环境信息"><a href="#1、-环境信息" class="headerlink" title="1、 环境信息"></a>1、 环境信息</h1><pre class="line-numbers language-bash"><code class="language-bash">centos7redis5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><a id="more"></a><h1 id="2、整体集群信息"><a href="#2、整体集群信息" class="headerlink" title="2、整体集群信息"></a>2、整体集群信息</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以直接在一台机器上实现上述的伪集群，因为端口号特意设置为不同的。</span><span class="token comment" spellcheck="true"># 重点：不论机器多少，对于部署过程都是一样的，只不过是在不同机器启动redis-server而已</span>192.168.100.242 <span class="token punctuation">(</span>6381- 6386共6个端口）<span class="token comment" spellcheck="true"># 注意事项：如果你的服务器有多个IP，那你操作下面步骤时，尽量使用你的客户端能够访问的IP</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3、每台服务器上面都要下载安装"><a href="#3、每台服务器上面都要下载安装" class="headerlink" title="3、每台服务器上面都要下载安装"></a>3、每台服务器上面都要下载安装</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> http://download.redis.io/releases/redis-5.0.3.tar.gz<span class="token function">tar</span> -zxvf redis-5.0.3.tar.gz<span class="token function">cd</span> redis-5.0.3 <span class="token function">make</span><span class="token comment" spellcheck="true"># 安装到 /usr/local/redis 目录中 安装的文件只有一个bin目录</span><span class="token function">make</span> <span class="token function">install</span> PREFIX<span class="token operator">=</span>/usr/local/redis/ <span class="token comment" spellcheck="true"># 创建配置文件和data存放目录</span><span class="token function">mkdir</span> /usr/local/redis/conf /usr/local/redis/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4、准备6个redis-conf配置文件（为了方便学习，redis-conf根据不同端口来命名，方便一台机器上构建伪集群）"><a href="#4、准备6个redis-conf配置文件（为了方便学习，redis-conf根据不同端口来命名，方便一台机器上构建伪集群）" class="headerlink" title="4、准备6个redis.conf配置文件（为了方便学习，redis.conf根据不同端口来命名，方便一台机器上构建伪集群）"></a>4、准备6个redis.conf配置文件（为了方便学习，redis.conf根据不同端口来命名，方便一台机器上构建伪集群）</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改</span><span class="token comment" spellcheck="true">#后台启动的意思</span>daemonize <span class="token function">yes</span>  <span class="token comment" spellcheck="true">#端口号</span>port 6381<span class="token comment" spellcheck="true"># IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病</span>bind 0.0.0.0<span class="token comment" spellcheck="true"># redis数据文件存放的目录</span><span class="token function">dir</span> /usr/local/redis/data<span class="token comment" spellcheck="true"># 开启AOF</span>appendonly <span class="token function">yes</span> <span class="token comment" spellcheck="true"># 开启集群</span>cluster-enabled <span class="token function">yes</span><span class="token comment" spellcheck="true"># 会自动生成在上面配置的dir目录下</span>cluster-config-file nodes-6381.conf cluster-node-timeout 5000<span class="token comment" spellcheck="true"># 这个文件会自动生成</span>pidfile /var/run/redis_6381.pid <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5、启动6个Redis实例"><a href="#5、启动6个Redis实例" class="headerlink" title="5、启动6个Redis实例"></a>5、启动6个Redis实例</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 一定要注意每个配置文件中的端口号哦</span>/usr/local/redis/bin/redis-server /usr/local/redis/conf/6381.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6382.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6383.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6384.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6385.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6386.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6、-创建cluster"><a href="#6、-创建cluster" class="headerlink" title="6、 创建cluster"></a>6、 创建cluster</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 5.0版本的方式</span>/usr/local/redis/bin/redis-cli --cluster create 192.168.100.242:6381 192.168.100.242:6382 \192.168.100.242:6383 192.168.100.242:6384 192.168.100.242:6385 192.168.100.242:6386 \--cluster-replicas 1<span class="token comment" spellcheck="true"># 自动设置主从，而且会提示你，是否运行使用自动的配置</span>Can I <span class="token keyword">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span class="token function">yes</span><span class="token comment" spellcheck="true"># 执行后的信息</span><span class="token operator">>></span><span class="token operator">></span> Performing <span class="token function">hash</span> slots allocation on 6 nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span>0<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 0 - 5460Master<span class="token punctuation">[</span>1<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 5461 - 10922Master<span class="token punctuation">[</span>2<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 10923 - 16383Adding replica 192.168.100.242:6384 to 192.168.100.242:6381Adding replica 192.168.100.242:6385 to 192.168.100.242:6382Adding replica 192.168.100.242:6386 to 192.168.100.242:6383<span class="token operator">>></span><span class="token operator">></span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same host as their masterM: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> masterM: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> masterM: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> masterS: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7S: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3cCan I <span class="token keyword">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span class="token function">yes</span><span class="token operator">>></span><span class="token operator">></span> Nodes configuration updated<span class="token operator">>></span><span class="token operator">></span> Assign a different config epoch to each node<span class="token operator">>></span><span class="token operator">></span> Sending CLUSTER MEET messages to <span class="token function">join</span> the clusterWaiting <span class="token keyword">for</span> the cluster to <span class="token function">join</span><span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Performing Cluster Check <span class="token punctuation">(</span>using node 192.168.100.242:6381<span class="token punctuation">)</span>M: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86S: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7M: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>M: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3c<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">>></span><span class="token operator">></span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All 16384 slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7、-集群检验和测试"><a href="#7、-集群检验和测试" class="headerlink" title="7、 集群检验和测试"></a>7、 集群检验和测试</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 检查集群，查看所有节点信息</span>/usr/local/redis/bin/redis-cli -c -h 192.168.100.242 -p 6381 cluster nodes<span class="token comment" spellcheck="true"># 执行后的信息</span><span class="token punctuation">[</span>root@node3 redis<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># /usr/local/redis/bin/redis-cli -c -h 192.168.100.242 -p 6381 cluster nodes</span>0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385@16385 slave 93293699b8966ccc202bb29c659a9f60e26e4c86 0 1550635081000 5 connecteda842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384@16384 slave 764500b86fadebd535ac2b5b778a73486fe7d2b7 0 1550635081565 4 connected93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383@16383 master - 0 1550635081665 3 connected 10923-16383764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382@16382 master - 0 1550635081000 2 connected 5461-1092268326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381@16381 myself,master - 0 1550635080000 1 connected 0-546042806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386@16386 slave 68326caa0238cb877afc3e6df23eb92558fcbc3c 0 1550635080664 6 connected<span class="token comment" spellcheck="true"># 节点id ip+端口 角色 masterid 处理的ping数量 最后一个pong时间 节点配置版本 节点连接状态 slot槽分配情况</span><span class="token comment" spellcheck="true"># 测试Redis Cluster的一种简单方法是使用redis-cli命令行实用程序</span><span class="token comment" spellcheck="true"># -c 是支持cluster重定向</span><span class="token punctuation">[</span>root@node3 redis<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># /usr/local/redis/bin/redis-cli -c -h 192.168.100.242 -p 6381</span>192.168.100.242:6381<span class="token operator">></span> <span class="token keyword">set</span> a 1-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>15495<span class="token punctuation">]</span> located at 192.168.100.242:6383OK192.168.100.242:6383<span class="token operator">></span> get a<span class="token string">"1"</span>192.168.100.242:6383<span class="token operator">></span> <span class="token keyword">set</span> hello tony-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>866<span class="token punctuation">]</span> located at 192.168.100.242:6381OK192.168.100.242:6381<span class="token operator">></span> get hello<span class="token string">"tony"</span>192.168.100.242:6381<span class="token operator">></span> get a-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>15495<span class="token punctuation">]</span> located at 192.168.100.242:6383<span class="token string">"1"</span><span class="token comment" spellcheck="true"># 查看一个key属于哪一个节点</span>CLUSTER KEYSLOT key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="8、集群slot数量整理-reshard"><a href="#8、集群slot数量整理-reshard" class="headerlink" title="8、集群slot数量整理 reshard"></a>8、集群slot数量整理 reshard</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#  /usr/local/redis/bin/redis-cli --cluster help 可以查看所有这个命令和子命令的帮助信息</span><span class="token comment" spellcheck="true"># 默认是master平均分了0-16383的所有虚拟slot</span><span class="token comment" spellcheck="true"># 可以进行调整，部分节点放多一点slot(槽或者位置)。</span>/usr/local/redis/bin/redis-cli --cluster reshard  <span class="token operator">&lt;</span>host<span class="token operator">></span>:<span class="token operator">&lt;</span>port<span class="token operator">></span> --cluster-from <span class="token operator">&lt;</span>node-id<span class="token operator">></span> --cluster-to <span class="token operator">&lt;</span>node-id<span class="token operator">></span> --cluster-slots <span class="token operator">&lt;</span>number of slots<span class="token operator">></span> --cluster-yes<span class="token comment" spellcheck="true"># 重新检查集群</span><span class="token punctuation">[</span>root@node3 redis<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># /usr/local/redis/bin/redis-cli --cluster check 192.168.100.242:6382</span>192.168.100.242:6382 <span class="token punctuation">(</span>764500b8<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">></span> 0 keys <span class="token operator">|</span> 5462 slots <span class="token operator">|</span> 1 slaves.192.168.100.242:6383 <span class="token punctuation">(</span>93293699<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">></span> 1 keys <span class="token operator">|</span> 5461 slots <span class="token operator">|</span> 1 slaves.192.168.100.242:6381 <span class="token punctuation">(</span>68326caa<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">></span> 1 keys <span class="token operator">|</span> 5461 slots <span class="token operator">|</span> 1 slaves.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> 2 keys <span class="token keyword">in</span> 3 masters.0.00 keys per slot on average.<span class="token operator">>></span><span class="token operator">></span> Performing Cluster Check <span class="token punctuation">(</span>using node 192.168.100.242:6382<span class="token punctuation">)</span>M: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7M: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3cS: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86M: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">>></span><span class="token operator">></span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All 16384 slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9、-测试自动故障转移"><a href="#9、-测试自动故障转移" class="headerlink" title="9、 测试自动故障转移"></a>9、 测试自动故障转移</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cluster集群不保证数据一致，数据也可能丢失</span><span class="token comment" spellcheck="true"># 首先是运行客户端不断的写入或读取数据，以便能够发现问题</span><span class="token comment" spellcheck="true"># 然后是模拟节点故障：找一个主节点关闭，主从故障切换的过程中，这个时间端的操作，客户端而言，只能是失败</span><span class="token comment" spellcheck="true"># 官方描述 https://redis.io/topics/cluster-spec  </span>There is always a window of <span class="token function">time</span> when it is possible to lose writes during partitions.分区的时间窗口内总是有可能丢失写操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="10、手动故障转移"><a href="#10、手动故障转移" class="headerlink" title="10、手动故障转移"></a>10、手动故障转移</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 可能某个节点需要维护（机器下线、硬件升级、系统版本调整等等场景），需要手动的实现转移</span><span class="token comment" spellcheck="true"># 在slave节点上执行命令</span>CLUSTER FAILOVER <span class="token comment" spellcheck="true"># 注：CLUSTER  help 可以看到帮助文档和简介。 相对安全的做法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="11、扩容"><a href="#11、扩容" class="headerlink" title="11、扩容"></a>11、扩容</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、 启动新节点</span>/usr/local/redis/bin/redis-server /usr/local/redis/conf/6387.conf<span class="token comment" spellcheck="true"># 2、 加入到已经存在的集群作为master</span>/usr/local/redis/bin/redis-cli --cluster add-node 192.168.100.242:6387 192.168.100.242:6382<span class="token comment" spellcheck="true"># 本质就是发送一个新节点通过 CLUSTER MEET命令加入集群</span><span class="token comment" spellcheck="true"># 新节点没有分配hash槽</span><span class="token comment" spellcheck="true"># 3、 加入到已经存在的集群作为slave</span>/usr/local/redis/bin/redis-cli --cluster add-node 192.168.100.242:7006 192.168.100.242:7000 --cluster-slave<span class="token comment" spellcheck="true"># 可以手工指定master，否则就是选择一个slave数量较少的master </span>/usr/local/redis/bin/redis-cli --cluster add-node 192.168.100.242:7006 192.168.100.242:7000 --cluster-slave --cluster-master-id <span class="token operator">&lt;</span>node-id<span class="token operator">></span><span class="token comment" spellcheck="true"># 还可以将空master，转换为slave</span>cluster replicate <span class="token operator">&lt;</span>master-node-id<span class="token operator">></span><span class="token comment" spellcheck="true"># 4、 检查集群</span>/usr/local/redis/bin/redis-cli --cluster check 192.168.100.242:6382<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="12、缩容（删除节点）"><a href="#12、缩容（删除节点）" class="headerlink" title="12、缩容（删除节点）"></a>12、缩容（删除节点）</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 注意：删除master的时候要把数据清空或者分配给其他主节点</span>/usr/local/redis/bin/redis-cli --cluster del-node 192.168.100.242:6381 <span class="token operator">&lt;</span>node-id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="13、关心的问题"><a href="#13、关心的问题" class="headerlink" title="13、关心的问题"></a>13、关心的问题</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、 增加了slot槽的计算，是不是比单机性能差？</span>共16384个槽，slots槽计算方式公开的，java客户端中就使用了：HASH_SLOT <span class="token operator">=</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> mod 16384为了避免每次都需要服务器计算重定向，优秀的java客户端都实现了本地计算，和服务器slots分配进行映射，有变动时再更新本地内容。<span class="token comment" spellcheck="true"># 2、 redis集群大小</span>理论是可以做到16384个槽，但是redis官方建议是最大1000个实例<span class="token comment" spellcheck="true"># 3、 批量操作或者</span><span class="token comment" spellcheck="true"># 4、cluster meet命令中的bus-port是什么？</span>MEET <span class="token operator">&lt;</span>ip<span class="token operator">></span> <span class="token operator">&lt;</span>port<span class="token operator">></span> <span class="token punctuation">[</span>bus-port<span class="token punctuation">]</span>每个Redis群集节点都有一个额外的TCP端口，用于接收来自其他Redis群集节点的传入连接<span class="token comment" spellcheck="true"># 5、集群节点间的通信方式</span>每个节点使用TCP连接与每个其他节点连接。<span class="token comment" spellcheck="true"># 6、ask和moved重定向的区别</span>重定向包括两种情况如果是确定slot不属于当前节点，redis会返回moved如果当前redis节点正在处理slot迁移，则代表此处请求对应的key暂时不在此节点，返回ask，告诉客户端本次请求重定向<span class="token comment" spellcheck="true"># 7、数据倾斜和访问倾斜的问题</span>解决办法 调整key的策略 + slot迁移迁移过程如下，完整的迁移流程：在迁移目的节点执行cluster setslot <span class="token operator">&lt;</span>slot<span class="token operator">></span> IMPORTING <span class="token operator">&lt;</span>node ID<span class="token operator">></span>命令，指明需要迁移的slot和迁移源节点。在迁移源节点执行cluster setslot <span class="token operator">&lt;</span>slot<span class="token operator">></span> MIGRATING <span class="token operator">&lt;</span>node ID<span class="token operator">></span>命令，指明需要迁移的slot和迁移目的节点。在迁移源节点执行cluster getkeysinslot获取该slot的key列表。在迁移源节点执行对每个key执行migrate命令，该命令会同步把该key迁移到目的节点。在迁移源节点反复执行cluster getkeysinslot命令，直到该slot的列表为空。在迁移源节点和目的节点执行cluster setslot <span class="token operator">&lt;</span>slot<span class="token operator">></span> NODE <span class="token operator">&lt;</span>node ID<span class="token operator">></span>，完成迁移操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、-环境信息&quot;&gt;&lt;a href=&quot;#1、-环境信息&quot; class=&quot;headerlink&quot; title=&quot;1、 环境信息&quot;&gt;&lt;/a&gt;1、 环境信息&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;centos7
redis5&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="缓存" scheme="https://brokge.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://brokge.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵高可用搭建</title>
    <link href="https://brokge.github.io/2020/02/06/redis%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://brokge.github.io/2020/02/06/redis哨兵高可用搭建/</id>
    <published>2020-02-06T12:50:24.000Z</published>
    <updated>2020-08-21T04:55:20.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis下载安装"><a href="#Redis下载安装" class="headerlink" title="Redis下载安装"></a>Redis下载安装</h1><a id="more"></a><pre class="line-numbers language-bash"><code class="language-bash">下载redishttps://redis.io/download<span class="token comment" spellcheck="true"># 下载</span><span class="token function">wget</span> http://download.redis.io/releases/redis-5.0.3.tar.gz<span class="token comment" spellcheck="true"># Installation</span><span class="token function">tar</span> xzf redis-5.0.3.tar.gz<span class="token function">cd</span> redis-5.0.3<span class="token function">make</span><span class="token comment" spellcheck="true"># 创建文件夹 </span><span class="token function">mkdir</span> /usr/local/redis/conf<span class="token function">mkdir</span> /usr/local/redis/data<span class="token function">mkdir</span> /usr/local/redis/logs<span class="token comment" spellcheck="true"># run</span>src/redis-server<span class="token comment" spellcheck="true"># warning 1 > 提示修改 linux内核参数</span><span class="token comment" spellcheck="true"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><span class="token keyword">echo</span> 1024 <span class="token operator">></span>/proc/sys/net/core/somaxconn<span class="token comment" spellcheck="true"># warn 2 > 提示如下</span><span class="token comment" spellcheck="true"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span><span class="token keyword">echo</span> <span class="token string">"vm.overcommit_memory = 1"</span> <span class="token operator">>></span> /etc/sysctl.confsysctl vm.overcommit_memory<span class="token operator">=</span>1<span class="token comment" spellcheck="true"># warning 3</span><span class="token comment" spellcheck="true"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled</span><span class="token keyword">echo</span> never <span class="token operator">></span> /sys/kernel/mm/transparent_hugepage/enabled<span class="token comment" spellcheck="true"># 云服务器要注意ip要写对，端口要开放</span><span class="token comment" spellcheck="true"># 虚拟机要注意防火墙要关闭 systemctl stop firewalld.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改</span><span class="token comment" spellcheck="true">#后台启动的意思</span>daemonize <span class="token function">yes</span>  <span class="token comment" spellcheck="true">#端口号(如果同一台服务器上启动，注意要修改为不同的端口)</span>port 6380<span class="token comment" spellcheck="true"># IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病</span>bind 0.0.0.0<span class="token comment" spellcheck="true"># 这个文件会自动生成(如果同一台服务器上启动，注意要修改为不同的端口)</span>pidfile /var/run/redis_6380.pid <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="准备三个redis服务"><a href="#准备三个redis服务" class="headerlink" title="准备三个redis服务"></a>准备三个redis服务</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、启动三个Redis</span>/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6380.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6381.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6382.conf<span class="token comment" spellcheck="true"># 2、配置为 1主2从</span>/usr/local/redis/bin/redis-cli -p 6381 slaveof 192.168.100.241 6380/usr/local/redis/bin/redis-cli -p 6382 slaveof 192.168.100.241 6380<span class="token comment" spellcheck="true"># 3、检查集群</span>/usr/local/redis/bin/redis-cli -p 6380 info Replication<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="准备哨兵配置文件"><a href="#准备哨兵配置文件" class="headerlink" title="准备哨兵配置文件"></a>准备哨兵配置文件</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置文件：sentinel.conf，在sentinel运行期间是会被动态修改的</span><span class="token comment" spellcheck="true"># sentinel如果重启时，根据这个配置来恢复其之前所监控的redis集群的状态</span><span class="token comment" spellcheck="true"># 绑定IP</span>bind 0.0.0.0<span class="token comment" spellcheck="true"># 后台运行</span>daemonize <span class="token function">yes</span><span class="token comment" spellcheck="true"># 默认yes，没指定密码或者指定IP的情况下，外网无法访问</span>protected-mode no<span class="token comment" spellcheck="true"># 哨兵的端口，客户端通过这个端口来发现redis</span>port 26380<span class="token comment" spellcheck="true"># 哨兵自己的IP，手动设定也可自动发现，用于与其他哨兵通信</span><span class="token comment" spellcheck="true"># sentinel announce-ip</span><span class="token comment" spellcheck="true"># 临时文件夹</span><span class="token function">dir</span> /tmp<span class="token comment" spellcheck="true"># 日志</span>logfile <span class="token string">"/usr/local/redis/logs/sentinel-26380.log"</span><span class="token comment" spellcheck="true"># sentinel监控的master的名字叫做mymaster,初始地址为 192.168.100.241 6380,2代表两个及以上哨兵认定为死亡，才认为是真的死亡</span>sentinel monitor mymaster 192.168.100.241 6380 2<span class="token comment" spellcheck="true"># 发送心跳PING来确认master是否存活</span><span class="token comment" spellcheck="true"># 如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了</span>sentinel down-after-milliseconds mymaster 1000<span class="token comment" spellcheck="true"># 如果在该时间（ms）内未能完成failover操作，则认为该failover失败</span>sentinel failover-timeout mymaster 3000<span class="token comment" spellcheck="true"># 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span>sentinel parallel-syncs mymaster 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="启动哨兵集群"><a href="#启动哨兵集群" class="headerlink" title="启动哨兵集群"></a>启动哨兵集群</h1><pre class="line-numbers language-bash"><code class="language-bash">/usr/local/redis/bin/redis-server /usr/local/redis/conf/sentinel-26380.conf --sentinel/usr/local/redis/bin/redis-server /usr/local/redis/conf/sentinel-26381.conf --sentinel/usr/local/redis/bin/redis-server /usr/local/redis/conf/sentinel-26382.conf --sentinel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 停掉master，主从切换过程</span>启动哨兵<span class="token punctuation">(</span>客户端通过哨兵发现Redis实例信息<span class="token punctuation">)</span>哨兵通过连接master发现主从集群内的所有实例信息哨兵监控redis实例的健康状况哨兵一旦发现master不能正常提供服务，则通知给其他哨兵当一定数量的哨兵都认为master挂了选举一个哨兵作为故障转移的执行者执行者在slave中选取一个作为新的master将其他slave重新设定为新master的从属<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="哨兵同步pubsub机制发出来的消息"><a href="#哨兵同步pubsub机制发出来的消息" class="headerlink" title="哨兵同步pubsub机制发出来的消息"></a>哨兵同步pubsub机制发出来的消息</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># https://redis.io/topics/sentinel#pubsub-messages</span>+reset-master <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当master被重置时.+slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当检测到一个slave并添加进slave列表时.+failover-state-reconf-slaves <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- Failover状态变为reconf-slaves状态时+failover-detected <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当failover发生时+slave-reconf-sent <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- sentinel发送SLAVEOF命令把它重新配置时+slave-reconf-inprog <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- slave被重新配置为另外一个master的slave，但数据复制还未发生时。+slave-reconf-done <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- slave被重新配置为另外一个master的slave并且数据复制已经与master同步时。-dup-sentinel <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 删除指定master上的冗余sentinel时 <span class="token punctuation">(</span>当一个sentinel重新启动时，可能会发生这个事件<span class="token punctuation">)</span>.+sentinel <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当master增加了一个sentinel时。+sdown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 进入SDOWN状态时<span class="token punctuation">;</span>-sdown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 离开SDOWN状态时。+odown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 进入ODOWN状态时。-odown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 离开ODOWN状态时。+new-epoch <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当前配置版本被更新时。+try-failover <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 达到failover条件，正等待其他sentinel的选举。+elected-leader <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 被选举为去执行failover的时候。+failover-state-select-slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 开始要选择一个slave当选新master时。+no-good-slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 没有合适的slave来担当新master+selected-slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 找到了一个适合的slave来担当新master+promoted-slave -- 确认成功+failover-state-reconf-slaves -- 开始对slaves进行reconfig操作+slave-reconf-sent -- 向指定的slave发送“slaveof”指令，告知此slave跟随新的master+slave-reconf-inprog -- 此slave正在执行slaveof + SYNC过程，slave收到“+slave-reconf-sent”之后将会执行slaveof操作+slave-reconf-done -- 此slave同步完成，此后leader可以继续下一个slave的reconfig操作failover-state-send-slaveof-noone <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当把选择为新master的slave的身份进行切换的时候。failover-end-for-timeout <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- failover由于超时而失败时。failover-end <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- failover成功完成,故障转移结束switch-master <span class="token operator">&lt;</span>master name<span class="token operator">></span> <span class="token operator">&lt;</span>oldip<span class="token operator">></span> <span class="token operator">&lt;</span>oldport<span class="token operator">></span> <span class="token operator">&lt;</span>newip<span class="token operator">></span> <span class="token operator">&lt;</span>newport<span class="token operator">></span> -- 当master的地址发生变化时。通常这是客户端最感兴趣的消息了。+tilt -- 进入Tilt模式。-tilt -- 退出Tilt模式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="哨兵日志分析"><a href="#哨兵日志分析" class="headerlink" title="哨兵日志分析"></a>哨兵日志分析</h1><pre class="line-numbers language-bash"><code class="language-bash">sdow <span class="token punctuation">(</span>sdown subjectively down<span class="token punctuation">)</span>odown <span class="token punctuation">(</span>objectively down<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过日志逐步分析</span>996:X 23 Nov 01:00:30.020 <span class="token comment" spellcheck="true"># +sdown master mymaster 60.205.209.106 6381</span>996:X 23 Nov 01:00:30.143 <span class="token comment" spellcheck="true"># +new-epoch 4</span>996:X 23 Nov 01:00:30.144 <span class="token comment" spellcheck="true"># +vote-for-leader 699538b978f33f677c8be471eed344b3933eca8c 4</span>996:X 23 Nov 01:00:31.111 <span class="token comment" spellcheck="true"># +odown master mymaster 60.205.209.106 6381 #quorum 3/2</span>996:X 23 Nov 01:00:31.111 <span class="token comment" spellcheck="true"># Next failover delay: I will not start a failover before Thu Nov 23 01:00:36 2017</span>996:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +config-update-from sentinel 699538b978f33f677c8be471eed344b3933eca8c 172.17.171.34 26381 @ mymaster 60.205.209.106 6381</span>996:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span>996:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6380996:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380996:X 23 Nov 01:00:32.233 <span class="token comment" spellcheck="true"># +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span>1073:X 23 Nov 01:00:30.087 <span class="token comment" spellcheck="true"># +sdown master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +odown master mymaster 60.205.209.106 6381 #quorum 3/2</span>1073:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +new-epoch 4</span>1073:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +try-failover master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.141 <span class="token comment" spellcheck="true"># +vote-for-leader 699538b978f33f677c8be471eed344b3933eca8c 4</span>1073:X 23 Nov 01:00:30.142 <span class="token comment" spellcheck="true"># 8412b6b2ac39a3d36c171590cd23cbe025517c15 voted for 8412b6b2ac39a3d36c171590cd23cbe025517c15 4</span>1073:X 23 Nov 01:00:30.144 <span class="token comment" spellcheck="true"># f8c7e052744926747ef1f31c27da4721fde3faf4 voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span>1073:X 23 Nov 01:00:30.232 <span class="token comment" spellcheck="true"># +elected-leader master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.232 <span class="token comment" spellcheck="true"># +failover-state-select-slave master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.294 <span class="token comment" spellcheck="true"># +selected-slave slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.294 * +failover-state-send-slaveof-noone slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:30.356 * +failover-state-wait-promotion slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:31.153 <span class="token comment" spellcheck="true"># +promoted-slave slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:31.153 <span class="token comment" spellcheck="true"># +failover-state-reconf-slaves master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:31.200 * +slave-reconf-sent slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:32.149 * +slave-reconf-inprog slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:32.149 * +slave-reconf-done slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:32.220 <span class="token comment" spellcheck="true"># -odown master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:32.220 <span class="token comment" spellcheck="true"># +failover-end master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:32.220 <span class="token comment" spellcheck="true"># +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span>1073:X 23 Nov 01:00:32.220 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63801073:X 23 Nov 01:00:32.220 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 63801073:X 23 Nov 01:00:33.227 <span class="token comment" spellcheck="true"># +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span>1009:X 23 Nov 01:00:30.039 <span class="token comment" spellcheck="true"># +sdown master mymaster 60.205.209.106 6381</span>1009:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +odown master mymaster 60.205.209.106 6381 #quorum 2/2</span>1009:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +new-epoch 4</span>1009:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +try-failover master mymaster 60.205.209.106 6381</span>1009:X 23 Nov 01:00:30.142 <span class="token comment" spellcheck="true"># +vote-for-leader 8412b6b2ac39a3d36c171590cd23cbe025517c15 4</span>1009:X 23 Nov 01:00:30.142 <span class="token comment" spellcheck="true"># 699538b978f33f677c8be471eed344b3933eca8c voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span>1009:X 23 Nov 01:00:30.144 <span class="token comment" spellcheck="true"># f8c7e052744926747ef1f31c27da4721fde3faf4 voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span>1009:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +config-update-from sentinel 699538b978f33f677c8be471eed344b3933eca8c 172.17.171.34 26381 @ mymaster 60.205.209.106 6381</span>1009:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span>1009:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63801009:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 63801009:X 23 Nov 01:00:32.258 <span class="token comment" spellcheck="true"># +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据一致性的处理办法之一</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 这些配置仅当redis为master时才有效</span><span class="token comment" spellcheck="true"># 当master不符合这些条件时，它将停止对外的服务。这种场景主要是用于master在网络上被孤立了。</span>min-slaves-to-write 1min-slaves-max-lag 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis下载安装&quot;&gt;&lt;a href=&quot;#Redis下载安装&quot; class=&quot;headerlink&quot; title=&quot;Redis下载安装&quot;&gt;&lt;/a&gt;Redis下载安装&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="缓存" scheme="https://brokge.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Redis" scheme="https://brokge.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://brokge.github.io/2020/01/08/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://brokge.github.io/2020/01/08/原型模式/</id>
    <published>2020-01-08T06:29:19.000Z</published>
    <updated>2020-08-21T05:01:57.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>原型模式(Prototype  Pattern)：</strong> 使用原型实例指定创建对象的种类，并且通过克隆拷贝的方式利用原型实例创建新的对象。原型模式是一种对象创建型模式。</p><p>通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p><a id="more"></a><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1-通用实现方法："><a href="#1-通用实现方法：" class="headerlink" title="1. 通用实现方法："></a>1. 通用实现方法：</h3><p>定义 Prototype 接口 和 clone() 方法。<br>原型对象继承其接口，实现clone 方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Prototype</span><span class="token punctuation">{</span>   Prototype  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">implements</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span><span class="token keyword">private</span> String  attr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//成员属性</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAttr</span><span class="token punctuation">(</span>String attr<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>attr <span class="token operator">=</span> attr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getAttr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>attr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//克隆方法</span><span class="token keyword">public</span> Prototype <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//创建新对象</span>    Prototype prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     prototype<span class="token punctuation">.</span><span class="token function">setAttr</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> prototype<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方通过下列方法，获得原型实例并得到克隆对象。 </p><pre class="line-numbers language-java"><code class="language-java">Prototype obj1  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span><span class="token function">setAttr</span><span class="token punctuation">(</span><span class="token string">"Sunny"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Prototype obj2  <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-Java-语言提供的-clone-方法"><a href="#2-Java-语言提供的-clone-方法" class="headerlink" title="2. Java 语言提供的 clone 方法"></a>2. Java 语言提供的 clone 方法</h3><p>Java类都继承自java.lang.Object。事实上，Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。我们可以直接利用Object类的clone()方法，具体步骤如下：</p><ol><li>在派生类中覆盖基类的clone()方法，并声明为public；</li><li>在派生类的clone()方法中，调用super.clone()；</li><li>派生类需实现Cloneable接口。</li></ol><p>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</p><p>需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">implements</span>  <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> Prototype  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    　　Object object <span class="token operator">=</span> null<span class="token punctuation">;</span>    　　<span class="token keyword">try</span> <span class="token punctuation">{</span>    　　　　　object <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    　　<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>    　　　　　System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Not support cloneable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    　　<span class="token punctuation">}</span>    　　<span class="token keyword">return</span> <span class="token punctuation">(</span>Prototype <span class="token punctuation">)</span>object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方：</p><pre class="line-numbers language-java"><code class="language-java">Prototype obj1  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Prototype obj2  <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Java 语言中的clone()方法满足：</p><p>(1) 对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</p><p>(2) 对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</p><p>(3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p><h2 id="浅克隆、深克隆"><a href="#浅克隆、深克隆" class="headerlink" title="浅克隆、深克隆"></a>浅克隆、深克隆</h2><p>通过 Java 的clone 方式可以实现原型模式，但是通过深克隆实现还是浅克隆实现，所达到的结果是不一样的。因为在Java语言中，<strong>数据类型</strong>分为<strong>值类型</strong>（基本数据类型）和<strong>引用类型</strong>，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。</p><h3 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1. 浅克隆"></a>1. 浅克隆</h3><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p><p>简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/java%20%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86-%E6%B5%85.png" alt="浅克隆"></p><h3 id="2-深克隆"><a href="#2-深克隆" class="headerlink" title="2. 深克隆"></a>2. 深克隆</h3><p>深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。</p><p>简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制</p><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/java%20%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86.png" alt="深克隆"></p><ol><li>实现深克隆方法：序列化(Serialization)</li></ol><blockquote><p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">WeeklyLog</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Attachment attachment<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String date<span class="token punctuation">;</span>    <span class="token keyword">private</span> String content<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAttachment</span><span class="token punctuation">(</span>Attachment attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>attachment  <span class="token operator">=</span> attachment<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDate</span><span class="token punctuation">(</span>String date<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> date<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContent</span><span class="token punctuation">(</span>String content<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Attachment <span class="token function">getAttachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>attachment<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span><span class="token punctuation">(</span>String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//使用序列化技术实现深克隆</span>    <span class="token keyword">public</span> WeeklyLog <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> OptionalDataException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将对象写入流中</span>        ByteArrayOutputStream bao<span class="token operator">=</span><span class="token keyword">new</span>  <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectOutputStream oos<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bao<span class="token punctuation">)</span><span class="token punctuation">;</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//将对象从流中取出</span>        ByteArrayInputStream bis<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bao<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectInputStream ois<span class="token operator">=</span><span class="token keyword">new</span>  <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>WeeklyLog<span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>原型模式的主要优点如下：</li></ul><p>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p><p>(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p><p>(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p><p>(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p><ul><li>原型模式的主要缺点如下：</li></ul><p>(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p><p>(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p><ul><li>在以下情况下可以考虑使用原型模式：</li></ul><p>(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</p><p>(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</p><p>(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原型模式(Prototype  Pattern)：&lt;/strong&gt; 使用原型实例指定创建对象的种类，并且通过克隆拷贝的方式利用原型实例创建新的对象。原型模式是一种对象创建型模式。&lt;/p&gt;
&lt;p&gt;通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
      <category term="设计模式" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
