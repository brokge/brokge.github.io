<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玉蘇子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yusuzi.cn/"/>
  <updated>2022-01-12T14:57:44.899Z</updated>
  <id>http://www.yusuzi.cn/</id>
  
  <author>
    <name>brokge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 主从配置问题汇总</title>
    <link href="http://www.yusuzi.cn/2021/06/05/MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://www.yusuzi.cn/2021/06/05/MySQL主从配置问题汇总/</id>
    <published>2021-06-05T15:40:00.000Z</published>
    <updated>2022-01-12T14:57:44.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、主从配置启动错误"><a href="#一、主从配置启动错误" class="headerlink" title="一、主从配置启动错误"></a>一、主从配置启动错误</h1><h2 id="ERROR-1872-HY000-Slave-failed-to-initialize-relay-log-info-structure-from-the-repository"><a href="#ERROR-1872-HY000-Slave-failed-to-initialize-relay-log-info-structure-from-the-repository" class="headerlink" title="ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository"></a>ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repository</h2><p>解决方法：</p><pre><code>mysql&gt; start slave;ERROR 1872 (HY000): Slave failed to initialize relay log info structure from the repositorymysql&gt; reset slave;Query OK, 0 rows affected (0.04 sec)</code></pre><h3 id="reset-slave"><a href="#reset-slave" class="headerlink" title="reset slave"></a><code>reset slave</code></h3><p>可以使用Mysql命令reset slave重置slave。</p><p>reset slave干的那些事：</p><ol><li>删除<code>slave_master_info</code> ，<code>slave_relay_log_info</code>两个表中数据；</li><li>删除所有<code>relay log</code>文件，并重新创建新的<code>relay log</code>文件；</li><li>不会改变<code>gtid_executed</code> 或者 <code>gtid_purged</code>的值</li></ol><h2 id="跳过错误"><a href="#跳过错误" class="headerlink" title="跳过错误"></a>跳过错误</h2><pre><code>mysql&gt;slave stop;mysql&gt;SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1  #跳过一个事务 多个就改变数字。mysql&gt;slave startmysql&gt; show slave status\G #查看主从状态；</code></pre><h3 id="配置跳过指定错误"><a href="#配置跳过指定错误" class="headerlink" title="配置跳过指定错误"></a>配置跳过指定错误</h3><p>从服务器上配置</p><pre><code>vim my.cnfslave-skip-errors=1032,1062 #跳过指定error no类型的错误slave-skip-errors=all #跳过所有错误</code></pre><h2 id="批量-dump-方式"><a href="#批量-dump-方式" class="headerlink" title="批量 dump 方式"></a>批量 dump 方式</h2><h3 id="常规方式："><a href="#常规方式：" class="headerlink" title="常规方式："></a>常规方式：</h3><ul><li>备份并压缩<pre><code>mysqldump -uusername -ppassword dbname | gzip &gt; /data/wwwroot/www/dbname.sql.gz</code></pre></li><li>解压并还原<pre><code>gunzip &lt; /root/dbname.sql.gz | mysql -uusernameb -ppasswordb dbnamenew</code></pre><h3 id="最优方式"><a href="#最优方式" class="headerlink" title="最优方式"></a>最优方式</h3>保证两台机器能互相访问。<pre><code>mysqldump --default-character-set=utf8mb4 --host=127.0.0.1 -uusername -ppassword --opt dbname | mysql --host=127.0.0.2 -uusernameb -ppasswordb --default-character-set=utf8mb4 -C dbnamenew</code></pre></li></ul><h1 id="二、同步过程中最常见的3种情况"><a href="#二、同步过程中最常见的3种情况" class="headerlink" title="二、同步过程中最常见的3种情况"></a>二、同步过程中最常见的3种情况</h1><p>这3种情况是在HA切换时，由于是异步复制，且sync_binlog=0，会造成一小部分binlog没接收完导致同步报错。</p><h3 id="第一种：在master上删除一条记录，而slave上找不到。"><a href="#第一种：在master上删除一条记录，而slave上找不到。" class="headerlink" title="第一种：在master上删除一条记录，而slave上找不到。"></a>第一种：在master上删除一条记录，而slave上找不到。</h3><pre><code>Last_SQL_Error: Could not execute Delete_rows event on table hcy.t1; Can&#39;t find record in &#39;t1&#39;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&#39;s master log mysql-bin.000006, end_log_pos 254&#39;</code></pre><ul><li>解决方法：</li></ul><p>由于master要删除一条记录，而slave上找不到故报错，这种情况主上都将其删除了，那么从机可以直接跳过。可用命令：</p><pre><code>stop slave;set global sql_slave_skip_counter=1;start slave;</code></pre><p>如果这种情况很多，可用我写的一个脚本skip_error_replcation.sh，默认跳过10个错误（只针对这种情况才跳，其他情况输出错误结果，等待处理），这个脚本是参考maakit工具包的mk-slave-restart原理用shell写的，功能上定义了一些自己的东西，不是无论什么错误都一律跳过。）</p><h3 id="第二种：主键重复。在slave已经有该记录，又在master上插入了同一条记录。"><a href="#第二种：主键重复。在slave已经有该记录，又在master上插入了同一条记录。" class="headerlink" title="第二种：主键重复。在slave已经有该记录，又在master上插入了同一条记录。"></a>第二种：主键重复。在slave已经有该记录，又在master上插入了同一条记录。</h3><pre><code>Last_SQL_Error: Could not execute Write_rows event on table hcy.t1; Duplicate entry &#39;2&#39; for key &#39;PRIMARY&#39;, Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; the event&#39;s master log mysql-bin.000006, end_log_pos 924</code></pre><ul><li>解决方法：</li></ul><p>在slave上用desc hcy.t1; 先看下表结构：</p><pre><code>mysql&gt; desc hcy.t1;+-------+---------+------+-----+---------+-------+| Field | Type  | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| id  | int(11) | NO  | PRI | 0    |    | | name | char(4) | YES |   | NULL  |    | +-------+---------+------+-----+---------+-------+</code></pre><p>删除重复的主键</p><pre><code>mysql&gt; delete from t1 where id=2;Query OK, 1 row affected (0.00 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.00 sec)mysql&gt; show slave status\G;……Slave_IO_Running: YesSlave_SQL_Running: Yes……mysql&gt; select * from t1 where id=2;</code></pre><p>在master上和slave上再分别确认一下。</p><h3 id="第三种：在master上更新一条记录，而slave上找不到，丢失了数据。"><a href="#第三种：在master上更新一条记录，而slave上找不到，丢失了数据。" class="headerlink" title="第三种：在master上更新一条记录，而slave上找不到，丢失了数据。"></a>第三种：在master上更新一条记录，而slave上找不到，丢失了数据。</h3><pre><code>Last_SQL_Error: Could not execute Update_rows event on table hcy.t1;Can&#39;t find record in &#39;t1&#39;, Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event&#39;s master log mysql-bin.000010, end_log_pos 263</code></pre><ul><li>解决方法：</li></ul><p>在master上，用mysqlbinlog 分析下出错的binlog日志在干什么。</p><pre><code>/usr/local/mysql/bin/mysqlbinlog --no-defaults -v -v --base64-output=DECODE-ROWS mysql-bin.000010 | grep -A &#39;10&#39; 794#120302 12:08:36 server id 22 end_log_pos 794 Update_rows: table id 33 flags: STMT_END_F### UPDATE hcy.t1### WHERE###  @1=2 /* INT meta=0 nullable=0 is_null=0 */###  @2=&#39;bbc&#39; /* STRING(4) meta=65028 nullable=1 is_null=0 */### SET###  @1=2 /* INT meta=0 nullable=0 is_null=0 */###  @2=&#39;BTV&#39; /* STRING(4) meta=65028 nullable=1 is_null=0 */# at 794#120302 12:08:36 server id 22 end_log_pos 821 Xid = 60COMMIT/*!*/;DELIMITER ;# End of log fileROLLBACK /* added by mysqlbinlog */;/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</code></pre><p>在slave上，查找下更新后的那条记录，应该是不存在的。</p><p>mysql&gt; select * from t1 where id=2;<br>Empty set (0.00 sec)</p><p>然后再到master查看</p><pre><code>mysql&gt; select * from t1 where id=2;+----+------+| id | name |+----+------+| 2 | BTV | +----+------+1 row in set (0.00 sec)</code></pre><p>把丢失的数据在slave上填补，然后跳过报错即可。</p><pre><code>mysql&gt; insert into t1 values (2,&#39;BTV&#39;);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1 where id=2;  +----+------+| id | name |+----+------+| 2 | BTV | +----+------+1 row in set (0.00 sec)mysql&gt; stop slave ;set global sql_slave_skip_counter=1;start slave;Query OK, 0 rows affected (0.01 sec)Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; show slave status\G;…… Slave_IO_Running: Yes Slave_SQL_Running: Yes……</code></pre><h3 id="异步半同步区别"><a href="#异步半同步区别" class="headerlink" title="异步半同步区别"></a>异步半同步区别</h3><ul><li><p>异步复制<br>简单的说就是master把binlog发送过去，不管slave是否接收完，也不管是否执行完，这一动作就结束了.</p></li><li><p>半同步复制<br>简单的说就是master把binlog发送过去，slave确认接收完，但不管它是否执行完，给master一个信号我这边收到了，这一动作就结束了。（谷歌写的代码，5.5上正式应用。）</p></li></ul><p>异步的劣势<br>当master上写操作繁忙时，当前POS点例如是10，而slave上IO_THREAD线程接收过来的是3，此时master宕机，会造成相差7个点未传送到slave上而数据丢失。</p><h3 id="特殊的情况"><a href="#特殊的情况" class="headerlink" title="特殊的情况"></a>特殊的情况</h3><p>slave的中继日志relay-bin损坏。</p><pre><code>Last_SQL_Error: Error initializing relay log position: I/O error reading the header from the binary logLast_SQL_Error: Error initializing relay log position: Binlog has bad magic number; It&#39;s not a binary log file that can be used by this version of MySQL</code></pre><p>这种情况SLAVE在宕机，或者非法关机，例如电源故障、主板烧了等，造成中继日志损坏，同步停掉。</p><p>人为失误需谨慎：多台slave存在重复server-id<br>这种情况同步会一直延时，永远也同步不完，error错误日志里一直出现上面两行信息。解决方法就是把server-id改成不一致即可。</p><pre><code>Slave: received end packet from server, apparent master shutdown:Slave I/O thread: Failed reading log event, reconnecting to retry, log &#39;mysql-bin.000012&#39; at postion 106</code></pre><p>手工修复</p><p>解决方法：找到同步的binlog和POS点，然后重新做同步，这样就可以有新的中继日值了。</p><p>例子：</p><pre><code>mysql&gt; show slave status\G;*************************** 1. row ***************************       Master_Log_File: mysql-bin.000010     Read_Master_Log_Pos: 1191        Relay_Log_File: vm02-relay-bin.000005        Relay_Log_Pos: 253    Relay_Master_Log_File: mysql-bin.000010       Slave_IO_Running: Yes      Slave_SQL_Running: No       Replicate_Do_DB:      Replicate_Ignore_DB:       Replicate_Do_Table:     Replicate_Ignore_Table:    Replicate_Wild_Do_Table:  Replicate_Wild_Ignore_Table:           Last_Errno: 1593          Last_Error: Error initializing relay log position: I/O error reading the header from the binary log         Skip_Counter: 1     Exec_Master_Log_Pos: 821</code></pre><ol><li><p>Slave_IO_Running ：接收master的binlog信息       </p></li><li><p>Master_Log_File</p></li><li><p>Read_Master_Log_Pos</p></li><li><p>Slave_SQL_Running：执行写操作</p></li><li><p>Relay_Master_Log_File</p></li><li><p>Exec_Master_Log_Pos</p></li></ol><p>以执行写的binlog和POS点为准。</p><pre><code>Relay_Master_Log_File: mysql-bin.000010Exec_Master_Log_Pos: 821mysql&gt; stop slave;Query OK, 0 rows affected (0.01 sec)mysql&gt; CHANGE MASTER TO MASTER_LOG_FILE=&#39;mysql-bin.000010&#39;,MASTER_LOG_POS=821;Query OK, 0 rows affected (0.01 sec)mysql&gt; start slave;Query OK, 0 rows affected (0.00 sec)mysql&gt; show slave status\G;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、主从配置启动错误&quot;&gt;&lt;a href=&quot;#一、主从配置启动错误&quot; class=&quot;headerlink&quot; title=&quot;一、主从配置启动错误&quot;&gt;&lt;/a&gt;一、主从配置启动错误&lt;/h1&gt;&lt;h2 id=&quot;ERROR-1872-HY000-Slave-failed-to-
      
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.yusuzi.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从配置</title>
    <link href="http://www.yusuzi.cn/2021/03/05/MySQL%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.yusuzi.cn/2021/03/05/MySQL主从配置/</id>
    <published>2021-03-05T15:40:00.000Z</published>
    <updated>2022-01-12T14:56:27.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-MySQL主从同步的作用"><a href="#1-MySQL主从同步的作用" class="headerlink" title="1. MySQL主从同步的作用"></a>1. MySQL主从同步的作用</h2><ol><li><p>可以作为备份机制，相当于热备份</p></li><li><p>可以用来做读写分离，均衡数据库负载</p><a id="more"></a><h2 id="2-项目场景"><a href="#2-项目场景" class="headerlink" title="2. 项目场景"></a>2. 项目场景</h2></li><li><p>主服务器10.10.20.111，其中已经有数据库且库中有表、函数以及存储过程</p></li><li><p>从服务器10.10.20.116，空的啥也没有</p></li></ol><h2 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3. 准备工作"></a>3. 准备工作</h2><p>主从服务器需要有相同的初态</p><ol><li><p>将主服务器要同步的数据库枷锁，避免同步时数据发生改变</p><pre class="line-numbers language-sh"><code class="language-sh">mysql>use db;mysql>flush tables with read lock;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>将主服务器数据库中数据导出</p><pre><code>mysql&gt;mysqldump -uroot -pxxxx db &gt; db.sql;</code></pre><p>这个命令是导出数据库中所有表结构和数据，如果要导出函数和存储过程的话使用</p><pre><code>mysql&gt;mysqldump -R -ndt db -uroot -pxxxx &gt; db.sql</code></pre></li><li><p>备份完成后，解锁主服务器数据库</p><pre><code>mysql&gt;unlock tables;</code></pre></li><li><p>将初始数据导入从服务器数据库</p><pre><code>mysql&gt;create database db;mysql&gt;use db;mysql&gt;source db.sql;</code></pre><p>好了，现在主从服务器拥有一样的初态了</p></li></ol><h2 id="4-主服务器配置"><a href="#4-主服务器配置" class="headerlink" title="4. 主服务器配置"></a>4. 主服务器配置</h2><ol><li>修改MySQL配置<pre><code>vi /etc/my.cnf</code></pre>在[mysqld]中添加<pre><code>#主数据库端ID号server_id = 1           #开启二进制日志                  log-bin = mysql-bin    #需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可                  binlog-do-db = db # binlog-do-db = db2# binlog-do-db = db3#将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中                 log-slave-updates                        #控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失) sync_binlog = 1                    #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突auto_increment_offset = 1           #这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突auto_increment_increment = 1            #二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除  expire_logs_days = 7                    #将函数复制到slave  log_bin_trust_function_creators = 1     </code></pre></li><li>重启MySQL，创建允许从服务器同步数据的账户<pre><code>#创建slave账号account，密码123456mysql&gt;grant replication slave on *.* to &#39;account&#39;@&#39;10.10.20.116&#39; identified by &#39;123456&#39;;#更新数据库权限mysql&gt;flush privileges;</code></pre></li><li>查看主服务器状态<br>```<br>mysql&gt;show master status\G;</li></ol><p>*<strong><strong><strong>****</strong></strong></strong> 1. row <strong><strong><strong>****</strong></strong></strong><br>            File: mysql-bin.000033 #当前记录的日志<br>        Position: 337523 #日志中记录的位置<br>    Binlog_Do_DB:<br>Binlog_Ignore_DB: </p><pre><code>执行完这个步骤后不要再操作主服务器数据库了，防止其状态值发生变化## 5. 从服务器配置1. 修改MySQL配置</code></pre><p>vi /etc/my.cnf</p><pre><code>在[mysqld]中添加</code></pre><p>server_id = 2<br>log-bin = mysql-bin<br>log-slave-updates<br>sync_binlog = 0<br>#log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下在事务提交的时候，不会主动触发写入磁盘的操作<br>innodb_flush_log_at_trx_commit = 0<br>#指定slave要复制哪个库,如果是多个库则重复设置此项<br>replicate-do-db = db         </p><h1 id="replicate-do-db-db1"><a href="#replicate-do-db-db1" class="headerlink" title="replicate-do-db = db1"></a>replicate-do-db = db1</h1><h1 id="replicate-do-db-db2"><a href="#replicate-do-db-db2" class="headerlink" title="replicate-do-db = db2"></a>replicate-do-db = db2</h1><p>#MySQL主从复制的时候，当Master和Slave之间的网络中断，但是Master和Slave无法察觉的情况下（比如防火墙或者路由问题）。Slave会等待slave_net_timeout设置的秒数后，才能认为网络出现故障，然后才会重连并且追赶这段时间主库的数据<br>slave-net-timeout = 60<br>log_bin_trust_function_creators = 1</p><pre><code>2. 执行同步命令&gt; 执行同步命令，设置主服务器ip，同步账号密码，同步位置</code></pre><p>mysql&gt; show binlog events in ‘mysql-bin.000033’;//查看EventType对应的 position<br>mysql&gt;change master to master_host=’10.10.20.111’,master_user=’account’,master_password=’123456’,master_log_file=’mysql-bin.000033’,master_log_pos=337523;<br>#开启同步功能<br>mysql&gt;start slave;</p><pre><code>3. 查看从服务器状态,同步状态</code></pre><p>mysql&gt;show slave status\G;</p><p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>* 1. row *</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>               Slave_IO_State: Waiting for master to send event<br>                  Master_Host: 10.10.20.111<br>                  Master_User: account<br>                  Master_Port: 3306<br>                Connect_Retry: 60<br>              Master_Log_File: mysql-bin.000033<br>          Read_Master_Log_Pos: 337523<br>               Relay_Log_File: db2-relay-bin.000002<br>                Relay_Log_Pos: 337686<br>        Relay_Master_Log_File: mysql-bin.000033<br>             Slave_IO_Running: Yes<br>            Slave_SQL_Running: Yes<br>              Replicate_Do_DB:<br>          Replicate_Ignore_DB:<br>          …</p><pre><code>Slave_IO_Running及Slave_SQL_Running进程必须正常运行，即Yes状态，否则说明同步失败。若失败查看mysql错误日志中具体报错详情来进行问题定位最后可以去主服务器上的数据库中创建表或者更新表数据来测试同步</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-MySQL主从同步的作用&quot;&gt;&lt;a href=&quot;#1-MySQL主从同步的作用&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL主从同步的作用&quot;&gt;&lt;/a&gt;1. MySQL主从同步的作用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可以作为备份机制，相当于热备份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以用来做读写分离，均衡数据库负载&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.yusuzi.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Github pages 多域名映射</title>
    <link href="http://www.yusuzi.cn/2020/09/08/github-pages-%E5%A4%9A%E5%9F%9F%E5%90%8D%E6%98%A0%E5%B0%84/"/>
    <id>http://www.yusuzi.cn/2020/09/08/github-pages-多域名映射/</id>
    <published>2020-09-08T07:53:43.000Z</published>
    <updated>2020-09-08T07:59:16.867Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要明确的是，github 规则是一个 repo 只能有一个域名映射。</p><a id="more"></a><p>那有人会说了，这不是白瞎了吗？</p><p>不瞎，来看原理。</p><h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h1><p>之所以多域名映射，其中原理就是 每个 repo 对应一个自定义域名,但把一份博客内容，上传到两个 repo。</p><h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2. 步骤"></a>2. 步骤</h1><ol><li>我们建立一个博客资源。</li><li>然后在github 建立多个 repo。</li><li>在 hexo _config.yml文件中对 deploy 标签的配置中这样配置<pre class="line-numbers language-yml"><code class="language-yml"># Deployment## Docs: https://hexo.io/docs/deployment.html# 集合的写法，发布到多个不同的仓库deploy:- type: git repo: git@github.com:brokge/brokge.github.io.git branch: master - type: git repo: git@github.com:brokge/yusuzi.git branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>然后在不同的 repo 中，设置不同的域名。</li></ol><p>最后来看看，下面笔者的两个 repo 对应的设置<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C5645658CA474EF0A33150637B69B289.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/EB5AA8CE2AF54BC69F9F0E5751B2B0F2.jpg" alt="image"></p><p>欧拉，两个域名是不是都可以访问  <a href="http://www.42011024.xyz/">http://www.42011024.xyz/</a>   <a href="http://www.yusuzi.cn/">http://www.yusuzi.cn</a></p><h1 id="3-分享"><a href="#3-分享" class="headerlink" title="3. 分享"></a>3. 分享</h1><p>最后分享一个一条命令，打包并上传的脚本</p><pre class="line-numbers language-sh"><code class="language-sh">#!/usr/bin/sshhexo cleanhexo generatetouch ./public/.nojekyll#echo "blog.42011024.xyz">./public/CNAMEecho "www.yusuzi.cn\nwww.42011024.xyz">./public/CNAMEhexo deploygit add .git commit -a -m 'deploy blog' git push -u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发布的时候，直接直接执行  <code>sh deploy.sh</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先需要明确的是，github 规则是一个 repo 只能有一个域名映射。&lt;/p&gt;
    
    </summary>
    
      <category term="经验" scheme="http://www.yusuzi.cn/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>nacos 导入配置数据不合法</title>
    <link href="http://www.yusuzi.cn/2020/09/07/nacos-%E5%AF%BC%E5%85%A5%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%90%88%E6%B3%95/"/>
    <id>http://www.yusuzi.cn/2020/09/07/nacos-导入配置数据不合法/</id>
    <published>2020-09-07T13:05:35.000Z</published>
    <updated>2020-09-07T13:10:47.154Z</updated>
    
    <content type="html"><![CDATA[<p>使用nacos导入配置文件报错：<code>未读取到合法数据，请检查导入的数据文件。</code></p><a id="more"></a><h1 id="1-Nacos控制台-导入配置-失败原因分析"><a href="#1-Nacos控制台-导入配置-失败原因分析" class="headerlink" title="1. Nacos控制台 导入配置 失败原因分析"></a>1. Nacos控制台 导入配置 失败原因分析</h1><p>使用nacos导入配置文件报错：未读取到合法数据，请检查导入的数据文件。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/AA7B44703F6A4A5992EBC2CF822E6448.jpg" alt="image"></p><h2 id="原因1"><a href="#原因1" class="headerlink" title="原因1:"></a>原因1:</h2><p>对比在naocs server中导出的文件，发现是少了一级目录。需要创建一个文件夹，名称为组的名称。<br>因为在nacos上传文件时是可以选择命名空间的，但是不会选择组，所以nacos server识别报错了。</p><p>如果是在 mac 平台，你会发现，通过上面的操作之后，还是会报错，因为什么呢？</p><h2 id="原因2"><a href="#原因2" class="headerlink" title="原因2:"></a>原因2:</h2><p>打开mac下的zip文件，发现里面有一个 .DS_store的文件，这个文件nacos读取的时候，会出现异常，所以需要清除 .DS_store 文件，具体步骤</p><ol><li>创建 分组 默认为 DEFAULT_GROUP</li><li>删除 .DS_STORE（mac平台需要，其他平台可以忽略）</li><li>压缩成zip文件</li></ol><h1 id="2-Mac-下删除zip-中的-DS-STORE-方法"><a href="#2-Mac-下删除zip-中的-DS-STORE-方法" class="headerlink" title="2. Mac 下删除zip 中的.DS_STORE 方法"></a>2. Mac 下删除zip 中的.DS_STORE 方法</h1><p>方便起见，通过 Automator 创建<code>快速操作</code> </p><p>具体配置如下：<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/4372AC4B0FA64F0E851DEB3CD4BC8A34.jpg" alt="image"><br>执行的 shell 命令</p><pre><code>for f in &quot;$@&quot;do    fileType=$(file -bI &quot;$f&quot;)    if [[ $fileType =~ &quot;application/zip*&quot; ]]; then        zip -d &quot;$f&quot; \*__MACOSX\*  || true        zip -d &quot;$f&quot; \*.DS_Store\* || true    fidone</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A082302210DA408399F295998D6B0F78.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用nacos导入配置文件报错：&lt;code&gt;未读取到合法数据，请检查导入的数据文件。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="微服务" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
      <category term="Spring Cloud" scheme="http://www.yusuzi.cn/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring cloud Feign原理分析</title>
    <link href="http://www.yusuzi.cn/2020/09/04/Spring-cloud-Feign%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.yusuzi.cn/2020/09/04/Spring-cloud-Feign实践/</id>
    <published>2020-09-04T02:46:41.000Z</published>
    <updated>2020-09-04T03:34:51.060Z</updated>
    
    <content type="html"><![CDATA[<p>Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求。Spring Cloud引入 Feign并且集成了Ribbon实现客户端负载均衡调用。<br>集成 Hystrix 实现客户端限流降级。<br>封装了Http调用流程，更适合面向接口化的变成习惯。</p><a id="more"></a><p>Spring Cloud  对 Feign 的增强和改造：</p><ol><li>将 Spring MVC 的注解与 Feign 客户端的定义进行了结合。</li><li>支持使用 Spring Web 中的 HttpMessageConverters对请求和响应进行编码工作。</li></ol><h1 id="1-集成示例"><a href="#1-集成示例" class="headerlink" title="1. 集成示例"></a>1. 集成示例</h1><ol><li><p>引入 SpringCloud关于 Feign的相关依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动类上添加注解 @EnableFeignClients</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringCloudFeignApplication</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringCloudFeignApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建接口 interface,并使用 @FeignClient 注解标注</p></li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token comment" spellcheck="true">//fallback 在demo中可以去掉</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"userServer"</span><span class="token punctuation">,</span>fallback <span class="token operator">=</span> UserServerFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HelloDemoService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/user"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Body</span><span class="token punctuation">(</span><span class="token string">"%7B\"name\":\"{name}\"%7D"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/test-user"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>POST<span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">testName</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>接口调用</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    HelloDemoService helloDemoService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"index"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> helloDemoService<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/find-user"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和普通方法一样调用</span>        <span class="token keyword">return</span> helloDemoService<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/set-user"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">setUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和普通的方法一样调用</span>        <span class="token keyword">return</span> helloDemoService<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><p>新创建一个 module </p><pre class="line-numbers language-xml"><code class="language-xml">spring:application: name: userServer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>在 userServer 中创建一个 controller</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token keyword">public</span> String <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>     Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> timeOut <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程休眠时间是:"</span><span class="token operator">+</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">;</span>     Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">;</span>     String str <span class="token operator">=</span>  <span class="token string">"这是服务端1返回的应答"</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span> String name<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/find-user"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动 userServer 和 集成 Feign 的 Server.请求 <code>localhost:8080\index</code></p></li></ol><h1 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h1><h2 id="1-内部操作流程"><a href="#1-内部操作流程" class="headerlink" title="1. 内部操作流程"></a>1. 内部操作流程</h2><p>整体流程请求<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/33C8169A6EA1442C90CCC83C42CF3CFE.jpg" alt="image"></p><p>在微服务启动时，Feign 会进行包扫描，对加 @FeignClient 注解的接口，按照注解的规则，创建远程接口的本地JDK Proxy代理实例。然后，将这些本地 Proxy 代理实例，注入到Spring IOC容器中。当远程接口的方法被调用，由 Proxy 代理实例去完成对其他服务真正的远程访问（也就是 http 请求），并且返回结果。</p><p>内部流程大概就如上所诉，原理非常简单，但是在 Feign 内部实现却很复杂。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3A6A4AD8528643E68BED64B25ECCFA7E.jpg" alt="image"><br>复杂的地方主要包含以下几个方面：</p><ol><li>采用 动态代理(JDK proxy).</li><li>请求对象的转码和返回对象的解码</li><li>不同 http 框架的支持。</li><li>针对 断路器的支持(hystrix)。</li><li>针对 负载均衡的支持(Ribbon)。</li><li>针对 日志的处理。</li></ol><p>下面针对以上几个方面分别说明</p><h2 id="2-1-JDK-Proxy代理"><a href="#2-1-JDK-Proxy代理" class="headerlink" title="2.1 JDK Proxy代理"></a>2.1 JDK Proxy代理</h2><p>远程接口的本地JDK Proxy代理实例，有以下特点：</p><ol><li><p>我们通过 添加@EnableFeignClients 注解，让 spring 开启 对@FeignClient 注解的扫描，并生成对应的代理实例（远程调用接口）</p></li><li><p>Proxy代理实例，在内部进行HTTP请求的封装，以及发送HTTP 请求；</p></li><li><p>Proxy代理实例，能处理远程HTTP请求的响应，并且完成结果的解码，然后返回给调用者。</p></li></ol><p>在 FeignClientsRegistrar.java 中</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">registerFeignClient</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">,</span>AnnotationMetadata annotationMetadata<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String className <span class="token operator">=</span> annotationMetadata<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BeanDefinitionBuilder definition <span class="token operator">=</span> BeanDefinitionBuilder                <span class="token punctuation">.</span><span class="token function">genericBeanDefinition</span><span class="token punctuation">(</span>FeignClientFactoryBean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>本质通过 FeignClientFactoryBean.java 生成代理对象，并交给spring管理。</strong><br>下面让我们来看看 <code>FeginClientFactoryBean.java</code>关键代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    FeignContext context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>FeignContext<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Feign<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token function">feign</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/***省略部分代码***/</span>    Targeter targeter <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> Targeter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> targeter<span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> builder<span class="token punctuation">,</span> context<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">HardCodedTarget</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>getTarget() 调用目标 <code>targeter.target（）</code>方法，值得注意的是在 Feign 中有两种实现，<code>DefaultTargeter</code> 和 <code>HystrixTrgeter</code> 两种实现，其中 <code>HystrixTargeter</code>实现相对复杂，但最终都调用了<code>Feign.Builder</code> 的 <code>target（）</code>方法。</p><p>以下为 <code>Feign.Builder</code>的 关键代码：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">target</span><span class="token punctuation">(</span>Target<span class="token operator">&lt;</span>T<span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> Feign <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SynchronousMethodHandler<span class="token punctuation">.</span>Factory synchronousMethodHandlerFactory <span class="token operator">=</span>          <span class="token keyword">new</span> <span class="token class-name">SynchronousMethodHandler<span class="token punctuation">.</span>Factory</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> retryer<span class="token punctuation">,</span> requestInterceptors<span class="token punctuation">,</span> logger<span class="token punctuation">,</span>              logLevel<span class="token punctuation">,</span> decode404<span class="token punctuation">,</span> closeAfterDecode<span class="token punctuation">,</span> propagationPolicy<span class="token punctuation">)</span><span class="token punctuation">;</span>    ParseHandlersByName handlersByName <span class="token operator">=</span>          <span class="token keyword">new</span> <span class="token class-name">ParseHandlersByName</span><span class="token punctuation">(</span>contract<span class="token punctuation">,</span> options<span class="token punctuation">,</span> encoder<span class="token punctuation">,</span> decoder<span class="token punctuation">,</span> queryMapEncoder<span class="token punctuation">,</span>              errorDecoder<span class="token punctuation">,</span> synchronousMethodHandlerFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReflectiveFeign</span><span class="token punctuation">(</span>handlersByName<span class="token punctuation">,</span> invocationHandlerFactory<span class="token punctuation">,</span> queryMapEncoder<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，最终调用的 <code>newInstance（）</code>方法，是 <code>ReflectiveFeign.java</code> 里面的实现。</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Target<span class="token operator">&lt;</span>T<span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> MethodHandler<span class="token operator">></span> nameToHandler <span class="token operator">=</span> targetToHandlersByName<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>Method<span class="token punctuation">,</span> MethodHandler<span class="token operator">></span> methodToHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>Method<span class="token punctuation">,</span> MethodHandler<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>DefaultMethodHandler<span class="token operator">></span> defaultMethodHandlers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>DefaultMethodHandler<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Util<span class="token punctuation">.</span><span class="token function">isDefault</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        DefaultMethodHandler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMethodHandler</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>        defaultMethodHandlers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        methodToHandler<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        methodToHandler<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> nameToHandler<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Feign<span class="token punctuation">.</span><span class="token function">configKey</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> method<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    InvocationHandler handler <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> methodToHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    T proxy <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>target<span class="token punctuation">.</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>DefaultMethodHandler defaultMethodHandler <span class="token operator">:</span> defaultMethodHandlers<span class="token punctuation">)</span> <span class="token punctuation">{</span>      defaultMethodHandler<span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> proxy<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>终于，看到了熟悉的 JDK Proxy 动态代理代码。<br>从代码来看同步方法操作者是 <code>SynchronousMethodHandler.java</code> ，这里是封装具体请求的关键。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> argv<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>    RequestTemplate template <span class="token operator">=</span> buildTemplateFromArgs<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    Retryer retryer <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>retryer<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 执行并解码</span>        <span class="token keyword">return</span> <span class="token function">executeAndDecode</span><span class="token punctuation">(</span>template<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RetryableException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          retryer<span class="token punctuation">.</span><span class="token function">continueOrPropagate</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RetryableException</span> th<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//省略不关键代码</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-请求对象的转码和返回对象的解析解码。"><a href="#2-2-请求对象的转码和返回对象的解析解码。" class="headerlink" title="2.2 请求对象的转码和返回对象的解析解码。"></a>2.2 请求对象的转码和返回对象的解析解码。</h2><ol><li>首先 Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以提高通信效率。<br>application.yml 配置信息如下：</li></ol><pre class="line-numbers language-xml"><code class="language-xml">feign:  compression:    request: #请求      enabled: true #开启      mime-types: text/xml,application/xml,application/json #开启支持压缩的MIME TYPE      min-request-size: 2048 #配置压缩数据大小的下限    response: #响应      enabled: true #开启响应GZIP压缩<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时要注意：</p><blockquote><p>由于开启GZIP压缩之后，Feign之间的调用数据通过二进制协议进行传输，返回值需要修改为ResponseEntity&lt;byte[]&gt;才可以正常显示，否则会导致服务之间的调用乱码。</p></blockquote><p>代码大概像以下这样子。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/order/{productId}"</span><span class="token punctuation">)</span>ResponseEntity<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token function">addCart</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"productId"</span><span class="token punctuation">)</span> Long productId<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>针对 encode 和 decode 也做了支持,在yaml 配置文件中有这样</li></ol><pre class="line-numbers language-xml"><code class="language-xml">feign:  client:    config:      feignName:        connectTimeout: 5000        readTimeout: 5000        loggerLevel: full        errorDecoder: com.example.SimpleErrorDecoder        retryer: com.example.SimpleRetryer        requestInterceptors:          - com.example.FooRequestInterceptor          - com.example.BarRequestInterceptor        decode404: false        encoder: com.example.SimpleEncoder        decoder: com.example.SimpleDecoder        contract: com.example.SimpleContract<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以通过手动方式，在代码中直接配置</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>FeignClientsConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">FooController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> FooClient fooClient<span class="token punctuation">;</span>    <span class="token keyword">private</span> FooClient adminClient<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token function">FooController</span><span class="token punctuation">(</span>Decoder decoder<span class="token punctuation">,</span> Encoder encoder<span class="token punctuation">,</span> Client client<span class="token punctuation">,</span> Contract contract<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fooClient <span class="token operator">=</span> Feign<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">client</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">encoder</span><span class="token punctuation">(</span>encoder<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">decoder</span><span class="token punctuation">(</span>decoder<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">contract</span><span class="token punctuation">(</span>contract<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BasicAuthRequestInterceptor</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span>FooClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"https://PROD-SVC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adminClient <span class="token operator">=</span> Feign<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">client</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">encoder</span><span class="token punctuation">(</span>encoder<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">decoder</span><span class="token punctuation">(</span>decoder<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">contract</span><span class="token punctuation">(</span>contract<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">requestInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BasicAuthRequestInterceptor</span><span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">,</span> <span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span>FooClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"https://PROD-SVC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-不同-http-框架的支持"><a href="#2-3-不同-http-框架的支持" class="headerlink" title="2.3 不同 http 框架的支持"></a>2.3 不同 http 框架的支持</h2><p>Feign 默认底层通过JDK 的 java.net.HttpURLConnection 实现了feign.Client接口类,在每次发送请求的时候，都会创建新的HttpURLConnection链接，这也就是为什么默认情况下Feign的性能很差的原因。可以通过拓展该接口，使用Apache HttpClient 或者OkHttp3等基于连接池的高性能Http客户端。</p><p>Apache提供的HttpClient框架相比传统JDK自带的HttpURLConnection，它封装了访问http的请求头，参数，内容体，响应等等；它不仅使客户端发送HTTP请求变得容易，而且也方便了开发人员测试接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性；另外高并发大量的请求网络的时候，还是用“HTTP连接池”提升吞吐量。</p><p>OKHttp 是一个处理网络请求的开源项目,是安卓端常用的轻量级框架。OKHttp拥有共享Socket,减少对服务器的请求次数，通过连接池,减少了请求延迟等技术特点。</p><p>使用Feign 内部的 HttpClient 或 okhttp 的方式：</p><pre class="line-numbers language-xml"><code class="language-xml">feign.httpclient.enabled = truefeign.okhttp.enabled = true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-4-针对-断路器的支持-hystrix"><a href="#2-4-针对-断路器的支持-hystrix" class="headerlink" title="2.4 针对 断路器的支持(hystrix)"></a>2.4 针对 断路器的支持(hystrix)</h2><p>Feign 默认是不开启 Hystrix 的。默认为：false。</p><p>开启需要在yaml文件进行配置</p><pre class="line-numbers language-xml"><code class="language-xml">feign.hystrix.enabled=true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>源码体现在FeignClientsConfiguration.java中</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> HystrixCommand<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> HystrixFeign<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">protected</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HystrixFeignConfiguration</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span>        <span class="token annotation punctuation">@ConditionalOnMissingBean</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"feign.hystrix.enabled"</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> Feign<span class="token punctuation">.</span>Builder <span class="token function">feignHystrixBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> HystrixFeign<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时定义 fallback 对降级进行处理逻辑。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> fallback <span class="token operator">=</span> HystrixClientFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">interface</span> <span class="token class-name">HystrixClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"/hello"</span><span class="token punctuation">)</span>    Hello <span class="token function">iFailSometimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HystrixClientFallback</span> <span class="token keyword">implements</span> <span class="token class-name">HystrixClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Hello <span class="token function">iFailSometimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token string">"fallback"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启之后既可以进行 hystrix 的常规配置，详细可以查看 hystrix 相关内容。</p><h2 id="2-5-针对-日志的处理"><a href="#2-5-针对-日志的处理" class="headerlink" title="2.5 针对 日志的处理"></a>2.5 针对 日志的处理</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> Feign<span class="token punctuation">.</span>Builder <span class="token function">feign</span><span class="token punctuation">(</span>FeignContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FeignLoggerFactory loggerFactory <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> FeignLoggerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Logger logger <span class="token operator">=</span> loggerFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// @formatter:off</span>        Feign<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> Feign<span class="token punctuation">.</span>Builder<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// required values</span>                <span class="token punctuation">.</span><span class="token function">logger</span><span class="token punctuation">(</span>logger<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">encoder</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> Encoder<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">decoder</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> Decoder<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">contract</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> Contract<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// @formatter:on</span>        <span class="token function">configureFeign</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认实现是 <code>DefaultFeignLoggerFactory</code></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.5.RELEASE/reference/html/#configuration-properties">https://docs.spring.io/spring-cloud-openfeign/docs/2.2.5.RELEASE/reference/html/#configuration-properties</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求。Spring Cloud引入 Feign并且集成了Ribbon实现客户端负载均衡调用。&lt;br&gt;集成 Hystrix 实现客户端限流降级。&lt;br&gt;封装了Http调用流程，更适合面向接口化的变成习惯。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="微服务" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
      <category term="Spring Cloud" scheme="http://www.yusuzi.cn/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Rocket MQ 扫盲</title>
    <link href="http://www.yusuzi.cn/2020/08/23/Rocket-MQ-%E6%89%AB%E7%9B%B2/"/>
    <id>http://www.yusuzi.cn/2020/08/23/Rocket-MQ-扫盲/</id>
    <published>2020-08-23T10:52:48.000Z</published>
    <updated>2020-08-23T10:57:12.522Z</updated>
    
    <content type="html"><![CDATA[<p>文章来源  <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485969&idx=1&sn=6bd53abde30d42a778d5a35ec104428c&chksm=cea245daf9d5cccce631f93115f0c2c4a7634e55f5bef9009fd03f5a0ffa55b745b5ef4f0530&token=294077121&lang=zh_CN#rd">FrancisQ 老哥</a></p><p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道似啥吧？</p><a id="more"></a><h2 id="消息队列扫盲"><a href="#消息队列扫盲" class="headerlink" title="消息队列扫盲"></a>消息队列扫盲</h2><p>所以问题并不是消息队列是什么，而是 <strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p><h3 id="消息队列为什么会出现？"><a href="#消息队列为什么会出现？" class="headerlink" title="消息队列为什么会出现？"></a>消息队列为什么会出现？</h3><p>消息队列算是作为后端程序员的一个必备技能吧，因为<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p><h3 id="消息队列能用来干什么？"><a href="#消息队列能用来干什么？" class="headerlink" title="消息队列能用来干什么？"></a>消息队列能用来干什么？</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p><p>很好👍，你又提出了一个概念，<strong>同步通信</strong>。就比如现在业界使用比较多的 <code>Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code>RPC</code> 框架。</p><p>我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef37fee7e09230.jpg.jpg"></p><p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p><p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短息系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong>头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef380429cf373e.jpg.jpg"></p><p>这样整个系统的调用链又变长了，整个时间就变成了550ms。</p><p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p><p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦<del>~</del> 为了多吃点，真恶心。</p><p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p><p>最终我们从大妈手中接过饭菜然后去寻找座位了…</p><p>回想一下，我们在给大妈发送需要的信息之后我们是 <strong>同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/006APoFYly1fvd9cwjlfrj30as0b03ym.jpg.jpg"></p><p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong>(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong>(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以看其他事情了，这是一个 <strong>异步</strong> 的概念。</p><p>所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef38124f55eaea.jpg.jpg"></p><p>这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p><blockquote><p>但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p></blockquote><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>回到最初同步调用的过程，我们写个伪代码简单概括一下。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef381a505d3e1f.jpg.jpg"></p><p>那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef381c4e1b1ac7.jpg.jpg"></p><p>如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef381f273a66bd.jpg.jpg"></p><p>这样改来改去是不是很麻烦，那么 <strong>此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code>result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong>“广播消息”</strong> 来实现。</p><p>我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong>订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code>订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong>生产消息到指定主题中</strong> ，而 <strong>消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef382674b66892.jpg.jpg"></p><blockquote><p>如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p></blockquote><h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><p>我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef382a9756bb1c.jpg.jpg"></p><p>如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong>直接崩溃</strong> 了？</p><p>短信业务又不是我们的主业务，我们能不能 <strong>折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p><p>留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p><h4 id="消息队列能带来什么好处？"><a href="#消息队列能带来什么好处？" class="headerlink" title="消息队列能带来什么好处？"></a>消息队列能带来什么好处？</h4><p>其实上面我已经说了。<strong>异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p><h4 id="消息队列会带来副作用吗？"><a href="#消息队列会带来副作用吗？" class="headerlink" title="消息队列会带来副作用吗？"></a>消息队列会带来副作用吗？</h4><p>没有哪一门技术是“银弹”，消息队列也有它的副作用。</p><p>比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong>降低了系统的可用性</strong> ？</p><p>那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 <strong>整个系统的复杂度是不是上升了</strong> ？</p><p>抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p><p>或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p><p>对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p><p>那么，又 <strong>如何解决重复消费消息的问题</strong> 呢？</p><p>如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p><p>那么，又 <strong>如何解决消息的顺序消费问题</strong> 呢？</p><p>就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code>Spring</code> 的话我们在上面伪代码中加入 <code>@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p><p>那么，又如何 <strong>解决分布式事务问题</strong> 呢？</p><p>我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p><p>那么，又如何 <strong>解决消息堆积的问题</strong> 呢？</p><p>可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef382d709abc9d.png.jpg"></p><p>别急，办法总是有的。</p><h2 id="RocketMQ是什么？"><a href="#RocketMQ是什么？" class="headerlink" title="RocketMQ是什么？"></a>RocketMQ是什么？</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef383014430799.jpg.jpg"></p><p>哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code>RocketMQ</code> ，还让不让人活了？！🤬</p><p>别急别急，话说你现在清楚 <code>MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code>MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p><p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code>Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 <code>Apache</code>，成为了 <code>Apache</code> 的一个顶级项目。 在阿里内部，<code>RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code>RocketMQ</code> 流转。</p><p>废话不多说，想要了解 <code>RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code>RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p><h2 id="队列模型和主题模型"><a href="#队列模型和主题模型" class="headerlink" title="队列模型和主题模型"></a>队列模型和主题模型</h2><p>在谈 <code>RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong>队列模型</strong> 和 <strong>主题模型</strong> 。</p><p>首先我问一个问题，消息队列为什么要叫消息队列？</p><p>你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p><p>的确，早期的消息中间件是通过 <strong>队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p><p>但是，如今例如 <code>RocketMQ</code> 、<code>Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong>队列</strong> 来实现消息存储的。</p><h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef3834ae653469.jpg.jpg"></p><p>在一开始我跟你提到了一个 <strong>“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p><p>当然你可以让 <code>Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong>解耦</strong> 这一原则。</p><h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>那么有没有好的方法去解决这一个问题呢？有，那就是 <strong>主题模型</strong> 或者可以称为 <strong>发布订阅模型</strong> 。</p><blockquote><p>感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p></blockquote><p>在主题模型中，消息的生产者称为 <strong>发布者(Publisher)</strong> ，消息的消费者称为 <strong>订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong>主题(Topic)</strong> 。</p><p>其中，发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef3837887d9a54sds.jpg.jpg"></p><h3 id="RocketMQ中的消息模型"><a href="#RocketMQ中的消息模型" class="headerlink" title="RocketMQ中的消息模型"></a>RocketMQ中的消息模型</h3><p><code>RockerMQ</code> 中的消息模型就是按照 <strong>主题模型</strong> 所实现的。你可能会好奇这个 <strong>主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p><p>其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code>Kafka</code> 中的 <strong>分区</strong> ，<code>RocketMQ</code> 中的 <strong>队列</strong> ，<code>RabbitMQ</code> 中的 <code>Exchange</code> 。我们可以理解为 <strong>主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p><p>所以，<code>RocketMQ</code> 中的 <strong>主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef383d3e8c9788.jpg.jpg"></p><p>我们可以看到在整个图中有 <code>Producer Group</code> 、<code>Topic</code> 、<code>Consumer Group</code>  三个角色，我来分别介绍一下他们。</p><ul><li><code>Producer Group</code> 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code>Producer Group</code> 生产者组，它们一般生产相同的消息。</li><li><code>Consumer Group</code> 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code>Consumer Group</code> 消费者组，它们一般消费相同的消息。</li><li><code>Topic</code> 主题： 代表一类消息，比如订单消息，物流消息等等。</li></ul><p>你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong>主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p><p>每个主题中都有多个队列(这里还不涉及到 <code>Broker</code>)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，<strong>一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code>Consumer1</code> 和 <code>Consumer2</code> 分别对应着两个队列，而 <code>Consuer3</code> 是没有队列对应的，所以一般来讲要控制 <strong>消费者组中的消费者个数和主题中队列个数相同</strong> 。</p><p>当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef3850c808d707.jpg.jpg"></p><p><strong>每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p><p>因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef3857fefaa079.jpg.jpg"></p><p>可能你还有一个问题，<strong>为什么一个主题中需要维护多个队列</strong> ？</p><p>答案是 <strong>提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong>发布订阅模式</strong> 。如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef38600cdb6d4b.jpg.jpg"></p><p>但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code>Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p><p>所以总结来说，<code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式/发布订阅模式</strong> 。</p><h2 id="RocketMQ的架构图"><a href="#RocketMQ的架构图" class="headerlink" title="RocketMQ的架构图"></a>RocketMQ的架构图</h2><p>讲完了消息模型，我们理解起 <code>RocketMQ</code> 的技术架构起来就容易多了。</p><p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code> 、<code>Broker</code> 、<code>Producer</code> 、<code>Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p><ul><li><p><code>Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</p><p>这里，我还得普及一下关于 <code>Broker</code> 、<code>Topic</code> 和 队列的关系。上面我讲解了 <code>Topic</code> 和队列的关系——一个 <code>Topic</code> 中存在多个队列，那么这个 <code>Topic</code> 和队列存放在哪呢？</p><p><strong>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。 </p><p>如果某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p><p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef38687488a5a4.jpg.jpg"></p><blockquote><p>所以说我们需要配置多个Broker。</p></blockquote></li><li><p><code>NameServer</code>： 不知道你们有没有接触过 <code>ZooKeeper</code> 和 <code>Spring Cloud</code> 中的 <code>Eureka</code> ，它其实也是一个 <strong>注册中心</strong> ，主要提供两个功能：<strong>Broker管理</strong> 和 <strong>路由信息管理</strong> 。说白了就是 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</p></li><li><p><code>Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p></li><li><p><code>Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p></li></ul><p>听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef386c6d1e8bdb.jpg.jpg"></p><p>嗯？你可能会发现一个问题，这老家伙 <code>NameServer</code> 干啥用的，这不多余吗？直接 <code>Producer</code> 、<code>Consumer</code> 和 <code>Broker</code> 直接进行生产消息，消费消息不就好了么？</p><p>但是，我们上文提到过 <code>Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code>Broker</code> 来维持的话，那么这个 <code>Broker</code> 的压力会不会很大？所以我们需要使用多个 <code>Broker</code> 来保证 <strong>负载均衡</strong> 。</p><p>如果说，我们的消费者和生产者直接和多个 <code>Broker</code> 相连，那么当 <code>Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code>NameServer</code> 注册中心就是用来解决这个问题的。</p><blockquote><p>如果还不是很理解的话，可以去看我介绍 <code>Spring Cloud</code> 的那篇文章，其中介绍了 <code>Eureka</code> 注册中心。</p></blockquote><p>当然，<code>RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef386fa3be1e53.jpg.jpg"></p><p>其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。</p><p>第一、我们的 <code>Broker</code> <strong>做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该<code>Broker</code> 上的消息读写都会受到影响。所以 <code>Rocketmq</code> 提供了 <code>master/slave</code> 的结构，<code> salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，<strong>则 <code>slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p><p>第二、为了保证 <code>HA</code> ，我们的 <code>NameServer</code> 也做了集群部署，但是请注意它是 <strong>去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code>NameServer</code> 的所有节点是没有进行 <code>Info Replicate</code> 的，在 <code>RocketMQ</code> 中是通过 <strong>单个Broker和所有NameServer保持长连接</strong> ，并且在每隔30秒 <code>Broker</code> 会向所有 <code>Nameserver</code> 发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息，这个步骤就对应这上面的 <code>Routing Info</code> 。</p><p>第三、在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p><p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。<code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p><h2 id="如何解决-顺序消费、重复消费"><a href="#如何解决-顺序消费、重复消费" class="headerlink" title="如何解决 顺序消费、重复消费"></a>如何解决 顺序消费、重复消费</h2><p>其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code>RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p><p>在上面我介绍 <code>RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong>它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code>RocketMQ</code> 集群。</p><blockquote><p>其实 <code>Kafka</code> 的架构基本和 <code>RocketMQ</code> 类似，只是它注册中心使用了 <code>Zookeeper</code> 、它的 <strong>分区</strong> 就相当于 <code>RocketMQ</code> 中的 <strong>队列</strong> 。还有一些小细节不同会在后面提到。</p></blockquote><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>在上面的技术架构介绍中，我们已经知道了 <strong><code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p><p>这又扯到两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p><p>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p><p>所谓严格顺序是指  消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</p><p>但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code>binlog</code> 同步。</p><p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p><p>那么，我们现在使用了 <strong>普通顺序模式</strong> ，我们从上面学习知道了在 <code>Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong>三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code>RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef3874585e096e.jpg.jpg"></p><p>那么，怎么解决呢？</p><p>其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong>Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p><h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>emmm，就两个字—— <strong>幂等</strong> 。在编程中一个<em>幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。</p><p>那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p><p>所以我们需要给我们的消费者实现 <strong>幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p><p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong>写入 <code>Redis</code></strong> 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。当然还有使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p><p>不过最主要的还是需要 <strong>根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p><p>而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将HTTP服务设计成幂等的，<strong>解决前端或者APP重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>如何解释分布式事务呢？事务大家都知道吧？<strong>要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p><p>那么，如何去解决这个问题呢？</p><p>如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p><p>在 <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef38798d7a987f.png.jpg"></p><p>在第一步发送的 half 消息 ，它的意思是 <strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p><blockquote><p>那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong>改变主题</strong> 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，<strong>然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p></blockquote><p>你可以试想一下，如果没有从第5步开始的 <strong>事务反查机制</strong> ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code>RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code>Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p><p>你还需要注意的是，在 <code>MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong>本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong>最终一致性</strong>，因为整个过程是异步的，<strong>每个系统只要保证它自己那一部分的事务就行了</strong>。</p><h2 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h2><p>在上面我们提到了消息队列一个很重要的功能——<strong>削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p><p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p><p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p><blockquote><p>当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong>同时你还需要增加每个主题的队列数量</strong> 。</p><p>别忘了在 <code>RocketMQ</code> 中，<strong>一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef387d939ab66d.jpg.jpg"></p><h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费1小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p><p>这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。</p><h2 id="RocketMQ-的刷盘机制"><a href="#RocketMQ-的刷盘机制" class="headerlink" title="RocketMQ 的刷盘机制"></a>RocketMQ 的刷盘机制</h2><p>上面我讲了那么多的 <code>RocketMQ</code> 的架构和设计原理，你有没有好奇</p><p>在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？</strong></p><p><strong>队列中的消息又是如何进行存储持久化的呢？</strong></p><p>我在上文中提到的 <strong>同步刷盘</strong> 和 <strong>异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p><p>下面我将给你们一一解释。</p><h3 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef387fba311cda.jpg.jpg"></p><p>如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code>ACK</code> ，同步刷盘对 <code>MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p><p>而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p><p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p><h3 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h3><p>上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p><ul><li>同步复制： 也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li><li>异步复制： <strong>消息写入主节点之后就直接返回写入成功</strong> 。</li></ul><p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p><p>那么，<strong>异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p><p>答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong>可用性</strong> 。为什么呢？其主要原因<strong>是 <code>RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p><p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p><p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code>Topic</code> 是分布在不同 <code>Broker</code> 中的。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef38687488a5a4.jpg.jpg"></p><p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code>Topic</code> 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p><p>而在 <code>RocketMQ</code> 中采用了 <code>Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p><blockquote><p>也不是说 <code>Dledger</code> 是个完美的方案，至少在 <code>Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制板书以上节点的效率和直接异步复制还是有一定的差距的。</p></blockquote><h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p><p>但是，在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code>RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code>RocketMQ</code> 消息存储架构中的三大角色——<code>CommitLog</code> 、<code>ConsumeQueue</code> 和 <code>IndexFile</code> 。</p><ul><li><code>CommitLog</code>： <strong>消息主体以及元数据的存储主体</strong>，存储 <code>Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong>顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li><li><code>ConsumeQueue</code>： 消息消费队列，<strong>引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code>RocketMQ</code> 是基于主题 <code>Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code>commitlog</code> 文件中根据 <code>Topic</code> 检索消息是非常低效的。<code>Consumer</code> 即可根据 <code>ConsumeQueue</code> 来查找待消费的消息。其中，<code>ConsumeQueue</code>（逻辑消费队列）<strong>作为消费消息的索引</strong>，保存了指定 <code>Topic</code> 下的队列消息在 <code>CommitLog</code> 中的<strong>起始物理偏移量 <code>offset</code> **，消息大小 <code>size</code> 和消息 <code>Tag</code> 的 <code>HashCode</code> 值。</strong><code>consumequeue</code> 文件可以看成是基于 <code>topic</code> 的 <code>commitlog</code> 索引文件**，故 <code>consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code>consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code>commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code>hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code>ConsumeQueue</code>文件大小约5.72M；</li><li><code>IndexFile</code>： <code>IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li></ul><p>总结来说，整个消息存储的结构，最主要的就是 <code>CommitLoq</code> 和 <code>ConsumeQueue</code> 。而 <code>ConsumeQueue</code> 你可以大概理解为 <code>Topic</code> 中的队列。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef3884c02acc72.png.jpg"></p><p><code>RocketMQ</code> 采用的是 <strong>混合型的存储结构</strong> ，即为 <code>Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code>Kafka</code> 中会为每个 <code>Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code>RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code>Kafka</code> 是将书本放入指定的分类区域的。</p><p>而 <code>RocketMQ</code> 为什么要这么做呢？原因是 <strong>提高数据的写入效率</strong> ，不分 <code>Topic</code> 意味着我们有更大的几率获取 <strong>成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p><p>所以，在 <code>RocketMQ</code> 中又使用了 <code>ConsumeQueue</code> 作为每个队列的索引文件来 <strong>提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p><p>讲到这里，你可能对 <code>RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/16ef388763c25c62.jpg.jpg"></p><p>emmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p><blockquote><p>如果上面没看懂的读者一定要认真看下面的流程分析！</p></blockquote><p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 **把 <code>ConsumerQueue</code> 理解为 <code>Queue</code>**。</p><p>在图中最左边说明了 <font color = red>红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code> 、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中管你是哪门子消息，他直接 **全部顺序存储到了 CommitLog **。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p><p>上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p><p>因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/e314ee45gy1g05zgr67bbj20gp0b3aba.jpg.jpg"></p><p>为什么 <code>CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong>内存映射机制</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总算把这篇博客写完了。我讲的你们还记得吗😅？</p><p>这篇文章中我主要想大家介绍了</p><ol><li>消息队列出现的原因</li><li>消息队列的作用(异步，解耦，削峰)</li><li>消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</li><li>消息队列的两种消息模型——队列和主题模式</li><li>分析了 <code>RocketMQ</code> 的技术架构(<code>NameServer</code> 、<code>Broker</code> 、<code>Producer</code> 、<code>Comsumer</code>)</li><li>结合 <code>RocketMQ</code> 回答了消息队列副作用的解决方案</li><li>介绍了 <code>RocketMQ</code> 的存储机制和刷盘策略。</li></ol><p>等等。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章来源  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485969&amp;idx=1&amp;sn=6bd53abde30d42a778d5a35ec104428c&amp;chksm=cea245daf9d5cccce631f93115f0c2c4a7634e55f5bef9009fd03f5a0ffa55b745b5ef4f0530&amp;token=294077121&amp;lang=zh_CN#rd&quot;&gt;FrancisQ 老哥&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道似啥吧？&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
      <category term="MQ" scheme="http://www.yusuzi.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>关于大型系统架构的10个问题</title>
    <link href="http://www.yusuzi.cn/2020/08/21/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://www.yusuzi.cn/2020/08/21/关于大型系统架构的10个问题/</id>
    <published>2020-08-21T06:22:37.000Z</published>
    <updated>2020-08-21T06:32:02.456Z</updated>
    
    <content type="html"><![CDATA[<p>下面这些问题都是一线大厂的真实面试问题，不论是对你面试还是说拓宽知识面都很有帮助。</p><a id="more"></a><h3 id="1-你使用过哪些组件或者方法来提升网站性能-可用性以及并发量"><a href="#1-你使用过哪些组件或者方法来提升网站性能-可用性以及并发量" class="headerlink" title="1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量"></a>1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量</h3><ol><li><strong>提高硬件能力、增加系统服务器</strong>。（当服务器增加到某个程度的时候系统所能提供的并发访问量几乎不变，所以不能根本解决问题）</li><li><strong>使用缓存</strong>（本地缓存：本地可以使用JDK自带的 Map、Guava Cache.分布式缓存：Redis、Memcache.本地缓存不适用于提高系统并发量，一般是用处用在程序中。比如Spring是如何实现单例的呢？大家如果看过源码的话，应该知道，S把已经初始过的变量放在一个Map中，下次再要使用这个变量的时候，先判断Map中有没有，这也就是系统中常见的单例模式的实现。）</li><li><strong>消息队列</strong> （解耦+削峰+异步）</li><li><strong>采用分布式开发</strong> （不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署(All In)的缺点，大大提高的系统并发量）</li><li><strong>数据库分库（读写分离）、分表（水平分表、垂直分表）</strong></li><li><strong>采用集群</strong> （多台机器提供相同的服务）</li><li><strong>CDN 加速</strong> (将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点)</li><li><strong>浏览器缓存</strong></li><li><strong>使用合适的连接池</strong>（数据库连接池、线程池等等）</li><li><strong>适当使用多线程进行开发。</strong></li></ol><h3 id="2-设计高可用系统的常用手段"><a href="#2-设计高可用系统的常用手段" class="headerlink" title="2. 设计高可用系统的常用手段"></a>2. 设计高可用系统的常用手段</h3><ol><li><strong>降级：</strong> 服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好；</li><li><strong>限流：</strong> 防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值；</li><li><strong>缓存：</strong> 避免大量请求直接落到数据库，将数据库击垮；</li><li><strong>超时和重试机制：</strong> 避免请求堆积造成雪崩；</li><li><strong>回滚机制：</strong> 快速修复错误版本。</li></ol><h3 id="3-现代互联网应用系统通常具有哪些特点"><a href="#3-现代互联网应用系统通常具有哪些特点" class="headerlink" title="3. 现代互联网应用系统通常具有哪些特点?"></a>3. 现代互联网应用系统通常具有哪些特点?</h3><ol><li>高并发，大流量；</li><li>高可用：系统7×24小时不间断服务；</li><li>海量数据：需要存储、管理海量数据，需要使用大量服务器；</li><li>用户分布广泛，网络情况复杂：许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别；</li><li>安全环境恶劣：由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会被黑客攻击；</li><li>需求快速变更，发布频繁：和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率是极高的；</li><li>渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来。</li></ol><h3 id="4-谈谈你对微服务领域的了解和认识"><a href="#4-谈谈你对微服务领域的了解和认识" class="headerlink" title="4. 谈谈你对微服务领域的了解和认识"></a>4. 谈谈你对微服务领域的了解和认识</h3><p>现在大公司都在用并且未来的趋势都是 Spring Cloud，而阿里开源的 Spring Cloud Alibaba 也是 Spring Cloud 规范的实现 。</p><p>我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon、Feign、Eureka（停止更新）、Hystrix 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。</p><p>Spring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现,Spring Cloud Alibaba 是一套国产开源产品集合，后续还会有中文 reference 和一些原理分析文章，所以，这对于国内的开发者是非常棒的一件事。阿里的这一举动势必会推动国内微服务技术的发展，因为在没有 Spring Cloud Alibaba 之前，我们的第一选择是 Spring Cloud Netflix，但是它们的文档都是英文的，出问题后排查也比较困难， 在国内并不是有特别多的人精通。Spring Cloud Alibaba 由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。</p><p>另外，Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p><h3 id="5-谈谈你对-Dubbo-和-Spring-Cloud-的认识-两者关系"><a href="#5-谈谈你对-Dubbo-和-Spring-Cloud-的认识-两者关系" class="headerlink" title="5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)"></a>5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)</h3><p>具体可以看公众号-阿里巴巴中间件的这篇文章:<a href="https://mp.weixin.qq.com/s/iNVctXw7tUGHhnF0hV84ww">独家解读：Dubbo Ecosystem - 从微服务框架到微服务生态</a></p><p>Dubbo 与 Spring Cloud 并不是竞争关系，Dubbo 作为成熟的 RPC 框架，其易用性、扩展性和健壮性已得到业界的认可。未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。</p><p>在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。我们后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p><h3 id="6-性能测试了解吗-说说你知道的性能测试工具"><a href="#6-性能测试了解吗-说说你知道的性能测试工具" class="headerlink" title="6. 性能测试了解吗?说说你知道的性能测试工具?"></a>6. 性能测试了解吗?说说你知道的性能测试工具?</h3><p>性能测试指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。性能测试是总称，通常细分为：</p><ol><li><strong>基准测试：</strong> 在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考</li><li><strong>负载测试：</strong> 是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。此时继续加压，系统处理能力会下降。</li><li><strong>压力测试：</strong> 超过安全负载情况下，不断施加压力（增加并发请求），直到系统崩溃或无法处理任何请求，依此获得系统最大压力承受能力。</li><li><strong>稳定性测试：</strong> 被测试系统在特定硬件、软件、网络环境下，加载一定业务压力（模拟生产环境不同时间点、不均匀请求，呈波浪特性）运行一段较长时间，以此检测系统是否稳定。</li></ol><p>后端程序员或者测试平常比较常用的测试工具是 JMeter（官网：<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a>）。Apache JMeter 是一款基于Java的压力测试工具(100％纯Java应用程序)，旨在加载测试功能行为和测量性能。它最初被设计用于 Web 应用测试但后来扩展到其他测试领域。</p><h3 id="7-对于一个单体应用系统-随着产品使用的用户越来越多-网站的流量会增加-最终单台服务器无法处理那么大的流量怎么办"><a href="#7-对于一个单体应用系统-随着产品使用的用户越来越多-网站的流量会增加-最终单台服务器无法处理那么大的流量怎么办" class="headerlink" title="7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?"></a>7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?</h3><p>这个时候就要考虑扩容了。《亿级流量网站架构核心技术》这本书上面介绍到我们可以考虑下面几步来解决这个问题：</p><ul><li>第一步，可以考虑简单的扩容来解决问题。比如增加系统的服务器，提高硬件能力等等。</li><li>第二步，如果简单扩容搞不定，就需要水平拆分和垂直拆分数据／应用来提升系统的伸缩性，即通过扩容提升系统负载能力。</li><li>第三步，如果通过水平拆分／垂直拆分还是搞不定，那就需要根据现有系统特性，架构层面进行重构甚至是重新设计，即推倒重来。</li></ul><p>对于系统设计，理想的情况下应支持线性扩容和弹性扩容，即在系统瓶颈时，只需要增加机器就可以解决系统瓶颈，如降低延迟提升吞吐量，从而实现扩容需求。</p><p>如果你想扩容，则支持水平/垂直伸缩是前提。在进行拆分时，一定要清楚知道自己的目的是什么，拆分后带来的问题如何解决，拆分后如果没有得到任何收益就不要为了<br>拆而拆，即不要过度拆分，要适合自己的业务。</p><h3 id="8-大表优化的常见手段"><a href="#8-大表优化的常见手段" class="headerlink" title="8. 大表优化的常见手段"></a>8. 大表优化的常见手段</h3><p>   当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li><li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li><strong>垂直分区：</strong> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。<img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/164084354ba2e0fd?w=950&h=279&f=jpeg&s=26015.jpg"><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li><li><strong>水平分区：</strong> <strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。<img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/164084b7e9e423e3?w=690&h=271&f=jpeg&s=23119.jpg" alt="数据库水平拆分">水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong>  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</li></ol><p><strong>下面补充一下数据库分片的两种常见方案：</strong></p><ul><li><strong>客户端代理：</strong>  <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h3 id="9-在系统中使用消息队列能带来什么好处"><a href="#9-在系统中使用消息队列能带来什么好处" class="headerlink" title="9. 在系统中使用消息队列能带来什么好处?"></a>9. 在系统中使用消息队列能带来什么好处?</h3><p><strong>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</strong></p><h4 id="1-通过异步处理提高系统性能"><a href="#1-通过异步处理提高系统性能" class="headerlink" title="1) 通过异步处理提高系统性能"></a>1) 通过异步处理提高系统性能</h4><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/162e63a8e34ba534?w=910&h=350&f=jpeg&s=29123.jpg" alt="通过异步处理提高系统性能"><br>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p><p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/162e64583dd3ed01?w=780&h=384&f=jpeg&s=13550.jpg" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击"><br>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h3 id="2-降低系统耦合性"><a href="#2-降低系统耦合性" class="headerlink" title="2) 降低系统耦合性"></a>2) 降低系统耦合性</h3><p>我们知道模块分布式部署以后聚合方式通常有两种：1.<strong>分布式消息队列</strong>和2.<strong>分布式服务</strong>。</p><blockquote><p><strong>先来简单说一下分布式服务：</strong></p></blockquote><p>目前使用比较多的用来构建<strong>SOA（Service Oriented Architecture面向服务体系结构）</strong>的<strong>分布式服务框架</strong>是阿里巴巴开源的<strong>Dubbo</strong>.如果想深入了解Dubbo的可以看我写的关于Dubbo的这一篇文章：<strong>《高性能优秀的服务框架-dubbo介绍》</strong>：<a href="https://juejin.im/post/5acadeb1f265da2375072f9c">https://juejin.im/post/5acadeb1f265da2375072f9c</a></p><blockquote><p><strong>再来谈我们的分布式消息队列：</strong></p></blockquote><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/162e6665fa394b3b?w=790&h=290&f=jpeg&s=14946.jpg" alt="利用消息队列实现事件驱动结构"><br><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong>   </p><p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<strong>比如在我们的ActiveMQ消息队列中还有点对点工作模式</strong>，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。</p><blockquote><p>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！</p></blockquote><h3 id="10-说说自己对-CAP-定理-BASE-理论的了解"><a href="#10-说说自己对-CAP-定理-BASE-理论的了解" class="headerlink" title="10. 说说自己对 CAP 定理,BASE 理论的了解"></a>10. 说说自己对 CAP 定理,BASE 理论的了解</h3><h4 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h4><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/163912e973ecb93c?w=624&h=471&f=png&s=32984.jpg" alt="CAP定理"><br>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li><strong>一致性（Consistence）</strong> :所有节点访问同一份最新的数据副本</li><li><strong>可用性（Availability）</strong>:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li><li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li></ul><p>CAP仅适用于原子读写的NOSQL场景中，并不适合数据库系统。现在的分布式系统具有更多特性比如扩展性、可用性等等，在进行系统设计和开发时，我们不应该仅仅局限在CAP问题上。</p><p><strong>注意：不是所谓的3选2（不要被网上大多数文章误导了）:</strong></p><p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在CAP理论诞生12年之后，CAP之父也在2012年重写了之前的论文。</p><p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能2选1。也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p><p>我在网上找了很多文章想看一下有没有文章提到这个不是所谓的3选2，用百度半天没找到了一篇，用谷歌搜索找到一篇比较不错的，如果想深入学习一下CAP就看这篇文章把，我这里就不多BB了：<strong>《分布式系统之CAP理论》 ：</strong> <a href="http://www.cnblogs.com/hxsyl/p/4381980.html">http://www.cnblogs.com/hxsyl/p/4381980.html</a></p><h4 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h4><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。</p><p><strong>BASE理论的核心思想：</strong> 即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p><p><strong>BASE理论三要素：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/163914806d9e15c6?w=612&h=461&f=png&s=39129.jpg" alt="BASE理论三要素"></p><ol><li><strong>基本可用：</strong> 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 比如： <strong>①响应时间上的损失</strong>:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；<strong>②系统功能上的损失</strong>：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；</li><li><strong>软状态：</strong> 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；</li><li><strong>最终一致性：</strong> 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>《大型网站技术架构》</li><li>《亿级流量网站架构核心技术》</li><li>《Java工程师修炼之道》</li><li><a href="https://www.cnblogs.com/puresoul/p/5456855.html">https://www.cnblogs.com/puresoul/p/5456855.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面这些问题都是一线大厂的真实面试问题，不论是对你面试还是说拓宽知识面都很有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="架构" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.yusuzi.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java-分布式锁这样实现</title>
    <link href="http://www.yusuzi.cn/2020/08/13/Java-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%BF%99%E6%A0%B7%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.yusuzi.cn/2020/08/13/Java-分布式锁这样实现/</id>
    <published>2020-08-13T12:41:41.000Z</published>
    <updated>2020-08-21T04:57:50.587Z</updated>
    
    <content type="html"><![CDATA[<p>为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。</p><a id="more"></a><p>分布式锁实现，目前有很多种方式比如以下方式。</p><h1 id="1-常用实现方式"><a href="#1-常用实现方式" class="headerlink" title="1. 常用实现方式"></a>1. 常用实现方式</h1><ul><li>基于数据库实现分布式锁</li></ul><ol><li>性能较差，容易出现单点故障。</li><li>锁没有失效时间，容易死锁。</li></ol><ul><li>基于缓存实现分布式锁</li></ul><ol><li>比如通过Redis 实现，但相对复杂。</li><li>存在死锁（或短时间死锁）的可能。</li></ol><ul><li>基于 Zookeeper 实现分布式锁</li></ul><ol><li>实现相对简单</li><li>可靠性高</li><li>性能好</li></ol><p>从上面来看，Zookeeper 是一个理想状态下的分布式锁实现，那zk为什么理想呢？这要从 zk 的特性来说。</p><ol><li>首先zk 是一个分布式的，开放源码的分布式应用程序协调服务。</li><li>基于节点的数据结构，和unix文件路径相似的节点，可以往这个节点存储或获取数据。</li><li>通过客户端可对 znode 进行增删改查的操作，还可以注册watcher监控znode变化。</li><li>节点类型分为持久节点（包含：顺序和非顺序）、临时节点（顺序和非顺序）</li><li>同父的子节点不可重复。</li></ol><h2 id="3-Zookeeper-实现分布式锁一"><a href="#3-Zookeeper-实现分布式锁一" class="headerlink" title="3. Zookeeper 实现分布式锁一"></a>3. Zookeeper 实现分布式锁一</h2><p>利用zk 同父节点下子节点不可重名的特性。</p><p>实现流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1892343233.jpg" alt="image"></p><p>针对以上流程代码实现如下，包含可重入锁的特性。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZKDistributeLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String lockPath<span class="token punctuation">;</span>    <span class="token keyword">private</span> ZkClient client<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 锁重入计数</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> reentrantCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ZKDistributeLock</span><span class="token punctuation">(</span>String lockPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>        client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZkClient</span><span class="token punctuation">(</span><span class="token string">"localhost:2181"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setZkSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyZkSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 不会阻塞</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">++</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 创建节点</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">createEphemeral</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ZkNodeExistsException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 重入的释放锁处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">--</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果获取不到锁，阻塞等待</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 没获得锁，阻塞自己</span>            <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 再次尝试</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CountDownLatch cdl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IZkDataListener listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IZkDataListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataDeleted</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----收到节点被删除了-------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cdl<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataChange</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">,</span> Object data<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">subscribeDataChanges</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 阻塞自己</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                cdl<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 取消注册</span>        client<span class="token punctuation">.</span><span class="token function">unsubscribeDataChanges</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 并发数</span>        <span class="token keyword">int</span> currency <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环屏障</span>        CyclicBarrier cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>currency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 多线程模拟高并发</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currency<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"---------我准备好---------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 等待一起出发</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    ZKDistributeLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZKDistributeLock</span><span class="token punctuation">(</span><span class="token string">"/distLock11"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 获得锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>是否可以利用持久节点进行创建？</li></ol><p>利用持久节点，存在死锁的风险。因为如果持有锁的进程挂掉了，没有来的及删除节点，则出现死锁。<br>所以需要用临时节点，因为临时节点有自删除的特性。</p><ol start="2"><li>但是采用临时节点就没问题了吗？</li></ol><p>有问题，临时节点会出现惊群效应，在高并发场景下，如果有多个线程 注册了 watcher 机制，那么在这种实现方式下，就会有多个线程同时被唤醒，进行锁争抢，会造成巨大的服务器性能损耗，甚至可能出现宕机的风险，这就是所谓的惊群效应。</p><p>针对惊群效应，下面给出个改进版。</p><h2 id="4-zk实现分布式锁方式二"><a href="#4-zk实现分布式锁方式二" class="headerlink" title="4. zk实现分布式锁方式二"></a>4. zk实现分布式锁方式二</h2><p>利用zk 临时顺序节点的特性。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1892343234.jpg" alt="image"></p><p>利用临时顺序节点来实现分布式锁，包含可重入特性的完整代码。</p><ol><li>获取锁：取排队号（创建自己的临时顺序节点），然后判断自己是否是最小号，如是，则获得锁；不是，则注册前一节点的watcher,阻塞等待</li><li>释放锁：删除自己创建的临时顺序节点</li><li>通知：watcher机制通知阻塞等待的线程。</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZKDistributeImproveLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lockPath<span class="token punctuation">;</span>    <span class="token keyword">private</span> ZkClient client<span class="token punctuation">;</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> currentPath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>String<span class="token operator">></span> beforePath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 锁重入计数</span>    <span class="token keyword">private</span> ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> reentrantCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ZKDistributeImproveLock</span><span class="token punctuation">(</span>String lockPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>        client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZkClient</span><span class="token punctuation">(</span><span class="token string">"localhost:2181"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setZkSerializer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyZkSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">createPersistent</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ZkNodeExistsException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">++</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            currentPath<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">createEphemeralSequential</span><span class="token punctuation">(</span>lockPath <span class="token operator">+</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 获得所有的子</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> children <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 排序list</span>        Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 判断当前节点是否是最小的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lockPath <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 取到前一个</span>            <span class="token comment" spellcheck="true">// 得到字节的索引号</span>            <span class="token keyword">int</span> curIndex <span class="token operator">=</span> children<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>lockPath<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            beforePath<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockPath <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>curIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 阻塞等待</span>            <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 再次尝试加锁</span>            <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">waitForLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CountDownLatch cdl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 注册watcher</span>        IZkDataListener listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IZkDataListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataDeleted</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----监听到节点被删除"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cdl<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDataChange</span><span class="token punctuation">(</span>String dataPath<span class="token punctuation">,</span> Object data<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">subscribeDataChanges</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beforePath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 怎么让自己阻塞</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beforePath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                cdl<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 醒来后，取消watcher</span>        client<span class="token punctuation">.</span><span class="token function">unsubscribeDataChanges</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beforePath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 重入的释放锁处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">--</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantCount<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 删除节点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 并发数</span>        <span class="token keyword">int</span> currency <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 循环屏障</span>        CyclicBarrier cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span>currency<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 多线程模拟高并发</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currency<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"---------我准备好---------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 等待一起出发</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    ZKDistributeImproveLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZKDistributeImproveLock</span><span class="token punctuation">(</span><span class="token string">"/distLock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 获得锁！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个分布式锁。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="微服务" scheme="http://www.yusuzi.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
      <category term="锁" scheme="http://www.yusuzi.cn/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Python 疫苗爬虫脚本</title>
    <link href="http://www.yusuzi.cn/2020/08/12/Python-%E7%96%AB%E8%8B%97%E7%88%AC%E8%99%AB%E8%84%9A%E6%9C%AC/"/>
    <id>http://www.yusuzi.cn/2020/08/12/Python-疫苗爬虫脚本/</id>
    <published>2020-08-12T07:03:28.000Z</published>
    <updated>2020-08-21T04:52:03.076Z</updated>
    
    <content type="html"><![CDATA[<p>关于疫苗的python爬虫脚本，主要爬新华网。</p><a id="more"></a><p>源码地址查看 </p><p><a href="https://github.com/brokge/vaccine-scrapy">Github brokge  / vaccine-scrapy</a></p><h1 id="1-需要环境"><a href="#1-需要环境" class="headerlink" title="1. 需要环境"></a>1. 需要环境</h1><ul><li>python 3.5.2</li><li>scrapy 1.5.2</li><li>conda 4.6.11 或者 pip3</li><li>pycryptodome </li><li>pymysql</li></ul><p>如果碰到 兼容性问题<br>最好的方式，是通过 conda 安装所需要的环境变量，记得安装之后重启下系统</p><pre class="line-numbers language-sh"><code class="language-sh">conda install -c conda-forge scrapy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然也可以通过 pip3 来安装</p><pre class="line-numbers language-sh"><code class="language-sh">pip3 --default-timeout=100 install scrapy pip3 install pycryptodomepip3 install pymysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="2-运行"><a href="#2-运行" class="headerlink" title="2. 运行"></a>2. 运行</h1><pre class="line-numbers language-sh"><code class="language-sh">scrapy crawl spiderNews  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-文件目录说明"><a href="#3-文件目录说明" class="headerlink" title="3. 文件目录说明"></a>3. 文件目录说明</h1><p>通过 tree 命令查看目录结构</p><pre><code>.── README.md├── scrapy.cfg└── vaccine    ├── README.md    ├── __init__.py    ├── __pycache__    │   ├── __init__.cpython-37.pyc    │   ├── items.cpython-37.pyc    │   ├── pipelines.cpython-37.pyc    │   └── settings.cpython-37.pyc    ├── dbsql.sql    ├── items.py    ├── middlewares.py    ├── pipelines.py    ├── settings.py    ├── spiders    │   ├── VaccineNewsSpider.py    │   ├── __init__.py    │   └── __pycache__    │       ├── VaccineNewsSpider.cpython-37.pyc    │       └── __init__.cpython-37.pyc    └── vaccine_name.txt</code></pre><ul><li><p>dbsql.sql —数据表结构脚本</p></li><li><p>vaccine_name.txt —需要查询的关键字配置文件</p></li><li><p>VaccineNewsSpider.py — 爬虫执行文件</p></li><li><p>pipelines.py — 配置 通道的位置，根据自己情况调整</p><pre class="line-numbers language-python"><code class="language-python"> <span class="token comment" spellcheck="true"># 链接数据的配置</span> self<span class="token punctuation">.</span>connect <span class="token operator">=</span> pymysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>      <span class="token comment" spellcheck="true"># 数据库地址</span>      host<span class="token operator">=</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span>      port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span>      db<span class="token operator">=</span><span class="token string">"dbcontent"</span><span class="token punctuation">,</span>      user<span class="token operator">=</span><span class="token string">'yusuzi'</span><span class="token punctuation">,</span>      passwd<span class="token operator">=</span><span class="token string">'yusuzi'</span><span class="token punctuation">,</span>      charset<span class="token operator">=</span><span class="token string">'utf8'</span><span class="token punctuation">,</span>      use_unicode<span class="token operator">=</span><span class="token boolean">True</span>  <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="4-执行效果截图"><a href="#4-执行效果截图" class="headerlink" title="4. 执行效果截图"></a>4. 执行效果截图</h1><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1FB53BAABFE04F15A20134805AE5BE2C.jpg" alt="image"></p><h1 id="5-核心逻辑"><a href="#5-核心逻辑" class="headerlink" title="5. 核心逻辑"></a>5. 核心逻辑</h1><p>在  VaccineNewsSpider.py 文件中，主要逻辑流程如下</p><ol><li>构造 url请求地址，</li><li>填充 关键字</li><li>请求 url</li><li>解析 返回数据</li><li>根据请求url 生成 md5 去重。</li><li>写入数据哭。</li></ol><h2 id="5-1-构造请求并解析返回数据"><a href="#5-1-构造请求并解析返回数据" class="headerlink" title="5.1 构造请求并解析返回数据"></a>5.1 构造请求并解析返回数据</h2><pre class="line-numbers language-py"><code class="language-py">class VaccineNewsSpider(scrapy.Spider):    name = "spiderNews"    url_format = "http://so.news.cn/getNews?keyword=%s&curPage=%s&sortField=0&searchFields=1&lang=cn"    def start_requests(self):        keywords = set()        try:            f = open('vaccine/vaccine_name.txt', 'r')            for line in f.readlines():                line = line.strip('\n')  # 去除换行符号                keywords.add(line)        finally:            if f:                f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>url_format: 根据自己不同的目标网址，进行构造请求url</p><pre class="line-numbers language-py"><code class="language-py"> def parse_json(self, response):        print("aa")        print(response.body)        newJson = json.loads(response.body)         print(newJson['code'])        newContent = newJson['content']        results = newContent['results']        pageSize = newContent['pageCount']        curPage = newContent['curPage']        keyWord = newContent['keyword']        newSets = set()        for result in results:            url = result['url']            if 'm.xinhuanet.com' in url and result['des']:                html_remove = re.compile(r'<[^>]+>', re.S)  # 构建匹配模式                # dd = dr.sub('', string) # 去除html标签                title = html_remove.sub('', result['title'])                print("title"+title)                vaccineNewsItem = VaccineNewsItem()                vaccineNewsItem['title'] = title.lstrip()                vaccineNewsItem['from_url'] = url                # result['sitename']                vaccineNewsItem['from_source'] = '新华网'                vaccineNewsItem['summary'] = result['des'].lstrip()                vaccineNewsItem['create_date'] = result['pubtime']                vaccineNewsItem['md5'] = self.md5_str(str=title)                vaccineNewsItem['keyword'] = keyWord                newSets.add(vaccineNewsItem)                yield vaccineNewsItem        if curPage < pageSize:            curPage = curPage+1            url = self.url_format % (keyWord, curPage)            print(url)            yield scrapy.Request(url, callback=self.parse_json)    def md5_str(self, str):        m = MD5.new()        m.update(str.encode("utf-8"))        return m.hexdigest()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码为请求 url 并解析请求数据。</p><h2 id="5-2-写入数据库"><a href="#5-2-写入数据库" class="headerlink" title="5.2 写入数据库"></a>5.2 写入数据库</h2><p>首先：VaccinePipeline.py 中配置通道相关信息，比如数据库链接配置，数据实体映射配置，插入数据执行sql配置等。</p><p>其次：setting.py 中 激活通道，并配置优先级</p><pre class="line-numbers language-py"><code class="language-py">ITEM_PIPELINES = {    'vaccine.pipelines.MySQLPipeLine': 300, }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过以上基本就可以跑起来了。运行中有任何问题欢迎反馈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于疫苗的python爬虫脚本，主要爬新华网。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="http://www.yusuzi.cn/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.yusuzi.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mysql explain详解和最佳实践</title>
    <link href="http://www.yusuzi.cn/2020/08/05/Mysql-explain%E8%AF%A6%E8%A7%A3%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.yusuzi.cn/2020/08/05/Mysql-explain详解和最佳实践/</id>
    <published>2020-08-05T15:40:00.000Z</published>
    <updated>2020-08-21T04:56:19.793Z</updated>
    
    <content type="html"><![CDATA[<p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈。</p><a id="more"></a><p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）</p><h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>actor<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>actor<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>actor<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>update_time<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'2017-12-22 15:27:18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>film<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>film<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_name<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>film<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'film0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'film1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'film2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>film_actor<span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>film_actor<span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>film_id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>actor_id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>remark<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_film_actor_id<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>film_id<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>actor_id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span>film_actor<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>film_id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>actor_id<span class="token punctuation">`</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><pre class="line-numbers language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D15C58240983455DA0B494E89385F7EB.jpg" alt="image"></p><p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。表的意义相当广泛：可以是子查询、一个 union 结果等。</p><h2 id="Explain-有两个变种："><a href="#Explain-有两个变种：" class="headerlink" title="Explain 有两个变种："></a>Explain 有两个变种：</h2><h3 id="1-explain-extended："><a href="#1-explain-extended：" class="headerlink" title="1. explain extended："></a>1. explain extended：</h3><p>会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p><pre><code>mysql&gt; explain extended select * from film where id = 1;mysql&gt; show warnings; </code></pre><h3 id="2-explain-partitions："><a href="#2-explain-partitions：" class="headerlink" title="2. explain partitions："></a>2. explain partitions：</h3><p>相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p><h2 id="Explain-中列的含义"><a href="#Explain-中列的含义" class="headerlink" title="Explain 中列的含义"></a>Explain 中列的含义</h2><h3 id="Id-列"><a href="#Id-列" class="headerlink" title="Id 列"></a>Id 列</h3><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。MySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。<br>复杂查询分为三类：简单子查询、派生表（from语句中的子查询）、union 查询。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</p><ol><li>简单子查询</li></ol><pre><code>mysql&gt; explain select (select 1 from actor limit 1) from film;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/10898C201A834EB781EF7BC2C044A816.jpg" alt="image"></p><ol start="2"><li><p>from子句中的子查询</p><pre><code>mysql&gt; explain select id from (select id from film) as der; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/620B5A7572DA4F409C5E211D4836F389.jpg" alt="image"><br>这个查询执行时有个临时表别名为der，外部 select 查询引用了这个临时表.</p></li><li><p>union查询</p><pre><code>mysql&gt; explain select 1 union all select 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7B675D2DD4434EA3BDB670265D0F1548.jpg" alt="image"><br>union结果总是放在一个匿名临时表中，临时表不在SQL中出现，因此它的 id 是 NULL。</p></li></ol><h3 id="select-type列"><a href="#select-type列" class="headerlink" title="select_type列"></a>select_type列</h3><p>select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p><ol><li>simple：简单查询。查询不包含子查询和union</li></ol><pre><code>mysql&gt; explain select * from film where id = 2;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A4615C5FE4434BE395226791172C471E.jpg" alt="image"></p><ol start="2"><li><p>primary：复杂查询中最外层的 select</p></li><li><p>subquery：包含在 select 中的子查询（不在 from 子句中）</p></li><li><p>derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）<br>用这个例子来了解 primary、subquery 和 derived 类型</p><pre><code>mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D6B2A80FE48448A98839C65F70657084.jpg" alt="image"></p></li><li><p>union：在 union 中的第二个和随后的 select</p></li><li><p>union result：从 union 临时表检索结果的 select<br>用这个例子来了解 union 和 union result 类型：</p><pre><code>mysql&gt; explain select 1 union all select 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/99B591DAED3E420B8567C9FDCD1715EE.jpg" alt="image"></p></li></ol><h3 id="table-列"><a href="#table-列" class="headerlink" title="table 列"></a>table 列</h3><p>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table 列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行 id。</p><h3 id="type列"><a href="#type列" class="headerlink" title="type列"></a>type列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref.</p><p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表.</p><pre><code>mysql&gt; explain select min(id) from film; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/99A7592E5BF04B44B13C011C202A4F42.jpg" alt="image"></p><p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是const的特例，表里只有一条元组匹配时为system</p><pre><code>mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B0008777242C4F9DB30CE6481DD6321F.jpg" alt="image"></p><pre><code>mysql&gt; show warnings; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8F7B3AA78C9D4D658052DFDC4EAB5395.jpg" alt="image"></p><p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p><pre><code>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FA04A7F60F9B44FAB02D7F2EB39C83EF.jpg" alt="image"></p><p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p><ol><li><p>简单 select 查询，name是普通索引（非唯一索引） </p><pre><code>mysql&gt; explain select * from film where name = &quot;film1&quot;; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0C68CC0AA000435EA7DEBB1F2C3F3951.jpg" alt="image"></p></li><li><p>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。 </p><pre><code>mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7CBD03DB6EB8436186FD10E0151B8C5D.jpg" alt="image"></p></li></ol><p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p><pre><code>mysql&gt; explain select * from actor where id &gt; 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FCE44E2B4262490F8088E4FDCFCBD308.jpg" alt="image"></p><p><strong>index</strong>：扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）</p><pre><code>mysql&gt; explain select * from film; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/03CC238786AE4E489ED2170F2D6BEE26.jpg" alt="image"><br><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p><pre><code>mysql&gt; explain select * from actor; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8369B9614FDA438BAB8F24CC964439A7.jpg" alt="image"></p><h3 id="possible-keys列"><a href="#possible-keys列" class="headerlink" title="possible_keys列"></a>possible_keys列</h3><p>这一列显示查询可能使用哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。 </p><ul><li>key列</li></ul><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p><ul><li>key_len列</li></ul><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p><pre><code>mysql&gt; explain select * from film_actor where film_id = 2;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7849D860315B4AB6AB4FA6DF036E3B5D.jpg" alt="image"></p><blockquote><p>key_len计算规则如下：<br>字符串<br>char(n)：n字节长度<br>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</p><p>数值类型:tinyint：1字节  smallint：2字节 int：4字节<br>bigint：8字节　　</p><p>时间类型　<br>date：3字节<br>timestamp：4字节<br>datetime：8字节</p><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p></blockquote><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p><h3 id="ref列"><a href="#ref列" class="headerlink" title="ref列"></a>ref列</h3><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p><h3 id="rows列"><a href="#rows列" class="headerlink" title="rows列"></a>rows列</h3><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p><h3 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h3><p>这一列展示的是额外信息。常见的重要值如下：</p><p><strong>Using index</strong>：查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高</p><pre><code>mysql&gt; explain select film_id from film_actor where film_id = 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5D3C7CA4BA7F46CB904D2C4B123BA39F.jpg" alt="image"></p><p><strong>Using where</strong>：查询的列未被索引覆盖，where筛选条件非索引的前导列</p><pre><code>mysql&gt; explain select * from actor where name = &#39;a&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/10451AF8BC4E46E2B23058C4F8CA6B71.jpg" alt="image"></p><p><strong>Using where Using index</strong>：查询的列被索引覆盖，并且==where筛选条件是索引列之一但是不是索引的前导列==，意味着无法直接通过索引查找来查询到符合条件的数据</p><pre><code>mysql&gt; explain select film_id from film_actor where actor_id = 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D79204ABDADC4803A8911BD6FFC54944.jpg" alt="image"></p><p><strong>NULL</strong>：查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引</p><pre><code>mysql&gt;explain select * from film_actor where film_id = 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/4E85A87B5E07442F8F017E8F1AD43BB8.jpg" alt="image"></p><p><strong>Using index condition</strong>：与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p><pre><code>mysql&gt; explain select * from film_actor where film_id &gt; 1;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8310AC3EA8804936BB7BDADCDD15AFEC.jpg" alt="image"></p><p><strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><ol><li><p>actor.name 没有索引，此时创建了张临时表来 distinct </p><pre><code>mysql&gt; explain select distinct name from actor; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/6701658087B1421EB24F3EE7F066189B.jpg" alt="image"></p></li><li><p>film.name 建立了idx_name索引，此时查询时extra是using index,没有用临时表 </p><pre><code>mysql&gt; explain select distinct name from film; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8F30FFC5BE9446BE8CC4B829DD269406.jpg" alt="image"></p></li></ol><p><strong>Using filesort</strong>：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p><ol><li><p>actor.name 未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录 </p><pre><code>mysql&gt; explain select * from actor order by name;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C7764DB5AF434C998B20C27CEEE8C7A4.jpg" alt="image"></p></li><li><p>film.name 建立了idx_name索引,此时查询时extra是using index</p><pre><code>mysql&gt; explain select * from film order by name; </code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/28DEB88B1D0D40A29B5E810BD9993F52.jpg" alt="image"></p></li></ol><h1 id="索引最佳实践"><a href="#索引最佳实践" class="headerlink" title="索引最佳实践"></a>索引最佳实践</h1><p>使用的表：</p><pre><code>CREATE TABLE `employees` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(24) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,  `age` int(11) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,  `position` varchar(20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;职位&#39;,  `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;入职时间&#39;,  PRIMARY KEY (`id`),  KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=&#39;员工记录表&#39;;INSERT INTO employees(name,age,position,hire_time) VALUES(&#39;LiLei&#39;,22,&#39;manager&#39;,NOW());INSERT INTO employees(name,age,position,hire_time) VALUES(&#39;HanMeimei&#39;, 23,&#39;dev&#39;,NOW());INSERT INTO employees(name,age,position,hire_time) VALUES(&#39;Lucy&#39;,23,&#39;dev&#39;,NOW());</code></pre><h2 id="最佳实践规则"><a href="#最佳实践规则" class="headerlink" title="最佳实践规则"></a>最佳实践规则</h2><h3 id="1-全值匹配"><a href="#1-全值匹配" class="headerlink" title="1. 全值匹配"></a>1. 全值匹配</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A36DE3157FDD49C3B18EF1E7C3823328.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5D918054B73F4CD1BAEA459DB6880AF0.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B78B7997D4DB407D85CAA1EED8C27828.jpg" alt="image"></p><h3 id="2-最佳左前缀法则"><a href="#2-最佳左前缀法则" class="headerlink" title="2. 最佳左前缀法则"></a>2. 最佳左前缀法则</h3><p>如果索引了多列，要遵守最左前缀法则。指的是查询从引的最左前列开始并且不跳过索引中的列。</p><pre><code>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =&#39;manager&#39;;EXPLAIN SELECT * FROM employees WHERE position = &#39;manager&#39;;EXPLAIN SELECT * FROM employees WHERE name = &#39;LiLei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/AB5FAAFBB2B94D05BD5DDDEA5537A657.jpg" alt="image"></p><h3 id="3-不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描"><a href="#3-不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描" class="headerlink" title="3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描"></a>3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name = &#39;LiLei&#39;;EXPLAIN SELECT * FROM employees WHERE left(name,3) = &#39;LiLei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/220EB6D05CFD4BE287BC311AB11EE6D3.jpg" alt="image"></p><h3 id="4-存储引擎不能使用索引中范围条件右边的列"><a href="#4-存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="4. 存储引擎不能使用索引中范围条件右边的列"></a>4. 存储引擎不能使用索引中范围条件右边的列</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 22 AND position =&#39;manager&#39;;EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age &gt; 22 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/03ACE575E6444B098A09431C06A51AF4.jpg" alt="image"></p><h3 id="5-尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select-语句"><a href="#5-尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select-语句" class="headerlink" title="5. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句"></a>5. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句</h3><pre><code>EXPLAIN SELECT name,age FROM employees WHERE name= &#39;LiLei&#39; AND age = 23 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/52C76F3FA6AB46FF9D491DC5BC07B02E.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name= &#39;LiLei&#39; AND age = 23 AND position =&#39;manager&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/93B9706742EE4B778FCCE0E73583236B.jpg" alt="image"></p><h3 id="6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描"><a href="#6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描" class="headerlink" title="6. mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描"></a>6. mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name != &#39;LiLei&#39;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/801D61263E3E443298EDD09A4B568B98.jpg" alt="image"></p><h3 id="7-is-null-is-not-null-也无法使用索引"><a href="#7-is-null-is-not-null-也无法使用索引" class="headerlink" title="7. is null,is not null 也无法使用索引"></a>7. is null,is not null 也无法使用索引</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name is null</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E6C01DD0BEBB4DD59FC9B6A321420066.jpg" alt="image"></p><h3 id="8-like以通配符开头（’-abc…’）mysql索引失效会变成全表扫描操作"><a href="#8-like以通配符开头（’-abc…’）mysql索引失效会变成全表扫描操作" class="headerlink" title="8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作"></a>8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name like &#39;%Lei&#39;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8069AB8749DF4F94A32B7A615097F406.jpg" alt="image"></p><pre><code>EXPLAIN SELECT * FROM employees WHERE name like &#39;Lei%&#39;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/86DD9D2FA50A491A9657C180B33C16B0.jpg" alt="image"></p><p><strong>问题：解决like’%字符串%’索引不被使用的方法？</strong></p><p>a. 使用覆盖索引，查询字段必须是建立覆盖索引字段</p><pre><code>EXPLAIN SELECT name,age,position FROM employees WHERE name like &#39;%Lei%&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FC9F82F3BF1C4C3D9F635737D8A52A80.jpg" alt="image"></p><p>b. 当覆盖索引指向的字段是 varchar(380) 及 380 以上的字段时，覆盖索引会失效！</p><h3 id="9-字符串不加单引号索引失效"><a href="#9-字符串不加单引号索引失效" class="headerlink" title="9. 字符串不加单引号索引失效"></a>9. 字符串不加单引号索引失效</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name = &#39;1000&#39;;EXPLAIN SELECT * FROM employees WHERE name = 1000;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7951BE0D3C83494680A5203437523D4B.jpg" alt="image"></p><h3 id="10-少用or-用它连接时很多情况下索引会失效"><a href="#10-少用or-用它连接时很多情况下索引会失效" class="headerlink" title="10. 少用or,用它连接时很多情况下索引会失效"></a>10. 少用or,用它连接时很多情况下索引会失效</h3><pre><code>EXPLAIN SELECT * FROM employees WHERE name = &#39;LiLei&#39; or name = &#39;HanMeimei&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CB583B20AE814DB5A7B3C64DA63FF4DD.jpg" alt="image"></p><h2 id="实践总结："><a href="#实践总结：" class="headerlink" title="实践总结："></a>实践总结：</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E473DB8A1C0B4AB59A494790716A08AB.jpg" alt="image"></p><blockquote><p>like KK%相当于=常量，%KK和%KK% 相当于范围</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是 如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.yusuzi.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Mysql索引底层数据结构与算法</title>
    <link href="http://www.yusuzi.cn/2020/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://www.yusuzi.cn/2020/08/05/深入理解Mysql索引底层数据结构与算法/</id>
    <published>2020-08-05T15:38:26.000Z</published>
    <updated>2020-08-21T05:02:21.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、索引优化面试题分析"><a href="#一、索引优化面试题分析" class="headerlink" title="一、索引优化面试题分析"></a>一、索引优化面试题分析</h2><a id="more"></a><p>分析以下几条sql的索引使用情况</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> emp_no<span class="token operator">=</span><span class="token string">'10001'</span> <span class="token operator">AND</span> title<span class="token operator">=</span><span class="token string">'Senior Engineer'</span> <span class="token operator">AND</span> from_date<span class="token operator">=</span><span class="token string">'1986-06-26'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> title<span class="token operator">=</span><span class="token string">'Senior Engineer'</span> <span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> emp_no <span class="token operator">></span> ‘<span class="token number">10001</span><span class="token string">';SELECT * FROM titles WHERE emp_no > ‘10001'</span> <span class="token operator">and</span> title<span class="token operator">=</span><span class="token string">'Senior Engineer'</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> titles <span class="token keyword">WHERE</span> emp_no <span class="token operator">></span> ‘<span class="token number">10001</span>' <span class="token keyword">order</span> <span class="token keyword">BY</span> title<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/56891307BDC64F33A02FBC942C108A50.jpg" alt="image"></p><h2 id="二、索引到底是什么"><a href="#二、索引到底是什么" class="headerlink" title="二、索引到底是什么"></a>二、索引到底是什么</h2><p>索引是帮助MySQL高效获取数据的排好序的数据结构<br>,索引存储在文件里。</p><ul><li>索引结构 二叉树、红黑树、HASH、Btree(B+tree)</li></ul><h3 id="磁盘存储原理"><a href="#磁盘存储原理" class="headerlink" title="磁盘存储原理"></a>磁盘存储原理</h3><p>磁盘存储耗时分为两个部分：</p><ol><li>寻道时间，指针移动时间(速度慢，费时)</li><li>旋转时间，磁盘旋转(速度较快)<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/AF528CD17AC44F86A458243B4FBC4268.jpg" alt="image"></li></ol><p>所以从mysql索引的角度，要减少寻道时间。</p><p>磁盘IO 以页为单位（固定大小 4KB）。所以一次数据库查询或写入操作，要尽可能的减少IO 次数，则每页包含的尽量多的要操作的目标数据。</p><h2 id="三、索引底层数据结构与算法"><a href="#三、索引底层数据结构与算法" class="headerlink" title="三、索引底层数据结构与算法"></a>三、索引底层数据结构与算法</h2><p>树简单分为：二叉树、B树、B+树。<br>度(Degree)-代表节点的数据存储个数，也指代节点最大的子节点个数。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><ol><li>每个节点都（包含叶子节点）存储数据</li><li>节点中的数据 key 从左到右递增排列</li><li>叶子节点不存储指针。</li><li>每个节点的子节点个数m/2&lt;= 个数 &lt;=m,但根节点的节点个数可以不超过m/2。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A27A5822516D41ADA83D082A07ADF8D1.jpg" alt="image"></p><h3 id="B-Tree-B-Tree变种"><a href="#B-Tree-B-Tree变种" class="headerlink" title="B+Tree(B-Tree变种)"></a>B+Tree(B-Tree变种)</h3><ol><li>一般情况下，根节点存储在内存中，其他节点存储在磁盘中</li><li>非叶子节点不存储数据，只存储索引，可以增大度，类似跳表。</li><li>叶子节点不存储指针，存储数据</li><li>每个节点的子节点个数m/2&lt;= 个数 &lt;=m,但根节点的节点个数可以不超过m/2。</li><li>叶子节点不存储指针</li><li>叶子节点是通过链表串在一起（方便区间查找）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CF305DBAECD843518162BBF1F15DD14A.jpg" alt="image"></p><h3 id="B与-B-树的区别"><a href="#B与-B-树的区别" class="headerlink" title="B与 B+树的区别"></a>B与 B+树的区别</h3><ol><li>B+树中的节点不存储数据，只是索引,而 B 树中的节点存储数据。</li><li>B 树中的叶子节点不需要链表来串联。</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="B-Tree-索引的性能分析"><a href="#B-Tree-索引的性能分析" class="headerlink" title="B+Tree 索引的性能分析"></a>B+Tree 索引的性能分析</h4><p>一般使用磁盘I/O次数评价索引结构的优劣</p><ul><li>预读：磁盘一般会顺序向后读取一定长度的数据(页的整数倍)放入内存。</li><li>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用B+Tree节点的大小设为等于一个页，每次新建节点直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点的载入只需一次I/O。</li><li>B+Tree的度d一般会超过100，因此h非常小(一般为3到5之间)</li></ul><h2 id="索引实现"><a href="#索引实现" class="headerlink" title="索引实现"></a>索引实现</h2><p>Mysql 常用存储引擎为：MyISAM 和 InnoDB。在创建表的时候指定存储引擎，</p><h3 id="MyISAM索引实现-非聚集"><a href="#MyISAM索引实现-非聚集" class="headerlink" title="MyISAM索引实现(非聚集)"></a>MyISAM索引实现(非聚集)</h3><p>MyISAM索引文件和数据文件是分离的</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0619AC2863944836AFA2B35232B777E0.jpg" alt="image"></p><h3 id="InnoDB索引实现-聚集"><a href="#InnoDB索引实现-聚集" class="headerlink" title="InnoDB索引实现(聚集)"></a>InnoDB索引实现(聚集)</h3><ol><li>数据文件本身就是索引文件。</li><li>表数据文件本身就是按B+Tree组织的一个索引结构文件。</li><li>聚集索引-叶节点包含了完整的数据记录。</li><li>为什么 InnoDB表必须有主键，并且推荐使用整型的自增主键？<blockquote><p>因为主键索引存储的有数据，基于这个原因，必须要有主键，如果没主键会默认添加一个整型自增主键。</p></blockquote></li><li>为什么非主键索引结构叶子节点存储的是主键值？<br>基于一致性和节省存储空间的考虑，非主键索引节点存储主键值。<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E57C60E2EDAA4863ADBEF76B2A5EAC01.jpg" alt="image"></li></ol><h2 id="联合索引，索引最左前缀原理"><a href="#联合索引，索引最左前缀原理" class="headerlink" title="联合索引，索引最左前缀原理"></a>联合索引，索引最左前缀原理</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/341B6DF11EB34172BA8DA3C2D7BA79B5.jpg" alt="image"></p><p>如果索引了多列，要遵守最左前缀法则。指的是查询从引的最左前列开始并且不跳过索引中的列。</p><p>例：<br>idx(a,b,c)</p><pre><code>select * from table where a=10002 and b=&#39;staff&#39; and c=&#39;199600823&#39;;(Y)select * from table where a=10002;(Y)select * from table where a=10002 and c = &#39;199600823&#39;;(部分索引Y,部分 N)select * from table where b=&#39;staff&#39; and c = &#39;199600823&#39;;(N)elect * from table where b=&#39;staff&#39;;(N)elect * from table where c = &#39;199600823&#39;;(N)</code></pre><table><thead><tr><th>语句</th><th>是否用到索引</th><th>使用的索引</th></tr></thead><tbody><tr><td>where a=3</td><td>Y</td><td>a</td></tr><tr><td>where a=3 and b = 5</td><td>Y</td><td>a，b</td></tr><tr><td>where a=3 and b = 5 and c = 4</td><td>Y</td><td>a，b, c</td></tr><tr><td>where b=3 或者 where b = 3 and c = 4 或者 where c=4</td><td>N</td><td></td></tr><tr><td>where a=3 and c = 5</td><td>Y</td><td>使用到 a,但 c 没有使用，b中间断了</td></tr><tr><td>where a=3 and b&gt;4 and c = 5</td><td>Y</td><td>使用到 a,b,但 c 不能用在范围之后，所以 b 断了。</td></tr><tr><td>where a=3 and b like ‘kk%’ and c = 5</td><td>Y</td><td>只用到 a，b ,c</td></tr><tr><td>where a=3 and b like ‘%kk’ and c = 5</td><td>Y</td><td>只用到 a</td></tr><tr><td>where a=3 and b like ‘%kk%’ and c = 5</td><td>Y</td><td>只用到 a</td></tr><tr><td>where a=3 and b like ‘k%kk%’ and c = 5</td><td>Y</td><td>只用到 a,b,c</td></tr><tr><td><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/9AAD735E36F94A52AFDEDD8B3D2DAA07.jpg" alt="image"></td><td></td><td></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。</p></li><li><p>order by满足两种情况会使用Using index。<br>#1.order by语句使用索引最左前列。<br>#2.使用where子句与order by子句条件列组合满足索引最左前列。</p></li><li><p>尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最佳左前缀法则。</p></li><li><p>如果order by的条件不在索引列上，就会产生Using filesort。</p></li><li><p>group by与order by很类似，其实质是先排序后分组，遵照索引创建顺序的最佳左前缀法则。注意where高于having，能写在where中的限定条件就不要去having限定了。</p></li></ol><p>通俗理解口诀：</p><blockquote></blockquote><pre><code>全值匹配我最爱，最左前缀要遵守；带头大哥不能死，中间兄弟不能断；索引列上少计算，范围之后全失效；LIKE百分写最右，覆盖索引不写星；不等空值还有or，索引失效要少用。</code></pre><p><strong>补充：in和exsits优化</strong></p><p>原则：小表驱动大表，即小的数据集驱动大的数据集</p><p>in：当B表的数据集必须小于A表的数据集时，in优于exists</p><pre><code>select * from A where id in (select id from B)#等价于：　　for select id from B　　for select * from A where A.id = B.id</code></pre><p>exists：当A表的数据集小于B表的数据集时，exists优于in<br>　　将主查询A的数据，放到子查询B中做条件验证，根据验证结果（true或false）来决定主查询的数据是否保留</p><pre><code>select * from A where exists (select 1 from B where B.id = A.id)#等价于    for select * from A    for select * from B where B.id = A.id</code></pre><p>A表与B表的ID字段应建立索引</p><blockquote></blockquote><ol><li>EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以是SELECT 1或select X,官方说法是实际执行时会忽略SELECT清单,因此没有区别</li><li>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比</li><li>EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、索引优化面试题分析&quot;&gt;&lt;a href=&quot;#一、索引优化面试题分析&quot; class=&quot;headerlink&quot; title=&quot;一、索引优化面试题分析&quot;&gt;&lt;/a&gt;一、索引优化面试题分析&lt;/h2&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.yusuzi.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>深入理解MySql锁 和事物隔离级别</title>
    <link href="http://www.yusuzi.cn/2020/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3MySql%E9%94%81-%E5%92%8C%E4%BA%8B%E7%89%A9%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://www.yusuzi.cn/2020/08/05/深入理解MySql锁-和事物隔离级别/</id>
    <published>2020-08-05T15:36:29.000Z</published>
    <updated>2020-08-21T05:02:27.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><a id="more"></a><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><ul><li>从性能上分为乐观锁(用版本对比来实现)和悲观锁</li><li>从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)<ol><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响</li><li>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ol></li><li>从对数据操作的粒度分，分为表锁和行锁</li></ul><h1 id="二、三种锁"><a href="#二、三种锁" class="headerlink" title="二、三种锁"></a>二、三种锁</h1><h2 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h2><p>表锁偏向MyISAM存储引擎，开销小，加锁快，无思索，锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>建表SQL<pre><code>CREATE TABLE `mylock` (`id` INT (11) NOT NULL AUTO_INCREMENT,`NAME` VARCHAR (20) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE = MyISAM DEFAULT CHARSET = utf8;</code></pre></li><li>插入数据<pre><code>INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;1&#39;, &#39;a&#39;);INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;2&#39;, &#39;b&#39;);INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;3&#39;, &#39;c&#39;);INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES (&#39;4&#39;, &#39;d&#39;);</code></pre></li><li>手动增加表锁<pre><code>lock table 表名称 read(write),表名称2 read(write);</code></pre></li><li>查看表上加过的锁<pre><code>show open tables;</code></pre></li><li>删除表锁<pre><code>unlock tables;</code></pre></li></ul><h3 id="案例分析-加读-写锁）"><a href="#案例分析-加读-写锁）" class="headerlink" title="案例分析(加读/写锁）"></a>案例分析(加读/写锁）</h3><ul><li><p>添加读锁<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BFE8ADDD90014C6BBB0BBE036AD3A63D.jpg" alt="image"><br>当前session和其他session都可以读该表<br>当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待</p></li><li><p>加写锁<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C461F77F31324DD18959B693CBE9F650.jpg" alt="image"><br>当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞</p></li></ul><h3 id="案例结论"><a href="#案例结论" class="headerlink" title="案例结论"></a>案例结论</h3><p>MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作前,会自动给涉及的表加写锁。</p><ol><li>对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。</li><li>对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作</li></ol><p><strong>总结：</strong><br>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p><h2 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h2><p>行锁偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。InnoDB 与 MYISAM 的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p><h3 id="行锁支持事务"><a href="#行锁支持事务" class="headerlink" title="行锁支持事务"></a>行锁支持事务</h3><ul><li>事务（Transaction）及其ACID属性</li></ul><p>事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。</p><p>**原子性(Atomicity)**：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。</p><p>**一致性(Consistent)**：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性;事务结束时,所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。</p><p>**隔离性(Isolation)**：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</p><p>**持久性(Durable)**：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</p><ul><li>并发事务处理带来的问题</li></ul><p>更新丢失（Lost Update）当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p><ol><li><strong>脏读(Dirty Reads)</strong><br>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。<br>==一句话==：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</li><li><strong>不可重读(Non-Repeatable Reads)</strong><br>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。<br>==一句话==：事务A读取到了事务B已经提交的修改数据，不符合隔离性。</li><li><strong>幻读（Phantom Reads）</strong><br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。<br>==一句话==：事务A读取到了事务B提交的新增数据，不符合隔离性，脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。</li></ol><p>事务隔离级别<br>脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/93E21899E14C49588AA24EDA089B6AC7.jpg" alt="image"></p><p>数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。</p><p>同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读”和“幻读”并不敏感,可能更关心数据并发访问的能力。</p><p>常看当前数据库的事务隔离级别: </p><pre><code>show variables like &#39;tx_isolation&#39;;</code></pre><p>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</p><h3 id="行锁案例分析结论"><a href="#行锁案例分析结论" class="headerlink" title="行锁案例分析结论"></a>行锁案例分析结论</h3><p>在开启事务的情况下，Session_1 更新某一行，Session_2 更新同一行被阻塞，但是更新其他行正常。</p><h3 id="隔离级别案例分析"><a href="#隔离级别案例分析" class="headerlink" title="隔离级别案例分析"></a>隔离级别案例分析</h3><pre><code>CREATE TABLE `account` (  `id` int(11) NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `balance` int(11) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;lilei&#39;, &#39;450&#39;);INSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;hanmei&#39;, &#39;16000&#39;);INSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;lucy&#39;, &#39;2400&#39;);</code></pre><ul><li>读未提交：</li></ul><ol><li><p>打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），查询表account的初始值：</p><pre><code>set tx_isolation=&#39;read-uncommitted&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CDED85F0DF60461A9E2D7092AB8EF2FA.jpg" alt="image"></p></li><li><p>在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/403767AE76FE45DDA2BA39966EBB504E.jpg" alt="image"></p><ol start="3"><li>这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/699F1A3528B746EFA38CC4C0AF87F450.jpg" alt="image"></p><ol start="4"><li>一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A7C1D41774A1443BAF3405874BBAD8EE.jpg" alt="image"></p><ol start="5"><li>在客户端A执行更新语句<code>update account set balance = balance - 50 where id =1</code>，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，==如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别==</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/74461B8919624E67A96DD8B617151680.jpg" alt="image"></p><ul><li>读已提交</li></ul><ol><li><p>打开一个客户端A，并设置当前事务模式为read committed（未提交读），查询表account的所有记录：</p><pre><code>set tx_isolation=&#39;read-committed&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3CF7411455184AB69905A49EAE33799C.jpg" alt="image"></p></li><li><p>在客户端A的事务提交之前，打开另一个客户端B，更新表account.</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F9521950E2204FBDAC8B87285480D4B9.jpg" alt="image"></p><ol start="3"><li>这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1A9DE283DA394653B31752A9AC6A7441.jpg" alt="image"></p><ol start="4"><li>客户端B的事务提交</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BA04776FFF0A49879D440E0ABB1CFF87.jpg" alt="image"><br>5. 客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1CB8D92B7BC5412F8A9C85397AF40B51.jpg" alt="image"></p><ul><li>可重复读</li></ul><ol><li>打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录</li></ol><pre><code>set tx_isolation=&#39;repeatable-read&#39;;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5A48F50168B249F18207E466FC05F3DA.jpg" alt="image"></p><ol start="2"><li>在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BF5B9C07539B450BB6E35AE36C1DD2B1.jpg" alt="image"></p><ol start="3"><li>在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/074ED7B01BE74D57A896ABA9CDB2C19E.jpg" alt="image"></p><ol start="4"><li>在客户端A，接着执行update balance = balance - 50 where id = 1，balance没有变成400-50=350，lilei的balance值用的是步骤（2）中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3D0CF09EA3324E4FB7CA05DD2A1E2E85.jpg" alt="image"></p><ol start="5"><li>重新打开客户端B，插入一条新数据后提交</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/9F567B7BC1314EE6A95B27595003AACD.jpg" alt="image"></p><ol start="6"><li>在客户端A查询表account的所有记录，没有 查出 新增数据，所以没有出现幻读</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7962D7EB0B33471DB68CDE7650782F1C.jpg" alt="image"> </p><ol start="7"><li>验证幻读<br>在客户端A执行update account set balance=888 where id = 4;能更新成功，再次查询能查到客户端B新增的数据.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/DB875DCAD8124843AD598E2C2F592D94.jpg" alt="image"></p><ul><li>串行化</li></ul><ol><li>打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：</li></ol><pre><code>set tx_isolation=&#39;serializable&#39;; mysql&gt; set session transaction isolation level serializable; Query OK, 0 rows affected (0.00 sec)  mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec)  mysql&gt; select * from account; +------+--------+---------+| id   | name   | balance |+------+--------+---------+|    1 | lilei  |   10000 ||    2 | hanmei |   10000 ||    3 | lucy   |   10000 ||    4 | lily   |   10000 |+------+--------+---------+4 rows in set (0.00 sec)</code></pre><ol start="2"><li>打开一个客户端B，并设置当前事务模式为serializable，插入一条记录报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，这种隔离级别并发性极低，开发中很少会用到。</li></ol><pre><code>mysql&gt; set session transaction isolation level serializable; Query OK, 0 rows affected (0.00 sec)  mysql&gt; start transaction; Query OK, 0 rows affected (0.00 sec) mysql&gt; insert into account values(5,&#39;tom&#39;,0); ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</code></pre><ol start="3"><li>Mysql默认级别是repeatable-read，有办法解决幻读问题吗？</li></ol><p>间隙锁在某些情况下可以解决幻读问题, 要避免幻读可以用间隙锁在Session_1下面执行</p><pre><code>update account set name = &#39;zhuge&#39; where id &gt; 10 and id &lt;=20;</code></pre><p>则其他Session没法插入这个范围内的数据</p><h3 id="案例结论-1"><a href="#案例结论-1" class="headerlink" title="案例结论"></a>案例结论</h3><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和MYISAM相比就会有比较明显的优势了。</p><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。</p><h3 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h3><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><pre><code>show status like&#39;innodb_row_lock%&#39;;</code></pre><p>对各个状态量的说明如下：</p><blockquote><p>Innodb_row_lock_current_waits: 当前正在等待锁定的数量</p><p>Innodb_row_lock_time: 从系统启动到现在锁定总时间长度</p><p>Innodb_row_lock_time_avg: 每次等待所花平均时间</p><p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间</p><p>Innodb_row_lock_waits:系统启动后到现在总共等待的次数</p><p>对于这5个状态变量，比较重要的主要是：</p><p>Innodb_row_lock_time_avg （等待平均时长）</p><p>Innodb_row_lock_waits （等待总次数）</p><p>Innodb_row_lock_time（等待总时长）</p></blockquote><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><pre><code>set tx_isolation=&#39;repeatable-read&#39;;Session_1执行：select * from account where id=1 for update;Session_2执行：select * from account where id=2 for update;Session_1执行：select * from account where id=2 for update;Session_2执行：select * from account where id=1 for update;</code></pre><p>查看近期死锁日志信息：</p><pre><code>show engine innodb status; </code></pre><p>大多数情况mysql可以自动检测死锁并回滚产生死锁的那个事务，但是有些情况mysql没法自动检测死锁</p><h1 id="三、关于锁的优化建议"><a href="#三、关于锁的优化建议" class="headerlink" title="三、关于锁的优化建议"></a>三、关于锁的优化建议</h1><ol><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;锁是计算机协调多个进程或线程并发访问某一资源的机制。&lt;br&gt;在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数据库" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.yusuzi.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>线程通信的方式</title>
    <link href="http://www.yusuzi.cn/2020/07/31/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.yusuzi.cn/2020/07/31/线程通信的方式/</id>
    <published>2020-07-31T09:49:53.000Z</published>
    <updated>2020-08-21T04:40:32.285Z</updated>
    
    <content type="html"><![CDATA[<p>线程通信也就是线程之间的协作方式。</p><a id="more"></a><h1 id="1-线程协作的方式"><a href="#1-线程协作的方式" class="headerlink" title="1. 线程协作的方式"></a>1. 线程协作的方式</h1><p>要想实现多个线程之间的通信协作<br>如： 线程执行的先后顺序、获取某个线程执行的结果等。</p><p>涉及到线程之间的相互通信/协作，可以分为 以下四类：</p><ol><li><p>文件共享</p></li><li><p>网络共享</p></li><li><p>共享变量</p></li><li><p>JDK 提供的线程协同 API </p><ol><li>suppend/resume  (已经弃用)</li><li>wait/notify</li><li>park/unpark</li></ol></li><li><p>管道通信</p></li></ol><p>下面主要针对 共享变量 和 JDK 提供的线程协作 API 来做个梳理。</p><h1 id="2-共享变量"><a href="#2-共享变量" class="headerlink" title="2. 共享变量"></a>2. 共享变量</h1><p>所谓共享变量，即通过一个线程之间可以共享的变量来达到线程之间通信的目的。</p><p>根据 JVM 的特性，线程之间能够共享的变量方式，即 静态变量。</p><h2 id="共享变量代码示例"><a href="#共享变量代码示例" class="headerlink" title="共享变量代码示例"></a>共享变量代码示例</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>hc<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>chapter1<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 定义共享变量</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> String content <span class="token operator">=</span> <span class="token string">"空"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 线程1 - 写入数据</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          content <span class="token operator">=</span> <span class="token string">"当前时间"</span> <span class="token operator">+</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 线程2 - 读取数据</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程 1 对静态变量 content 做更改，则 线程 2 可以访问更改过的值。</p><h1 id="3-JDK-提供的线程协同-API"><a href="#3-JDK-提供的线程协同-API" class="headerlink" title="3. JDK 提供的线程协同 API"></a>3. JDK 提供的线程协同 API</h1><p>JDK 中对于需要多线程协作完成某一任务的场景，提供了对应的 API 支持。多线程协作的典型场景是：生产者-消费者模型。（线程阻塞、线程唤醒）。</p><p>下面通过一个场景来看 jdk 提供的线程协同 api 并做个对比。</p><p>场景是这样子：</p><blockquote><p>线程-1 去买包子，没有包子，则不再执行。线程-2 生产包子，通知线程继续执行，线程1收到通知继续买包子。</p></blockquote><p>流程图如下</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C7A478DEEB2D4E9482227967CCCA941E.jpg" alt="image"></p><h2 id="3-1-suspend-resume"><a href="#3-1-suspend-resume" class="headerlink" title="3.1 suspend/resume"></a>3.1 suspend/resume</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo6</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 包子店 */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object baozidian <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 正常的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动一个线程 consumerThread 购买包子，如果没包子，则进入等待 调用 <code>suspend()</code>,主线程 3秒之后生产一个包子，然后唤醒其他线程<code>resume()</code>。consumerThread 被唤醒继续执行 <code>3、买到包子，回家</code>。</p><p>按照正常逻辑以上代码没有问题，但是如果是以下方式呢？</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** 死锁的suspend/resume。 suspend并不会像wait一样释放锁，故此容易写出死锁代码 */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 导致程序永久挂起的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、没包子，进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 为这个线程加上一点延时</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 这里的挂起执行在resume后面</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上两种方式都是死锁的写法。</p><ul><li>suspendResumeDeadLockTest 写法中 suspend 并不释放锁，一直持有锁，导致主线程获取不到锁，不能执行 <code>resume()</code>唤醒操作， 故此容易写出死锁代码 。</li><li>suspendResumeDeadLockTest2 写法种，由于线程休眠的问题，导致<code>resume()</code> 再 <code>suspend()</code>之前调用，由于后续没有调用 <code>resume()</code>的操作，导致死锁。</li></ul><h2 id="3-2-notify-wait"><a href="#3-2-notify-wait" class="headerlink" title="3.2 notify/wait"></a>3.2 notify/wait</h2><p>notify / wait 必须再 synchronized 代码块中才会有效，而且 <code>wait</code> 和 <code>notify()</code> 调用之后会自动释放持有的锁。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 正常的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是也会写出死锁的代码，比如以下写法：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** 会导致程序永久等待的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然 <code>wait()</code> 会自动解锁，但是对顺序有要求。 如果 <code>wait()</code> 方法，是在 <code>notify</code> 之后调用，则线程会永远处于 <code>waitting</code> 状态。</p><h2 id="3-3-park-unpark"><a href="#3-3-park-unpark" class="headerlink" title="3.3 park/unpark"></a>3.3 park/unpark</h2><p><code>park</code> 是等待许可，<code>unpark</code> 是为指定线程提供许可，他的主要特性就是对顺序没有要求，调用<code>park</code>时候，如果调用过 <code>unpark</code> 则，线程直接执行。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 正常的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是 <code>unpark</code> 调用之后，许可只能使用一次。即只要调一次park，则许可就会失效。后续调用 <code>park</code>，则该线程会进入等待状态。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** 死锁的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-所有代码"><a href="#3-4-所有代码" class="headerlink" title="3.4 所有代码"></a>3.4 所有代码</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>hc<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>chapter1<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>LockSupport<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 三种线程协作通信的方式：suspend/resume、wait/notify、park/unpark */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo6</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 包子店 */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object baozidian <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 正常的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 死锁的suspend/resume。 suspend并不会像wait一样释放锁，故此容易写出死锁代码 */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 导致程序永久挂起的suspend/resume */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendResumeDeadLockTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、没包子，进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 为这个线程加上一点延时</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 这里的挂起执行在resume后面</span>                Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 正常的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 会导致程序永久等待的wait/notify */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitNotifyDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 正常的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 死锁的park/unpark */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">parkUnparkDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 启动线程</span>        Thread consumerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>baozidian <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果没包子，则进入等待</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1、进入等待"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 当前线程拿到锁，然后挂起</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2、买到包子，回家"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumerThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3秒之后，生产一个包子</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        baozidian <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 争取到锁以后，再恢复consumerThread</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>consumerThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3、通知消费者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对调用顺序有要求，也要开发自己注意锁的释放。这个被弃用的API， 容易死锁，也容易导致永久挂起。</span><span class="token comment" spellcheck="true">//         new Demo6().suspendResumeTest();</span><span class="token comment" spellcheck="true">//         new Demo6().suspendResumeDeadLockTest();</span><span class="token comment" spellcheck="true">//         new Demo6().suspendResumeDeadLockTest2();</span>        <span class="token comment" spellcheck="true">// wait/notify要求再同步关键字里面使用，免去了死锁的困扰，但是一定要先调用wait，再调用notify，否则永久等待了</span>        <span class="token comment" spellcheck="true">// new Demo6().waitNotifyTest();</span><span class="token comment" spellcheck="true">//         new Demo6().waitNotifyDeadLockTest();</span>        <span class="token comment" spellcheck="true">// park/unpark没有顺序要求，但是park并不会释放锁，所有再同步代码中使用要注意</span><span class="token comment" spellcheck="true">//         new Demo6().parkUnparkTest();</span>         <span class="token keyword">new</span> <span class="token class-name">Demo6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parkUnparkDeadLockTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ol><li><p><strong>suspend 和 resume</strong> 容易写出死锁代码所以被弃用，导致死锁的原因： suspend 挂起之后不会释放锁；suspend 和 resume 先后顺序不保证。</p></li><li><p><strong>wait 和 notify</strong>。只能由同一对象锁的持有者线程调用，也就是说写在代码同步块里，否则会抛出 IllegalMonitorStateException 异常。wait 方法导致当前线程等待，加入该对象的等待集合中，并且 放弃当前持有的对象锁。notify 和 notifyAll 方法唤醒一个或所有正在等待这个对象锁的线程。</p><blockquote><p>注意：虽然  wait 会自动解锁，但是对顺序有要求。 如果 wait 方法，是在 notify 之后调用，则线程会永远处于 waitting 状态。</p></blockquote></li><li><p><strong>park / unpark</strong> park 是等待许可，unpark 是为指定线程提供许可，对顺序没有要求，调用park时候，如果调用过 unpark 则，线程直接执行。但由于许可的一次有效性，即只要调一次park，则许可就会失效。后续调用park，则该线程会进入等待状态。</p></li></ol><p><strong>伪唤醒问题</strong> 由于 jvm 在实现机制问题，通过以上三种方式会出现错误警报或伪唤醒的问题，这时并不是真正的满足条件唤醒。如果 通过 if 语句判断是否为空，来使线程进入等待状态，则会也会出现异常情况。</p><p>所以建议 通过 while 循环的写法，然后设置 flag 来检测线程的等待条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程通信也就是线程之间的协作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="并发编程" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>kafka 集群搭建</title>
    <link href="http://www.yusuzi.cn/2020/07/25/kafka-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.yusuzi.cn/2020/07/25/kafka-集群搭建/</id>
    <published>2020-07-25T04:30:57.000Z</published>
    <updated>2020-08-21T04:54:27.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装前的环境准备"><a href="#1-安装前的环境准备" class="headerlink" title="1. 安装前的环境准备"></a>1. 安装前的环境准备</h1><p>由于Kafka是用Scala语言开发的，运行在JVM上，因此在安装Kafka之前需要先安装JDK。</p><a id="more"></a><pre><code># yum install java-1.8.0-openjdk* -y</code></pre><p>kafka依赖zookeeper，所以需要先安装zookeeper</p><pre><code># wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz# tar -zxvf zookeeper-3.4.12.tar.gz# cd zookeeper-3.4.12# cp conf/zoo_sample.cfg conf/zoo.cfg</code></pre><p>启动zookeeper</p><pre><code># bin/zkServer.sh start# bin/zkCli.sh # ls /            #查看zk的根目录相关节点</code></pre><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="第一步：下载安装包"><a href="#第一步：下载安装包" class="headerlink" title="第一步：下载安装包"></a>第一步：下载安装包</h2><p>下载1.1.0 release版本，并解压：</p><pre><code># wget https://archive.apache.org/dist/kafka/1.1.0/kafka_2.11-1.1.0.tgz# tar -xzf kafka_2.11-1.1.0.tgz# cd kafka_2.11-1.1.0</code></pre><h2 id="第二步：启动服务"><a href="#第二步：启动服务" class="headerlink" title="第二步：启动服务"></a>第二步：启动服务</h2><p>现在来启动kafka服务：<br>启动脚本语法：</p><pre><code>kafka-server-start.sh [-daemon] server.properties</code></pre><p>可以看到，server.properties的配置路径是一个强制的参数，-daemon表示以后台进程运行，否则ssh客户端退出后，就会停止服务。(注意，在启动kafka时会使用linux主机名关联的ip地址，所以需要把主机名和linux的ip映射配置到本地host里，用vim /etc/hosts)</p><pre><code># bin/kafka-server-start.sh -daemon config/server.properties</code></pre><p>我们进入zookeeper目录通过zookeeper客户端查看下zookeeper的目录树</p><pre><code># bin/zkCli.sh # ls /            #查看zk的根目录kafka相关节点# ls /brokers/ids    #查看kafka节点</code></pre><h1 id="3-创建主题"><a href="#3-创建主题" class="headerlink" title="3. 创建主题"></a>3. 创建主题</h1><p>现在我们来创建一个名字为“test”的Topic，这个topic只有一个partition，并且备份因子也设置为1：</p><pre><code># bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</code></pre><p>现在我们可以通过以下命令来查看kafka中目前存在的topic</p><pre><code># bin/kafka-topics.sh --list --zookeeper localhost:2181</code></pre><p>除了我们通过手工的方式创建Topic，我们可以配置broker，当producer发布一个消息某个指定的Topic，但是这个Topic并不存在时，就自动创建。</p><h1 id="4-发送消息"><a href="#4-发送消息" class="headerlink" title="4. 发送消息"></a>4. 发送消息</h1><p>kafka自带了一个producer命令客户端，可以从本地文件中读取内容，或者我们也可以以命令行中直接输入内容，并将这些内容以消息的形式发送到kafka集群中。在默认情况下，每一个行会被当做成一个独立的消息。<br>首先我们要运行发布消息的脚本，然后在命令中输入要发送的消息的内容：</p><pre><code># bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test &gt;this is a msg&gt;this is a another msg </code></pre><h1 id="5-消费消息"><a href="#5-消费消息" class="headerlink" title="5. 消费消息"></a>5. 消费消息</h1><p>对于consumer，kafka同样也携带了一个命令行客户端，会将获取到内容在命令中进行输出：</p><pre><code># bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test   --from-beginning #老版本# bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --consumer-property group.id=testGroup --consumer-property client.id=consumer-1  --topic test    #新版本</code></pre><p>如果你是通过不同的终端窗口来运行以上的命令，你将会看到在producer终端输入的内容，很快就会在consumer的终端窗口上显示出来。<br>以上所有的命令都有一些附加的选项；当我们不携带任何参数运行命令的时候，将会显示出这个命令的详细用法。<br>还有一些其他命令如下：<br>查看组名</p><pre><code>#  bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list --new-consumer</code></pre><p>查看消费者的消费偏移量</p><pre><code># bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group testGroup</code></pre><p>消费多主题</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --whitelist &quot;test|test-2&quot;</code></pre><h2 id="5-1-单播消费"><a href="#5-1-单播消费" class="headerlink" title="5.1 单播消费"></a>5.1 单播消费</h2><p>一条消息只能被某一个消费者消费的模式，类似queue模式，只需让所有消费者在同一个消费组里即可<br>分别在两个客户端执行如下消费命令，然后往主题里发送消息，结果只有一个客户端能收到消息</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --consumer-property group.id=testGroup --topic test </code></pre><h2 id="5-2-多播消费"><a href="#5-2-多播消费" class="headerlink" title="5.2 多播消费"></a>5.2 多播消费</h2><p>一条消息能被多个消费者消费的模式，类似publish-subscribe模式费，针对Kafka同一条消息只能被同一个消费组下的某一个消费者消费的特性，要实现多播只要保证这些消费者属于不同的消费组即可。我们再增加一个消费者，该消费者属于testGroup-2消费组，结果两个客户端都能收到消息</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092  --consumer-property group.id=testGroup-2 --topic test </code></pre><h1 id="6-kafka集群配置"><a href="#6-kafka集群配置" class="headerlink" title="6. kafka集群配置"></a>6. kafka集群配置</h1><p>到目前为止，我们都是在一个单节点上运行broker，这并没有什么意思。对于kafka来说，一个单独的broker意味着kafka集群中只有一个接点。要想增加kafka集群中的节点数量，只需要多启动几个broker实例即可。为了有更好的理解，现在我们在一台机器上同时启动三个broker实例。</p><h2 id="6-1-第一步配置文件"><a href="#6-1-第一步配置文件" class="headerlink" title="6.1 第一步配置文件"></a>6.1 第一步配置文件</h2><p>我们需要建立好其他2个broker的配置文件：</p><pre><code># cp config/server.properties config/server-1.properties# cp config/server.properties config/server-2.properties</code></pre><pre><code>配置文件的内容分别如下：config/server-1.properties:    broker.id=1    listeners=PLAINTEXT://:9093    log.dir=/tmp/kafka-logs-1config/server-2.properties:    broker.id=2    listeners=PLAINTEXT://:9094    log.dir=/tmp/kafka-logs-2</code></pre><p><strong>broker.id</strong> 属性在kafka集群中必须要是唯一的。</p><p>我们需要重新指定port和log目录，因为我们是在同一台机器上运行多个实例。如果不进行修改的话，consumer 只能获取到一个 instance 实例的信息，或者是相互之间的数据会被影响。<br>目前我们已经有一个zookeeper实例和一个broker实例在运行了.</p><h2 id="6-2-第二步-启动实例"><a href="#6-2-第二步-启动实例" class="headerlink" title="6.2 第二步 启动实例"></a>6.2 第二步 启动实例</h2><p>现在我们只需要在启动2个broker实例即可：</p><pre><code># bin/kafka-server-start.sh -daemon config/server-1.properties# bin/kafka-server-start.sh -daemon config/server-2.properties</code></pre><h2 id="6-3-第三步-创建新的topic"><a href="#6-3-第三步-创建新的topic" class="headerlink" title="6.3 第三步 创建新的topic"></a>6.3 第三步 创建新的topic</h2><p>现在我们创建一个新的topic，备份因子设置为3：</p><pre><code># bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic my-replicated-topic</code></pre><p>现在我们已经有了集群，并且创建了一个3个备份因子的topic，但是到底是哪一个broker在为这个topic提供服务呢(因为我们只有一个分区，所以肯定同时只有一个broker在处理这个topic)？</p><pre><code># bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/4A84105C94DF433286557C4A47EB2087.jpg" alt="image"></p><blockquote><p>以下是输出内容的解释，第一行是所有分区的概要信息，之后的每一行表示每一个partition的信息。因为目前我们只有一个partition，因此关于partition的信息只有一行。<br>leader节点负责给定partition的所有读写请求。<br>replicas 表示某个partition在哪几个broker上存在备份。不管这个几点是不是”leader“，甚至这个节点挂了，也会列出。<br>isr 是replicas的一个子集，它只列出当前还存活着的，并且备份了该partition的节点。</p></blockquote><p>现在我们的案例中，0号节点是leader，即使用server.properties 启动的那个进程。</p><h2 id="6-4-第四步-发送消息"><a href="#6-4-第四步-发送消息" class="headerlink" title="6.4 第四步 发送消息"></a>6.4 第四步 发送消息</h2><p>现在我们向新建的topic中发送一些message：</p><pre><code># bin/kafka-console-producer.sh --broker-list localhost:9092 --topic my-replicated-topic&gt;my test msg 1&gt;my test msg 2</code></pre><h2 id="6-5-第五步-消费消息"><a href="#6-5-第五步-消费消息" class="headerlink" title="6.5 第五步 消费消息"></a>6.5 第五步 消费消息</h2><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic my-replicated-topicmy test msg 1my test msg 2</code></pre><h2 id="6-6-第六步-测试容错性"><a href="#6-6-第六步-测试容错性" class="headerlink" title="6.6 第六步 测试容错性"></a>6.6 第六步 测试容错性</h2><p>现在我们来测试我们容错性，因为broker0目前是leader，所以我们要将其kill</p><pre><code># ps -ef | grep server.properties# kill -9 1177</code></pre><p>现在再执行命令：</p><pre><code># bin/kafka-topics.sh --describe --zookeeper localhost:9092 --topic my-replicated-topic</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F9EE7EAD337748ABB25CB8BE81179AC8.jpg" alt="image"></p><blockquote><p>我们可以看到，leader节点已经变成了broker 2.要注意的是，在Isr中，已经没有了0号节点。leader的选举也是从ISR(in-sync replica)中进行的。</p></blockquote><p>此时，我们依然可以 消费新消息</p><pre><code># bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic my-replicated-topicmy test msg 1my test msg 2</code></pre><p>查看主题分区对应的leader信息：</p><p>需要通过zk 客户端查看：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/1A9C68F18131409E844516D103E78B50.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-安装前的环境准备&quot;&gt;&lt;a href=&quot;#1-安装前的环境准备&quot; class=&quot;headerlink&quot; title=&quot;1. 安装前的环境准备&quot;&gt;&lt;/a&gt;1. 安装前的环境准备&lt;/h1&gt;&lt;p&gt;由于Kafka是用Scala语言开发的，运行在JVM上，因此在安装Kafka之前需要先安装JDK。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
      <category term="MQ" scheme="http://www.yusuzi.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>kafka 概念和原理详解</title>
    <link href="http://www.yusuzi.cn/2020/07/22/kafka-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.yusuzi.cn/2020/07/22/kafka-概念和原理详解/</id>
    <published>2020-07-22T04:28:51.000Z</published>
    <updated>2020-08-21T04:56:34.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，使用Scala编写。<br>对于熟悉JMS（Java Message Service）规范的同学来说，消息系统已经不是什么新概念了(例如ActiveMQ，RabbitMQ等)。</p><a id="more"></a><p>Kafka 拥有作为一个消息系统应该具备的功能，但是确有着独特的设计。可以这样来说，Kafka 借鉴了JMS规范的思想，但是确并没有完全遵循JMS规范。</p><p>kafka是一个分布式的，分区的消息(官方称之为commit log)服务。它提供一个消息系统应该具备的功能，但是确有着独特的设计。</p><h2 id="1-1-首先，让我们来看一下基础的消息-Message-相关术语"><a href="#1-1-首先，让我们来看一下基础的消息-Message-相关术语" class="headerlink" title="1.1 首先，让我们来看一下基础的消息(Message)相关术语"></a>1.1 首先，让我们来看一下基础的消息(Message)相关术语</h2><ul><li>Topic: Kafka按照Topic分类来维护消息</li><li>Producer： 我们将发布(publish)消息到Topic的进程称之为生产者(producer)</li><li>Consumer： 我们将订阅(subscribe)Topic并且处理Topic中消息的进程称之为消费者(consumer)</li><li>Broker：Kafka以集群的方式运行，集群中的每一台服务器称之为一个代理(broker)。</li></ul><p>因此，从一个较高的层面上来看，producers通过网络发送消息到Kafka集群，然后consumers来进行消费，</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/94E20F013CAA4F3694867F196F09F9D7.jpg" alt="image"></p><p>服务端(brokers)和客户端(producer、consumer)之间通信通过TCP协议来完成。Kafka提供了一个Java客户端，但是也可以使用其他语言编写的客户端。</p><h3 id="1-1-1-Topic和Log"><a href="#1-1-1-Topic和Log" class="headerlink" title="1.1.1 Topic和Log"></a>1.1.1 Topic和Log</h3><p>让我们首先深入理解Kafka提出一个高层次的抽象概念-Topic。<br>可以理解Topic是一个类别的名称，所有的message发送到Topic下面。对于每一个Topic，kafka集群按照如下方式维护一个分区(Partition,可以就理解为一个队列Queue)日志文件:</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7E80C11FB6AE43B1A579D9A283331D43.jpg" alt="image"></p><p>partition是一个有序的message序列，这些message按顺序添加到一个叫做commit log的文件中。每个partition中的消息都有一个唯一的编号，称之为offset，用来唯一标示某个分区中的message。</p><blockquote><p>提示：每个 partition ，都对应一个commit-log。一个 partition 中的message的offset都是唯一的，但是不同的partition中的message的offset可能是相同的。</p></blockquote><p><strong>kafka集群</strong>，在配置的时间范围内，维护所有的由producer生成的消息，而不管这些消息有没有被消费。例如日志保留( log retention )时间被设置为2天。kafka会维护最近2天生产的所有消息，而2天前的消息会被丢弃。==kafka 的性能与保留的数据量的大小没有关系==，因此保存大量的数据(日志信息)不会有什么影响。</p><p><strong>关于 consumer</strong> ，每个consumer是基于自己在commit log 中的消费进度(offset)来进行工作的。在kafka中，offset由consumer来维护：一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息，或者跳过某些消息。</p><p>这意味 kafka 中的 consumer 对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer来说，都是没有影响的，因此==每个consumer维护各自的offset==。</p><p><strong>对log进行分区（partitioned）目的是什么？</strong></p><ul><li>首先，当log文件大小超过系统文件系统的限制时，可以自动拆分。每个partition对应的log都受到所在机器的文件系统大小的限制，但是一个Topic中是可以有很多分区的，因此可以处理任意数量的数据。</li><li>另一个方面，是为了提高并行度。</li></ul><h3 id="1-1-3-Distribution"><a href="#1-1-3-Distribution" class="headerlink" title="1.1.3 Distribution"></a>1.1.3 Distribution</h3><p>log的partitions分布在kafka集群中不同的broker上，每个broker可以请求备份其他broker上partition上的数据。kafka集群支持配置一个partition备份的数量。</p><p>针对每个partition，都有一个broker起到“leader”的作用，0个多个其他的broker作为“follwers”的作用。leader处理所有的针对这个partition的读写请求，而==followers被动复制leader的结果==。如果这个leader失效了，其中的一个follower将会自动的变成新的leader。==每个broker都是自己所管理的partition的leader，同时又是其他broker所管理partitions的followers，kafka通过这种方式来达到负载均衡。==</p><h3 id="1-1-3-Producers"><a href="#1-1-3-Producers" class="headerlink" title="1.1.3 Producers"></a>1.1.3 Producers</h3><p>生产者将消息发送到topic中去，同时负责选择将message发送到topic的哪一个partition中。通过round-robin（轮询）做简单的负载均衡。也可以根据消息中的某一个关键字来进行区分，比如指定定key 通过 hash 取模。通常第二种方式使用的更多。</p><h3 id="1-1-4-Consumers-和-Consumer-Group"><a href="#1-1-4-Consumers-和-Consumer-Group" class="headerlink" title="1.1.4 Consumers 和 Consumer Group"></a>1.1.4 Consumers 和 Consumer Group</h3><p>传统的消息传递模式有2种：队列( queuing )和（ publish-subscribe）。<br>在queuing模式中，多个consumer从服务器中读取数据，消息只会到达一个consumer。在 publish-subscribe 模型中，消息会被广播给所有的consumer。==Kafka基于这2种模式提供了一种consumer的抽象概念==：==consumer group==。</p><p>每个consumer都要标记自己属于哪一个 consumer group。发布到 topic 中的 message 中 message 会被传递到 consumer group 中的一个 consumer 实例。consumer实例可以运行在不同的进程上，也可以在不同的物理机器上。<br>如果所有的consumer都位于同一个consumer group 下，这就类似于传统的queue模式，并在众多的consumer instance之间进行负载均衡。<br>如果所有的consumer都有着自己唯一的consumer group，这就类似于传统的publish-subscribe模型。</p><p>更一般的情况是，通常一个topic会有几个consumer group，每个consumer group都是一个逻辑上的订阅者（ logical subscriber ）。每个consumer group由多个consumer instance 组成，从而达到可扩展和容灾的功能。这并没有什么特殊的地方，仅仅是将publish-subscribe模型中的运行在单个进程上的consumers中的consumer替换成一个consumer group。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/79D77C03B804413AB5D481ACDBBA0FC6.jpg" alt="image"></p><blockquote><p>说明：由2个broker组成的kafka集群，总共有4个 Parition (P0-P3)。这个集群由2个Consumer Group， A有2个 consumer instances ，而B有四个.consumer instances的个数不能大于对应topic 的 Parition 个数。</p></blockquote><h2 id="1-2-消费顺序"><a href="#1-2-消费顺序" class="headerlink" title="1.2  消费顺序"></a>1.2  消费顺序</h2><p>Kafka 比传统的消息系统有着更强的顺序保证。</p><p><strong>在传统的情况下</strong>：服务器按照顺序保留消息到队列，如果有多个consumer来消费队列中的消息，服务器 会接受消息的顺序向外提供消息。但是，尽管服务器是按照顺序提供消息，但是消息传递到每一个consumer是异步的，这可能会导致先消费的 consumer获取到消息时间可能比后消费的consumer获取到消息的时间长，导致不能保证顺序性。这表明，当进行并行的消费的时候，消息在多个 consumer之间可能会失去顺序性。消息系统通常会采取一种“ exclusive consumer”的概念，来确保同一时间内只有一个consumer能够从队列中进行消费，但是这实际上意味着在消息处理的过程中是不支持并行的。</p><p><strong>Kafka</strong>：在这方面做的更好。通过Topic中并行度的概念，即partition，Kafka可以同时提供顺序性保证和多个consumer同时消费时的负载均衡。实现的原理是通过将一个topic中的partition分配给一个consumer group中的不同consumer instance。<br>通过这种方式，我们可以保证一个partition在同一个时刻只有一个consumer instance在消息，从而保证顺序。虽然一个topic中有多个partition，但是一个consumer group中同时也有多个consumer instance，通过合理的分配依然能够保证负载均衡。需要注意的是，一个consumer group中的consumer instance的数量不能比一个Topic中的partition的数量多。</p><p>Kafka只在 partition 的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。</p><p>通常来说，这已经可以满足大部分应用的需求。但是，如果的确有在总体上保证消费的顺序的需求的话，那么我们可以通过将 topic 的 partition 数量设置为1，将 consumer group 中的 consumer instance 数量也设置为1.</p><h2 id="1-3-Guarantees（担保）"><a href="#1-3-Guarantees（担保）" class="headerlink" title="1.3 Guarantees（担保）"></a>1.3 Guarantees（担保）</h2><p>从较高的层面上来说的话，Kafka提供了以下的保证：</p><p><strong>发送顺序保证:</strong> 发送到一个Topic中的message会按照发送的顺序添加到commit log 中。意思是，如果消息 M1，M2 由同一个producer发送，M1 比 M2 发送的早的话，那么在 commit log 中，M1的 offset一定比commit M2的 offset 小。</p><p><strong>消息容灾保证:</strong> 一个consumer在commit log中可以按照发送顺序来消费message<br>如果一个 topic 的备份因子( replication factor )设置为N，那么Kafka可以容忍N-1个服务器的失败，而存储在commit log中的消息不会丢失。</p><h1 id="2-Kafka设计原理分析"><a href="#2-Kafka设计原理分析" class="headerlink" title="2. Kafka设计原理分析"></a>2. Kafka设计原理分析</h1><h2 id="2-1-kafka-拓扑结构"><a href="#2-1-kafka-拓扑结构" class="headerlink" title="2.1 kafka 拓扑结构"></a>2.1 kafka 拓扑结构</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/04CD2B96DA934EC8A301480B308A9DE7.jpg" alt="image"></p><h2 id="2-2-kafka-zoopeeper-节点结构"><a href="#2-2-kafka-zoopeeper-节点结构" class="headerlink" title="2.2 kafka zoopeeper 节点结构"></a>2.2 kafka zoopeeper 节点结构</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5C5F8A937B9245F7956014A6010F9E0E.jpg" alt="image"></p><ul><li>topics 节点为永久节点类型（防止数据丢失）。</li><li>ids 为临时节点（节点挂掉，就需要删除id）</li></ul><h2 id="2-3-producer-发布消息"><a href="#2-3-producer-发布消息" class="headerlink" title="2.3 producer 发布消息"></a>2.3 producer 发布消息</h2><h3 id="2-3-1-写入方式"><a href="#2-3-1-写入方式" class="headerlink" title="2.3.1 写入方式"></a>2.3.1 写入方式</h3><p>producer 采用 push 模式将消息发布到 broker，每条消息都被 append 到 patition 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。</p><h3 id="2-3-2-消息路由"><a href="#2-3-2-消息路由" class="headerlink" title="2.3.2 消息路由"></a>2.3.2 消息路由</h3><p>producer 发送消息到 broker 时，会根据分区算法选择将其存储到哪一个 partition。<br>其路由机制为：</p><ol><li>指定了 patition，则直接使用；</li><li>未指定 patition 但指定 key，通过对 key 的 value 进行hash 选出一个 patition</li><li>patition 和 key 都未指定，使用轮询选出一个 patition。<br>3、写入流程</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5575DC56967641BC9AF89F9C8078E6B9.jpg" alt="image"></p><blockquote><ol><li>producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader</li><li>producer 将消息发送给该 leader</li><li>leader 将消息写入本地 log</li><li>followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK</li><li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 HW（high watermark，最后 commit 的 offset） 并向 producer 发送 ACK</li></ol></blockquote><h2 id="2-4-kafka分区leader选举原理"><a href="#2-4-kafka分区leader选举原理" class="headerlink" title="2.4 kafka分区leader选举原理"></a>2.4 kafka分区leader选举原理</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/10991B022F3F4E829DEFB78EA4228095.jpg" alt="image"></p><p>选举原理：是根据 zookeeper 的锁机制来实现，同一时间创建临时节点写入参选信息，只有一个flower 能写入成功，写入成功的即为  leader。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Kafka是一种高吞吐量的分布式发布订阅消息系统，使用Scala编写。&lt;br&gt;对于熟悉JMS（Java Message Service）规范的同学来说，消息系统已经不是什么新概念了(例如ActiveMQ，RabbitMQ等)。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
      <category term="MQ" scheme="http://www.yusuzi.cn/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>JVM- 虚拟机调优工具</title>
    <link href="http://www.yusuzi.cn/2020/07/10/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.yusuzi.cn/2020/07/10/JVM-虚拟机调优工具/</id>
    <published>2020-07-10T12:46:00.000Z</published>
    <updated>2020-08-21T04:56:55.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JVM-调优监控命令行工具介绍"><a href="#1-JVM-调优监控命令行工具介绍" class="headerlink" title="1. JVM 调优监控命令行工具介绍"></a>1. JVM 调优监控命令行工具介绍</h1><a id="more"></a><h2 id="1-1-jps"><a href="#1-1-jps" class="headerlink" title="1.1 jps"></a>1.1 jps</h2><p>查看运行进程 以及进程 id。</p><h2 id="1-2-Jinfo"><a href="#1-2-Jinfo" class="headerlink" title="1.2 Jinfo"></a>1.2 Jinfo</h2><p>查看正在运行的Java应用程序的扩展参数</p><ol><li>查看jvm的参数</li></ol><pre><code>jinfo -flags 30880</code></pre><ol start="2"><li><p>查看java系统参数</p><pre><code>jinfo -sysprops 30880</code></pre><h2 id="1-3-jstat"><a href="#1-3-jstat" class="headerlink" title="1.3 jstat"></a>1.3 jstat</h2><p>jstat 命令可以查看堆内存各部分的使用量，以及加载类的数量。命令的格式如下：<br>jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]<br>注意：使用的jdk版本是jdk8.</p></li><li><p>类加载统计</p><pre><code>jstat -class 5989</code></pre></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B3B456FC88EE4870A8C30E2E785ECED4.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>Loaded</td><td>加载class的数量</td></tr><tr><td>Bytes</td><td>所占用空间大小</td></tr><tr><td>Unloaded</td><td>未加载数量</td></tr><tr><td>Bytes</td><td>未加载占用空间</td></tr><tr><td>Time</td><td>时间</td></tr></tbody></table><ol start="2"><li>垃圾回收统计</li></ol><pre><code>jstat -gc 5989</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/84830F699417470C859862202F3AA646.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>S0C</td><td>第一个幸存区的大小</td></tr><tr><td>S1C</td><td>第二个幸存区的大小</td></tr><tr><td>S0U</td><td>第一个幸存区的使用大小</td></tr><tr><td>S1U</td><td>第二个幸存区的使用大小</td></tr><tr><td>EC</td><td>伊甸园区的大小</td></tr><tr><td>EU</td><td>伊甸园区的使用大小</td></tr><tr><td>OC</td><td>老年代大小</td></tr><tr><td>OU</td><td>老年代使用大小</td></tr><tr><td>MC</td><td>方法区大小(元空间)</td></tr><tr><td>MU</td><td>方法区使用大小</td></tr><tr><td>CCSC</td><td>压缩类空间大小</td></tr><tr><td>CCSU</td><td>压缩类空间使用大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间</td></tr></tbody></table><ol start="3"><li>堆内存统计</li></ol><pre><code>jstat -gccapacity 5989</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E033D8E689C4436D81692D953BD25632.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>NGCMN</td><td>新生代最小容量</td></tr><tr><td>NGCMX</td><td>新生代最大容量</td></tr><tr><td>NGC</td><td>当前新生代容量</td></tr><tr><td>S0C</td><td>第一个幸存区大小</td></tr><tr><td>S1C</td><td>第二个幸存区的大小</td></tr><tr><td>EC</td><td>伊甸园区的大小</td></tr><tr><td>OGCMN</td><td>老年代最小容量</td></tr><tr><td>OGCMX</td><td>老年代最大容量</td></tr><tr><td>OGC</td><td>当前老年代大小</td></tr><tr><td>OC</td><td>当前老年代大小</td></tr><tr><td>MCMN</td><td>最小元数据容量</td></tr><tr><td>MCMX</td><td>最大元数据容量</td></tr><tr><td>MC</td><td>当前元数据空间大小</td></tr><tr><td>CCSMN</td><td>最小压缩类空间大小</td></tr><tr><td>CCSMX</td><td>最大压缩类空间大小</td></tr><tr><td>CCSC</td><td>当前压缩类空间大小</td></tr><tr><td>YGC</td><td>年轻代gc次数</td></tr><tr><td>FGC</td><td>老年代GC次数</td></tr></tbody></table><ol start="4"><li>新生代垃圾回收统计</li></ol><pre><code>jstat -gcnew 13988</code></pre><ol start="5"><li>新生代内存统计</li></ol><pre><code>jstat -gcnewcapacity 13988</code></pre><ol start="6"><li>老年代垃圾回收统计</li></ol><pre><code>jstat -gcold 13988</code></pre><ol start="7"><li>老年代内存统计<pre><code>jstat -gcoldcapacity 13988</code></pre></li><li>元数据空间统计<pre><code>jstat -gcmetacapacity 13988</code></pre></li></ol><h2 id="1-4-jmap"><a href="#1-4-jmap" class="headerlink" title="1.4 jmap"></a>1.4 jmap</h2><p>此命令可以用来查看内存信息,查询内存溢出（OOM）可以通过这个命令。</p><ol><li>实例个数以及占用内存大小</li></ol><pre><code>jmap -histo 8899 &gt;./log.txt</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/7B15E576C60E4DCA9B09712C6D9930E6.jpg" alt="image"></p><table><thead><tr><th>标题</th><th>含义</th></tr></thead><tbody><tr><td>num</td><td>序号</td></tr><tr><td>instances</td><td>实例数量</td></tr><tr><td>bytes</td><td>占用空间大小</td></tr><tr><td>class name</td><td>类名称</td></tr></tbody></table><ol start="2"><li>堆信息</li></ol><pre><code>jmap -heap 8899</code></pre><ol start="3"><li>堆内存dump</li></ol><pre><code>jmap -dump:format=b,file = log.hprof 8899</code></pre><p>也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)</p><pre><code>-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=./ （路径）</code></pre><p>可以用 <code>jvisualvm</code> 命令工具导入该 dump文件分析</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0843F9809FB540259A749275DFCEF883.jpg" alt="image"></p><h2 id="1-5-Jstack"><a href="#1-5-Jstack" class="headerlink" title="1.5 Jstack"></a>1.5 Jstack</h2><p>查看堆栈信息,<strong>栈溢出或死锁可以通过这个工具</strong>。</p><pre><code>jstack 88999</code></pre><p>用 jstack 查找死锁，见如下示例，也可以用<code>jvisualvm</code> 查看死锁</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Object lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread1 begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread1 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread2 begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread2 end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0EB4FF290AC94746BAF3745D7CA1948F.jpg" alt="image"></p><h1 id="2-可视化工具-jvisualvm"><a href="#2-可视化工具-jvisualvm" class="headerlink" title="2. 可视化工具 jvisualvm"></a>2. 可视化工具 jvisualvm</h1><pre><code>jvisualvm</code></pre><h2 id="2-1-启动jvisualvm的远程链接"><a href="#2-1-启动jvisualvm的远程链接" class="headerlink" title="2.1 启动jvisualvm的远程链接"></a>2.1 启动jvisualvm的远程链接</h2><p>启动普通的jar程序JMX端口配置：</p><pre><code>java -Dcom.sun.management.jmxremote.port=12345 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -jar foo.jar</code></pre><p>tomcat的JMX配置</p><pre><code>JAVA_OPTS=-Dcom.sun.management.jmxremote.port=8999-Dcom.sun.management.jmxremote.ssl=false-Dcom.sun.management.jmxremote.authenticate=false</code></pre><p>jvisualvm 远程连接服务需要在远程服务器上配置host(连接ip 主机名)，并且要关闭防火墙。</p><h1 id="3-jstack找出占用cpu最高的堆栈信息"><a href="#3-jstack找出占用cpu最高的堆栈信息" class="headerlink" title="3. jstack找出占用cpu最高的堆栈信息"></a>3. jstack找出占用cpu最高的堆栈信息</h1><ol><li><p>使用命令<code>top -p &lt;pid&gt;</code> ，显示你的java进程的内存情况，pid是你的java进程号，比如4977</p></li><li><p>按H，获取每个线程的内存情况 </p></li><li><p>找到内存和cpu占用最高的线程tid，比如4977 </p></li><li><p>转为十六进制得到 0x1371 ,此为线程id的十六进制表示</p></li><li><p>执行 <code>jstack 4977|grep -A 10 1371</code>，得到线程堆栈信息中1371这个线程所在行的后面10行 </p></li><li><p>查看对应的堆栈信息找出可能存在问题的代码</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JVM-调优监控命令行工具介绍&quot;&gt;&lt;a href=&quot;#1-JVM-调优监控命令行工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1. JVM 调优监控命令行工具介绍&quot;&gt;&lt;/a&gt;1. JVM 调优监控命令行工具介绍&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="虚拟机" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://www.yusuzi.cn/tags/JVM/"/>
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM- 内存回收机制</title>
    <link href="http://www.yusuzi.cn/2020/07/08/JVM-%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.yusuzi.cn/2020/07/08/JVM-内存回收机制/</id>
    <published>2020-07-08T08:44:57.000Z</published>
    <updated>2020-08-21T04:57:07.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/84A35B9748EC46758F35BA070CBA4564.jpg" alt="image"></p><h1 id="2-JVM内存分配与回收"><a href="#2-JVM内存分配与回收" class="headerlink" title="2. JVM内存分配与回收"></a>2. JVM内存分配与回收</h1><h2 id="2-1-Minor-Gc-和-Full-GC-有什么不同呢？"><a href="#2-1-Minor-Gc-和-Full-GC-有什么不同呢？" class="headerlink" title="2.1 Minor Gc 和 Full GC 有什么不同呢？"></a>2.1 Minor Gc 和 Full GC 有什么不同呢？</h2><p>垃圾回收方式有两种 MinorGC 和 Full GC</p><p><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。通常 Minor GC 也叫做 Young GC.</p><p><strong>老年代GC（Major GC/Full GC</strong>）:指发生在老年代的 GC，出现了Major GC经常会伴随至少一次的 Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。老年代 GC 也可称为 Old GC.</p><h2 id="2-2-对象优先在Eden区分配"><a href="#2-2-对象优先在Eden区分配" class="headerlink" title="2.2 对象优先在Eden区分配"></a>2.2 对象优先在Eden区分配</h2><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次<strong>Minor GC</strong></p><h3 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h3><pre><code>public static void main(String[] args) throws InterruptedException {        byte[] allocation1, allocation2;        allocation1 = new byte[20231 * 1024];        //allocation2 = new byte[10000*1024];        try {            System.in.read();        } catch (IOException e) {            e.printStackTrace();        }    }</code></pre><pre><code>Heap PSYoungGen      total 38400K, used 26468K [0x0000000795580000, 0x0000000798000000, 0x00000007c0000000)  eden space 33280K, 79% used [0x0000000795580000,0x0000000796f59348,0x0000000797600000)  from space 5120K, 0% used [0x0000000797b00000,0x0000000797b00000,0x0000000798000000)  to   space 5120K, 0% used [0x0000000797600000,0x0000000797600000,0x0000000797b00000) ParOldGen       total 87552K, used 0K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)  object space 87552K, 0% used [0x0000000740000000,0x0000000740000000,0x0000000745580000) Metaspace       used 3600K, capacity 4536K, committed 4864K, reserved 1056768K  class space    used 401K, capacity 428K, committed 512K, reserved 1048576K</code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A58B033A8C194AF7BC9AC2684D048B35.jpg" alt="image"></p><p>从上图我们可以看出eden区内存已经被分配79%（即使程序什么也不做，新生代也会使用至少2000多k内存）。<br>假如我们再为allocation2分配内存会出现什么情况呢？  </p><pre><code>Heap PSYoungGen      total 38400K, used 3190K [0x0000000795580000, 0x000000079a080000, 0x00000007c0000000)  eden space 33280K, 8% used [0x0000000795580000,0x0000000795819a30,0x0000000797600000)  from space 5120K, 10% used [0x0000000797600000,0x0000000797684010,0x0000000797b00000)  to   space 5120K, 0% used [0x0000000799b80000,0x0000000799b80000,0x000000079a080000) ParOldGen       total 87552K, used 30239K [0x0000000740000000, 0x0000000745580000, 0x0000000795580000)  object space 87552K, 34% used [0x0000000740000000,0x0000000741d87c20,0x0000000745580000) Metaspace       used 3600K, capacity 4536K, committed 4864K, reserved 1056768K  class space    used 401K, capacity 428K, committed 512K, reserved 1048576K</code></pre><p>简单解释一下为什么会出现这种情况： 因为给 allocation2 分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survior 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现Full GC。执行 Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。</p><p>发生 Minor GC的次数 也可以通过下面的统计信息看到，<code>YGC = 1</code>。<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D005CBE2829A445E89EE71A29C44F692.jpg" alt="image"></p><h2 id="2-3-对象进入老年的方式"><a href="#2-3-对象进入老年的方式" class="headerlink" title="2.3 对象进入老年的方式"></a>2.3 对象进入老年的方式</h2><h3 id="2-3-1-大对象直接进入老年代"><a href="#2-3-1-大对象直接进入老年代" class="headerlink" title="2.3.1 大对象直接进入老年代"></a>2.3.1 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<br>为什么要这样呢？<br>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="2-3-2-长期存活的对象将进入老年代"><a href="#2-3-2-长期存活的对象将进入老年代" class="headerlink" title="2.3.2 长期存活的对象将进入老年代"></a>2.3.2 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。<br>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold </code>来设置。</p><h2 id="2-4-如何判断对象可以被回收"><a href="#2-4-如何判断对象可以被回收" class="headerlink" title="2.4 如何判断对象可以被回收"></a>2.4 如何判断对象可以被回收</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><h3 id="2-4-1-引用计数法"><a href="#2-4-1-引用计数法" class="headerlink" title="2.4.1 引用计数法"></a>2.4.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。<br>这个方法实现简单，效率高，==但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，== 如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</p><pre><code>public class ReferenceCountingGc {    Object instance = null;    public static void main(String[] args) {        ReferenceCountingGc objA = new ReferenceCountingGc();        ReferenceCountingGc objB = new ReferenceCountingGc();        objA.instance = objB;        objB.instance = objA;        objA = null;        objB = null;    }}</code></pre><h3 id="2-4-2-可达性分析算法"><a href="#2-4-2-可达性分析算法" class="headerlink" title="2.4.2 可达性分析算法"></a>2.4.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><strong>GC Roots根节点</strong>：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等等</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/A5C7B9534B934431A6328BBAEE20FE9F.jpg" alt="image"></p><h3 id="2-4-3-finalize-方法最终判定对象是否存活"><a href="#2-4-3-finalize-方法最终判定对象是否存活" class="headerlink" title="2.4.3 finalize()方法最终判定对象是否存活"></a>2.4.3 finalize()方法最终判定对象是否存活</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/FCBB514303EA44C79F7FD4315F15F2EC.jpg" alt="image"><br>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，还可以再抢救以下，至少要经历再次标记过程。标记的前提是对象在进行可达性分析后发现没有与 GCRoots 相连接的引用链。</p><p>两次标记 。</p><ol><li><p>第一次标记并进行一次筛选。<br>筛选的条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。</p></li><li><p>第二次标记<br>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</p></li></ol><p>finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己(只要重新与引用链上的任何的一个对象建立关联即可)，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。</p><p>如果对象这时候还没逃脱，那基本上它就真的被回收了。</p><p> 测试代码：</p><pre><code>public class OOMTest {    // JVM设置    // -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\jvm.dump    public static void main(String[] args) {        List list = new ArrayList();        int i = 0;        int j = 0;        while (true) {            list.add(new User(i++, UUID.randomUUID().toString()));            new User(j--, UUID.randomUUID().toString());        }    }}</code></pre><h3 id="2-4-4-如何判断一个常量是废弃常量"><a href="#2-4-4-如何判断一个常量是废弃常量" class="headerlink" title="2.4.4 如何判断一个常量是废弃常量"></a>2.4.4 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？<br>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><h3 id="2-4-5-如何判断一个类是无用的类"><a href="#2-4-5-如何判断一个类是无用的类" class="headerlink" title="2.4.5 如何判断一个类是无用的类"></a>2.4.5 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？<br>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 “无用的类” ：</p><ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h1 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h1><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CF04E79D16864FCDAB9BCA4AED74A82E.jpg" alt="image"></p><h2 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h2><p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：</p><ol><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D20509B98FA94400B0119A7F96237875.jpg" alt="image"> </p><h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/63CB574DAD564B5483B146B5D49DDF14.jpg" alt="image"></p><h2 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h2><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F3E25E0FA9F84E2DA27673E094DF04E5.jpg" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/146612F58E97421CA4EB3ACC2A630B77.jpg" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5C04D60F7EA64FBB9A7CD1EDAA232368.jpg" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/E82EA683993C42109AB7CBBDAC405717.jpg" alt="image"></p><h2 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h2><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h1 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4. 垃圾收集器"></a>4. 垃圾收集器</h1><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/81F9203653EF45968896617D2F39B6FB.jpg" alt="image"></p><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p><p>先对 并行和并发概念进行了解：</p><ul><li>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。适合科学计算、后台处理等弱交互场景。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。适合Web应用。</li></ul><p>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。</p><h2 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a>4.1 Serial收集器</h2><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</p><p>++新生代采用复制算法，老年代采用标记-整理算法。++</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/C6E4EECA4B7544B4B00A334485A89AEA.jpg" alt="image"></p><p>虚拟机的设计者们当然知道 <code>Stop The World</code> 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。<br>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p><h2 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a>4.2 ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。<br>==新生代采用复制算法，老年代采用标记-整理算法。==</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/EF654130AB66417EAFEFC1C1F8C20338.jpg" alt="image"></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><h2 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a>4.3 Parallel Scavenge收集器</h2><p>Parallel Scavenge 收集器类似于 ParNew 收集器，是 Server 模式（内存大于 2G，2 个 cpu）下的默认收集器，那么它有什么特别之处呢？</p><p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。<br>==新生代采用复制算法，老年代采用标记-整理算法。==</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/CB2FC5646BCD4E00973AD3CF38DF1D2F.jpg" alt="image"></p><h2 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a>4.4 Serial Old收集器</h2><p>Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h2 id="4-5-Parallel-Old收集器"><a href="#4-5-Parallel-Old收集器" class="headerlink" title="4.5 Parallel Old收集器"></a>4.5 Parallel Old收集器</h2><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h2 id="4-6-CMS收集器-XX-UseConcMarkSweepGC-主要是old区使用"><a href="#4-6-CMS收集器-XX-UseConcMarkSweepGC-主要是old区使用" class="headerlink" title="4.6 CMS收集器(-XX:+UseConcMarkSweepGC(主要是old区使用))"></a>4.6 CMS收集器(-XX:+UseConcMarkSweepGC(主要是old区使用))</h2><p>CMS（Concurrent MarkSweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。</p><p>整个过程分为四个步骤：</p><ul><li>初始标记：暂停所有的其他线程(STW)，并记录下直接与root相连的对象，速度很快 ；</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除：开启用户线程，同时GC线程开始对未标记的区域做清扫。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8036227F2EE742D6AB5D0510FB5DD71D.jpg" alt="image"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。</p><p>但是它有下面三个明显的缺点：</p><ol><li>对CPU资源敏感（会和服务抢资源）；</li><li>无法处理浮动垃圾(在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li><li></li></ol><p>CMS的相关参数</p><pre><code>-XX:+UseConcMarkSweepGC 启用cms-XX:ConcGCThreads:并发的GC线程数（并非STW时间，而是和服务一起执行的线程数）-XX:+UseCMSCompactAtFullCollection:FullGC之后做压缩（减少碎片）-XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次（因压缩非常的消耗时间，所以不能每次FullGC都做）-XX:CMSInitiatingOccupancyFraction:触发FulGC条件（默认是92）-XX:+UseCMSInitiatingOccupancyOnly:是否动态调节-XX:+CMSScavengeBeforeRemark:FullGC之前先做YGC（一般这个参数是打开的）-XX:+CMSClassUnloadingEnabled:启用回收Perm区（jdk1.7及以前）</code></pre><h2 id="4-7-G1收集器-XX-UseG1GC"><a href="#4-7-G1收集器-XX-UseG1GC" class="headerlink" title="4.7 G1收集器(-XX:+UseG1GC)"></a>4.7 G1收集器(-XX:+UseG1GC)</h2><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/4421E80B1A4F4438AA637E46B2197F51.jpg" alt="image"></p><p>G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p><p>分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。</p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备以下特点：<br>并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p><ul><li>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li>空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内完成垃圾收集。</li></ul><h3 id="G1收集器的运作大致分为以下几个步骤："><a href="#G1收集器的运作大致分为以下几个步骤：" class="headerlink" title="G1收集器的运作大致分为以下几个步骤："></a>G1收集器的运作大致分为以下几个步骤：</h3><ol><li><p>初始标记（initial mark，STW）：在此阶段，G1 GC对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</p></li><li><p>并发标记（Concurrent Marking）：G1 GC在整个堆中查找可访问的（存活的）对象。</p></li><li><p>最终标记（Remark，STW）：该阶段是 STW 回收，帮助完成标记周期。</p></li><li><p>筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 </p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/319BBC12D56C4BE7929004D4648023D3.jpg" alt="image"></p><p><strong>G1收集器在后台维护了一个优先列表</strong>，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率。</p><h1 id="5-如何选择垃圾收集器"><a href="#5-如何选择垃圾收集器" class="headerlink" title="5. 如何选择垃圾收集器"></a>5. 如何选择垃圾收集器</h1><ol><li>优先调整堆的大小让服务器自己来选择</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li><li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li></ol><p>下图有连线的可以搭配使用，官方推荐使用G1，因为性能高</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/18D6A441DD6E4B6E8EAB4CD6085053E4.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-内存结构&quot;&gt;&lt;a href=&quot;#JVM-内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM 内存结构&quot;&gt;&lt;/a&gt;JVM 内存结构&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="虚拟机" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://www.yusuzi.cn/tags/JVM/"/>
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM-Java 虚拟机入门</title>
    <link href="http://www.yusuzi.cn/2020/07/01/JVM-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%A5%E9%97%A8/"/>
    <id>http://www.yusuzi.cn/2020/07/01/JVM-Java-虚拟机入门/</id>
    <published>2020-06-30T18:43:39.000Z</published>
    <updated>2020-08-21T04:56:47.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JVM-整体架构"><a href="#1-JVM-整体架构" class="headerlink" title="1. JVM 整体架构"></a>1. JVM 整体架构</h1><a id="more"></a><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>**JVM(虚拟机)**：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。常用的虚拟机有VMWare，Virtual Box，Java Virtual Machine</p><p><strong>Java虚拟机阵营</strong>：Sun HotSpot VM、BEA JRockit VM、IBM J9 VM、Azul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B6C4C346061744E49EFACF2AFD644161.jpg" alt="image"></p><h2 id="1-2-JVM-构成"><a href="#1-2-JVM-构成" class="headerlink" title="1.2 JVM 构成"></a>1.2 JVM 构成</h2><p>由三个主要的子系统</p><ol><li>类加载器子系统</li><li>运行时数据区（内存结构）</li><li>执行引擎</li></ol><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8276252A099C4767B0824412B5AC790E.jpg" alt="image"></p><h2 id="1-3-Java-编译器"><a href="#1-3-Java-编译器" class="headerlink" title="1.3 Java 编译器"></a>1.3 Java 编译器</h2><p>Java  Compiler 运行时编译源码(.java)成字节码(.class)，由jre（Java Run Environment）运行。jre由java虚拟机（jvm）实现。Jvm 分析字节码，后解释并执行。</p><p>编译流程如下：<br><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/ACA7583FB3E9488D96C6D3E9B3D0C96B.jpg" alt="image"></p><h1 id="2-JVM类加载器"><a href="#2-JVM类加载器" class="headerlink" title="2. JVM类加载器"></a>2. JVM类加载器</h1><h2 id="2-1-类加载过程"><a href="#2-1-类加载过程" class="headerlink" title="2.1 类加载过程"></a>2.1 类加载过程</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B3DF1EEF61FD424C8D38E4737D702F62.jpg" alt="image"><br>类加载过程：类加载器将class文件加载到虚拟机的内存的过程。</p><p>步骤如下：</p><ol><li>加载：在硬盘上查找并通过IO读入字节码文件</li><li>连接：执行校验、准备、解析（可选）步骤</li><li>校验：校验字节码文件的正确性</li><li>准备：给类的静态变量分配内存，并赋予默认值</li><li>解析：类装载器装入类所引用的其他所有类</li><li>初始化：对类的静态变量初始化为指定的值，执行静态代码块</li></ol><h2 id="2-2-加载器种类"><a href="#2-2-加载器种类" class="headerlink" title="2.2 加载器种类"></a>2.2 加载器种类</h2><ul><li>启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等</li><li>扩展类加载器：负责加载JRE扩展目录ext中JAR类包</li><li>系统类加载器：负责加载ClassPath路径下的类包</li><li>用户自定义加载器：负责加载用户自定义路径下的类包</li></ul><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/99121BE919D44D7FA55CF8B574A4221C.jpg" alt="image"><br>示例代码可以输出加载器名称：</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/92E7D1EEA0B5442288B29BB6D0AD315E.jpg" alt="image"></p><h2 id="2-3-类加载机制"><a href="#2-3-类加载机制" class="headerlink" title="2.3 类加载机制"></a>2.3 类加载机制</h2><p>类加载过程种，有两种机制来保证加载的安全与避免重复加载：</p><ol><li><strong>全盘负责委托机制</strong>：当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入。</li><li><strong>双亲委派机制</strong>：指先委托父类加载器寻找目标类，而不是自己先找，在父类找不到的情况下，才不得已在自己的路径中查找并载入目标类。</li></ol><p>上面两条机制可以简单总结就是：一人得道鸡犬升天 和 败家子模型。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/F39CDE3D07DE4FCB9AB2A2EF3DAE5600.jpg" alt="image"></p><p><strong>双亲委派模式优势：</strong></p><p>沙箱安全机制：自己写的String.class类不会被加载，这样便可以防止核心API库被随意篡改<br>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再 加载一次。</p><h2 id="2-4-JVM加载jar包是否会将包里的所有类全部加载进内存？"><a href="#2-4-JVM加载jar包是否会将包里的所有类全部加载进内存？" class="headerlink" title="2.4 JVM加载jar包是否会将包里的所有类全部加载进内存？"></a>2.4 JVM加载jar包是否会将包里的所有类全部加载进内存？</h2><p>先说答案： JVM 对 class 文件是按需加载(运行期间动态加载)，非一次性加载。</p><p>下面通过一个例子来测试，注意：(启动需要加上参数：-verbose:class)</p><pre><code>public class TestDynamicLoad {    static {        System.out.println(&quot;*************static code************&quot;);    }    public static void main(String[] args){        new A();        System.out.println(&quot;*************load test************&quot;);        new B();    }}class A{    public A(){        System.out.println(&quot;*************initial A************&quot;);    }}class B{    public B(){        System.out.println(&quot;*************initial B************&quot;);    }}[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_92.jdk/Contents/Home/jre/lib/rt.jar]*************static code************[Loaded com.study.jvm.A from file:/U/jvmtest/out/production/jvmtest/]*************initial A*************************load test************[Loaded com.study.jvm.B from file:/Us/jvmtest/out/production/jvmtest/]*************initial B************</code></pre><p>从上面输入日志可以发现，A 和 B 都是在加载之后开始输出构造函数内的日志。</p><h2 id="2-5-jvm-如何知道我们的类在何方？"><a href="#2-5-jvm-如何知道我们的类在何方？" class="headerlink" title="2.5 jvm 如何知道我们的类在何方？"></a>2.5 jvm 如何知道我们的类在何方？</h2><p>我们的 class 信息存放在不同的地方，如不同文件夹里面的jar，项目bin目录，target目录等，jvm 怎么知道都需要加载哪些路径呢？</p><p>通过查看 sun.misc.Launcher.AppClassLoader 源码可以发现，是通过读取<code> java.class.path</code> 配置，通过这个指定去特定配置目录去加载。</p><p>通过 <code>jps</code> 和 <code>jcmd</code> 两个命令来验证</p><pre class="line-numbers language-bash"><code class="language-bash">jpsjcmd pid <span class="token function">help</span>jcmd pid VM.system_properties<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/6BACF4F6B07B4C518CE7820CDBAD22A0.jpg" alt="image"></p><h1 id="3-JVM-内存结构"><a href="#3-JVM-内存结构" class="headerlink" title="3. JVM 内存结构"></a>3. JVM 内存结构</h1><h2 id="3-1-内存结构结构图"><a href="#3-1-内存结构结构图" class="headerlink" title="3.1 内存结构结构图"></a>3.1 内存结构结构图</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/50969016BB3446248562F165B43F902F.jpg" alt="image"></p><ol><li><p>本地方法栈(线程私有)：登记native方法，在Execution Engine执行时加载本地方法库</p></li><li><p>程序计数器（线程私有）：就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</p></li><li><p>Java栈（线程私有）：Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）==不存在垃圾回收问题==，只要线程一结束该栈就释放，生命周期和线程一致。</p></li><li><p>方法区(线程共享)：类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p></li><li><p>堆(线程共享)：虚拟机启动时创建，用于存放对象实例，几乎所有的对象（包含常量池）都在堆上分配内存，当对象无法再该空间申请到内存时将抛出OutOfMemoryError异常。同时也是垃圾收集器管理的主要区域。可通过 -Xmx –Xms 参数来分别指定最大堆和最小堆</p></li></ol><p>JVM 对该区域规范了两种异常：</p><ol><li>针对与栈：线程请求的栈深度大于虚拟机栈所允许的深度，将抛出 StackOverFlowError 异常</li><li>针对堆：若虚拟机栈可动态扩展，当无法申请到足够内存空间时将抛出OutOfMemoryError，通过jvm参数–Xss指定栈空间，空间大小决定函数调用的深度<h2 id="3-2-Java-栈"><a href="#3-2-Java-栈" class="headerlink" title="3.2 Java 栈"></a>3.2 Java 栈</h2></li></ol><p>每个线程都有自己私有的栈，栈内部是由n个栈帧（函数/方法）组成。<br>栈帧（函数/方法）内部又包含：局部变量表、操作数栈、动态链接、返回地址。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5B247C51135C4A00B2B9A3F77D109081.jpg" alt="image"></p><h2 id="3-3-栈-堆-方法区的交互关系"><a href="#3-3-栈-堆-方法区的交互关系" class="headerlink" title="3.3 栈+堆+方法区的交互关系"></a>3.3 栈+堆+方法区的交互关系</h2><p>HotSpot 是使用==指针==的方式来访问对象<br>Java堆中会存放访问==类元数据==的地址<br>reference存储的就直接是对象的地址</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/D2B31A961A53482A9FB921AA929285EA.jpg" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/B803B954C8254EF18A95473BF80D015A.jpg" alt="image"></p><h2 id="3-4-堆"><a href="#3-4-堆" class="headerlink" title="3.4 堆"></a>3.4 堆</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/84A35B9748EC46758F35BA070CBA4564.jpg" alt="image"></p><h3 id="3-4-1-Young-Generation-新生区"><a href="#3-4-1-Young-Generation-新生区" class="headerlink" title="3.4.1 Young Generation 新生区"></a>3.4.1 Young Generation 新生区</h3><p>类诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。<br>新生区分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。</p><p>幸存区有两个： 0(From)区（Survivor 0 space）和1(To)区（Survivor 1 space）。</p><p>当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。<br>若幸存 0区也满了，再对该区进行垃圾回收，然后移动到1区。那如果1区也满了呢？则 移动到 老年代。</p><h3 id="3-4-2-old-Generation-老年区"><a href="#3-4-2-old-Generation-老年区" class="headerlink" title="3.4.2 old Generation 老年区"></a>3.4.2 old Generation 老年区</h3><p>新生区经过多次GC仍然存活的对象移动到老年区。<br>若老年区也满了，那么这个时候将产生MajorGC（FullGC），进行老年区的内存清理。若老年区执行了Full GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常“OutOfMemoryError”</p><h3 id="3-4-3-MetaDataSpace-元数据区"><a href="#3-4-3-MetaDataSpace-元数据区" class="headerlink" title="3.4.3 MetaDataSpace 元数据区"></a>3.4.3 MetaDataSpace 元数据区</h3><p>元数据区取代了永久代(jdk1.8以前)，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存，永久代在虚拟机中，永久代逻辑结构上属于堆，但是物理上不属于堆，堆大小=新生代+老年代。元数据区也有可能发生OutOfMemory异常。</p><table><thead><tr><th>JAVA 版本</th><th>是否有永久代</th></tr></thead><tbody><tr><td>Jdk1.6及之前</td><td>有永久代, 常量池在方法区</td></tr><tr><td>Jdk1.7</td><td>有永久代，但已经逐步“去永久代”，常量池在堆</td></tr><tr><td>Jdk1.8及之后</td><td>无永久代，常量池在元空间.</td></tr></tbody></table><p>元数据区的动态扩展，默认 –XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。</p><p><strong>为什么jdk1.8用元数据区取代了永久代？</strong></p><p>官方解释：移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</p><h1 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a>JVM执行引擎</h1><p>执行引擎：读取运行时数据区的Java字节码并逐个执行</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/BE6F2D2F39AF4F80A6D80BA8807A8A67.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JVM-整体架构&quot;&gt;&lt;a href=&quot;#1-JVM-整体架构&quot; class=&quot;headerlink&quot; title=&quot;1. JVM 整体架构&quot;&gt;&lt;/a&gt;1. JVM 整体架构&lt;/h1&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="虚拟机" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://www.yusuzi.cn/tags/JVM/"/>
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 动态页面缓存方式实现</title>
    <link href="http://www.yusuzi.cn/2020/06/25/Nginx-%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.yusuzi.cn/2020/06/25/Nginx-动态页面缓存方式实现/</id>
    <published>2020-06-24T18:40:22.000Z</published>
    <updated>2020-08-21T05:05:00.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="具体实现步骤："><a href="#具体实现步骤：" class="headerlink" title="具体实现步骤："></a>具体实现步骤：</h2><p>依托于 OpenResty 框架实现</p><a id="more"></a><h3 id="一、Openresty安装"><a href="#一、Openresty安装" class="headerlink" title="一、Openresty安装"></a>一、Openresty安装</h3><pre class="line-numbers language-sh"><code class="language-sh">mkdir ‐p /usr/servers cd  /usr/servers/yum install‐y readline‐devel pcre‐devel openssl‐devel gccwget http://openresty.org/download/ngx_openresty‐1.7.7.2.tar.gz tar ‐xzvf ngx_openresty‐1.7.7.2.tar.gzcd  /usr/servers/ngx_openresty‐1.7.7.2/cd  bundle/LuaJIT‐2.1‐20150120/ make clean && make&& make install ln ‐sf luajit‐2.1.0‐alpha /usr/local/bin/luajitcd  /usr/servers/ngx_openresty‐1.7.7.2/bundle wget  https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz tar‐xvf 2.3.tar.gzcd  bundle wget  https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz tar  ‐xvf  v0.3.0.tar.gzcd  /usr/servers/ngx_openresty‐1.7.7.2 ./configure‐‐prefix=/usr/servers‐‐with‐http_realip_module‐‐with‐pcre‐‐with‐luajit‐‐add‐module=./bundle/ngx_cache_purge‐2.3/ ‐‐add‐module=./bundle/nginx_upstream_check_module‐0.3.0/ ‐j2 24 make&&makeinstallcd /usr/servers/ll/usr/servers/luajit/usr/servers/lualib/usr/servers/nginx/usr/servers/nginx/sbin/nginx ‐V##启动nginx: /usr/servers/nginx/sbin/nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、-Nginx-lua-开发-hello-world"><a href="#二、-Nginx-lua-开发-hello-world" class="headerlink" title="二、 Nginx + lua 开发 hello world"></a>二、 Nginx + lua 开发 hello world</h3><pre class="line-numbers language-sh"><code class="language-sh">cd /usr/servers/nginx/confvim  lua.conf server{    listen 80;    server_name _;    location /lua { default_type 'text/html';    content_by_lua 'ngx.say("helloworld")';    } }vim  nginx.conf##在http部分引入lua包lua_package_path"/usr/servers/lualib/?.lua;;";lua_package_cpath"/usr/servers/lualib/?.so;;"; include lua.conf;../sbin/nginx‐sreload #访问:http://192.168.0.60/lua<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、Nginx-lua开发的流量分发逻辑，可以根据商品id-进行-hash-然后取模分发。"><a href="#三、Nginx-lua开发的流量分发逻辑，可以根据商品id-进行-hash-然后取模分发。" class="headerlink" title="三、Nginx+lua开发的流量分发逻辑，可以根据商品id 进行 hash 然后取模分发。"></a>三、Nginx+lua开发的流量分发逻辑，可以根据商品id 进行 hash 然后取模分发。</h3><pre class="line-numbers language-sh"><code class="language-sh">#流量分发的nginx，会发送http请求到后端的应用层nginx上去，所以要先引入lua http lib包 cd /usr/servers/lualib/resty wget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http_headers.lua wget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http.luacd  /usr/servers/nginx/conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>lua-distribution.lua</p><pre class="line-numbers language-SH"><code class="language-SH">vim lua‐distribution.lua# lua-distribution.lualocal uri_args=ngx.req.get_uri_args()local productId=uri_args["productId"] local host={"192.168.0.61","192.168.0.62"}local hash=ngx.crc32_long(productId) hash = (hash%2)+1backend="http://"..host[hash]local method = uri_args["method"] local requestBody="/"..method.."?productId="..productIdlocal http=require("resty.http") localhttpc=http.new()local resp,err=httpc:request_uri(backend,{      method = "GET", path = requestBody, keepalive=false})if not resp then    ngx.say("request error :", err)    returnend ngx.say(resp.body) httpc:close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开 lua.conf</p><pre class="line-numbers language-sh"><code class="language-sh">vim lua.conf 在server部分加入 location/product{    default_type 'text/html';    content_by_lua_file /usr/servers/nginx/conf/lua‐distribution.lua; }../sbin/nginx‐sreload#访问:http://192.168.0.60/lua?productId=XX 会根据productId将请求分发到不同的应用层nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、Nginx-lua开发应用层页面缓存与模板动态渲染逻辑"><a href="#四、Nginx-lua开发应用层页面缓存与模板动态渲染逻辑" class="headerlink" title="四、Nginx+lua开发应用层页面缓存与模板动态渲染逻辑"></a>四、Nginx+lua开发应用层页面缓存与模板动态渲染逻辑</h3><pre class="line-numbers language-sh"><code class="language-sh">##应用层需要访问服务http接口，所以也需要引入lua http lib包cd /usr/servers/lualib/resty wget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http_headers.luawget https://raw.githubusercontent.com/pintsized/lua‐resty‐http/master/lib/resty/http.lua##应用层还需要用到模板动态渲染技术，所以还需要引入lua的template包cd  /usr/servers/lualib/resty wget https://raw.githubusercontent.com/bungle/lua‐resty‐template/master/lib/resty/template.lua mkdir/usr/servers/lualib/resty/htmlcd /usr/servers/lualib/resty/html wget https://raw.githubusercontent.com/bungle/lua‐resty‐template/master/lib/resty/template/html.luacd /usr/servers/templates vim product.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>增加html静态模板 </li></ul><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http‐equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content‐Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html; charset<span class="token punctuation">=</span>utf‐8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>商品id: {* productId *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品名称: {* productName *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品原价: {* productPrice *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品现价: {* productNowPrice *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品库存: {* productStock *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> 商品描述: {* productHTML *}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sh"><code class="language-sh">cd  /usr/servers/nginx/confvim lua.conf## 在server部分加入set $template_location"/templates";set $template_root"/usr/servers/templates";## 增加ngxin缓存配置vim lua.conf## 在最前面加入lua_shared_dictmy_cache  128m;## 增加商品详情页渲染的lua脚本vim lua.conf## 在server部分增加location/product{  default_type 'text/html';  content_by_lua_file /usr/servers/nginx/conf/product.lua;}## 最后，编写商品详情页渲染lua脚本vim product.lualocal uri_args=ngx.req.get_uri_args()local productId=uri_args["productId"]local cache_ngx=ngx.shared.my_cachelocal productCacheKey="product_info_"..productIdlocal productCache=cache_ngx:get(productCacheKey)if productCache == "" or productCache == nil then   local http=require("resty.http")   local httpc=http.new()   local resp,err=httpc:request_uri("http://192.168.0.175:8080",{   method="GET", path="/shop‐web/product/cache/"..productId,keepalive=false   })   productCache = resp.body   local expireTime = math.random(600,1200)   cache_ngx:set(productCacheKey,productCache,expireTime)endngx.log(ngx.ERR,"json‐‐‐‐‐‐‐‐2",productCache)local cjson=require("cjson")local productCacheJSON=cjson.decode(productCache)local context={    productId=productCacheJSON.id,    productName=productCacheJSON.name,    productPrice=productCacheJSON.price,    productNowPrice=productCacheJSON.nowPrice,    productStock=productCacheJSON.stock,    productHTML=productCacheJSON.productHTML}local template=require("resty.template")template.render("product.html",context)../sbin/nginx‐sreload ## 访问:http://192.168.0.60/product?productId=XX&method=product## 会根据productId将请求分发到不同的应用层nginx获取相应的商品详情页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;具体实现步骤：&quot;&gt;&lt;a href=&quot;#具体实现步骤：&quot; class=&quot;headerlink&quot; title=&quot;具体实现步骤：&quot;&gt;&lt;/a&gt;具体实现步骤：&lt;/h2&gt;&lt;p&gt;依托于 OpenResty 框架实现&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.yusuzi.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://www.yusuzi.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>网络协议梳理</title>
    <link href="http://www.yusuzi.cn/2020/06/06/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/"/>
    <id>http://www.yusuzi.cn/2020/06/06/网络协议梳理/</id>
    <published>2020-06-06T09:35:01.000Z</published>
    <updated>2020-07-24T14:12:49.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、OSI-网络七层模型"><a href="#一、OSI-网络七层模型" class="headerlink" title="一、OSI 网络七层模型"></a>一、OSI 网络七层模型</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/0A162883B11F412DBAF35E4FDB31D054.jpg" alt="image"></p><p><strong>应用层</strong>：<br>决定向用户提供应用服务时通信的活动，此处的活动包括比如待传送数据的处理（应用内部生成特定格式的数据，后对数据进行标准协议的格式的编码）。</p><p><strong>表示层</strong><br>负责数据格式转换、数据加密与解密、压缩解压缩等</p><p><strong>会话层</strong><br>负责建立、管理和终止进程之间的会话和数据交换。</p><p><strong>传输层：</strong><br>对上层应用层，提供处于网络连接种的两台计算机之间的数据传输（TCP、UDP）。</p><p><strong>网络层：</strong><br>用来处理网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。<br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><p><strong>链路层</strong>（又名数据链路层，网络接口层）：<br>用来管理／操作连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡、光纤等物理可见部分。</p><a id="more"></a><h2 id="二、-OSI-七层模型对应的协议"><a href="#二、-OSI-七层模型对应的协议" class="headerlink" title="二、 OSI 七层模型对应的协议"></a>二、 OSI 七层模型对应的协议</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/2B803AB503B144418B043A283CC22B3A.jpg" alt="image"> </p><h2 id="TCP-UDP-网络请求过程"><a href="#TCP-UDP-网络请求过程" class="headerlink" title="TCP/UDP 网络请求过程"></a>TCP/UDP 网络请求过程</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/451F2587D1F4416198ED3CEACAB3052B.jpg" alt="image"> </p><p>发送端：在层与层之间传输数据时，每一层都会被打上当前层所属的头部信息。</p><p>接收端：在层与层之间传输数据时，每一层都会取消当前层所属的头部信息。</p><h3 id="TCP-头部信息"><a href="#TCP-头部信息" class="headerlink" title="TCP 头部信息"></a>TCP 头部信息</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/8890607AEBBB48C286631BC8087B2941.jpg" alt="image"> </p><h3 id="TCP-可靠性保证"><a href="#TCP-可靠性保证" class="headerlink" title="TCP 可靠性保证"></a>TCP 可靠性保证</h3><ul><li><p>三次握手和四次挥手机制</p><blockquote><p>在建立连接的时候，通过3 次握手机制。在结束连接的时候通过4次挥手。这样保证连接的可靠性。</p></blockquote></li><li><p>校验和</p><blockquote><p>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p></blockquote></li><li><p>确认应答+序列号</p><blockquote><p>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p></blockquote></li><li><p>超时重传</p><blockquote><p>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p><p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p><p>超时以500ms（0.5秒）为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2<em>500ms的时间后，再次重传。等待4</em>500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。</p></blockquote></li><li><p>流量控制</p><blockquote><p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。接收方有即时窗口（滑动窗口），随ACK报文发送。</p></blockquote></li><li><p>拥塞控制</p><blockquote><p>而且 TCP 引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。发送过程中当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的及时窗口。</p></blockquote></li></ul><h3 id="TCP-握手和挥手机制"><a href="#TCP-握手和挥手机制" class="headerlink" title="TCP 握手和挥手机制"></a>TCP 握手和挥手机制</h3><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/3467CABB79EC412A955A981B18752DE3.jpg" alt="image"> </p><h2 id="三、-浏览器中输入一个域名地址-发生了什么？"><a href="#三、-浏览器中输入一个域名地址-发生了什么？" class="headerlink" title="三、 浏览器中输入一个域名地址 发生了什么？"></a>三、 浏览器中输入一个域名地址 发生了什么？</h2><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/9FF77B5A7DF74377A11A7049C637C1C6.jpg" alt="image"> </p><pre class="line-numbers language-shell"><code class="language-shell">$ nslookup www.baidu.comServer:        192.168.1.1Address:    192.168.1.1#53Non-authoritative answer:www.baidu.com    canonical name = www.a.shifen.com.Name:    www.a.shifen.comAddress: 36.152.44.95Name:    www.a.shifen.comAddress: 36.152.44.96<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、-WebSocket-和-HTTP-Socket-区别"><a href="#四、-WebSocket-和-HTTP-Socket-区别" class="headerlink" title="四、 WebSocket 和 HTTP, Socket 区别"></a>四、 WebSocket 和 HTTP, Socket 区别</h2><p>WebSocket 同 HTTP 一样也是应用层的协议,但是它是一种双向通信协议,是建立在TCP之上的。</p><h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol><li><p>浏览器、服务器通过三次握手建立TCP连接 。这是通信的基础,若失败后续都不执行。</p></li><li><p>TCP连接成功后,浏览器通过HTTP协议向服务器传送WebSocket 支持的版本号等信息。(开始前的HTTP握手）</p></li><li><p>服务器收到客户端的握手请求后,同样采用HTTP协议回馈数据。</p></li><li><p>当收到了连接成功的消息后,通过TCP通道进行传输通信。</p></li></ol><h3 id="WebSocket与HTTP的相同点和不同点"><a href="#WebSocket与HTTP的相同点和不同点" class="headerlink" title="WebSocket与HTTP的相同点和不同点"></a>WebSocket与HTTP的相同点和不同点</h3><ul><li>相同点</li></ul><ol><li>都是一样基于TCP的,都是可靠性传输协议。</li><li>都是应用层协议</li></ol><ul><li>不同点</li></ul><ol><li>WebSocket是双向通信协议,模拟Socket协议,可以双向发送或接受信息,HTTP是单向的。</li><li>WebSocket是需要握手进行建立连接的 ，WebSocket在建立握手时,数据是通过HTTP传输的。但是建立之后,在真正传输时候是不需要HTTP协议的。</li></ol><h3 id="WebSocket-与-Socket的关系"><a href="#WebSocket-与-Socket的关系" class="headerlink" title="WebSocket 与 Socket的关系"></a>WebSocket 与 Socket的关系</h3><p>Socket 其实并不是一个协议,而是为了方便使用 TCP 或 UDP 而抽象出来的层,是位于应用层和传输控制层之间的—组接口。</p><p><img src="https://cdn.jsdelivr.net/gh/brokge/drawio/img/5F3C32A779AF4085B1EFA79585EFA7F0.jpg" alt="image"> </p><blockquote><p>Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层,它是一组接口。在设计模式中, Socket其实就是一个门面模式,它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面,对用户来说,一组简单的接口就是全部,让 Socket去组织数据,以符合指定的协议。</p></blockquote><p>当两台主机通信时,必须通过 Socket 连接, Socket则利用 TCP/IP 协议建立 TCP 连接。TCP连接则更依靠于底层的 IP 协议, IP 协议的连接则依赖于链路层等更低层次。</p><p>WebSocket 则是一个典型的应用层协议。</p><ul><li>区别</li></ul><p>Socket是传输控制层协议, WebSocket是应用层协议。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>图解 http</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、OSI-网络七层模型&quot;&gt;&lt;a href=&quot;#一、OSI-网络七层模型&quot; class=&quot;headerlink&quot; title=&quot;一、OSI 网络七层模型&quot;&gt;&lt;/a&gt;一、OSI 网络七层模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/brokge/drawio/img/0A162883B11F412DBAF35E4FDB31D054.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;：&lt;br&gt;决定向用户提供应用服务时通信的活动，此处的活动包括比如待传送数据的处理（应用内部生成特定格式的数据，后对数据进行标准协议的格式的编码）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示层&lt;/strong&gt;&lt;br&gt;负责数据格式转换、数据加密与解密、压缩解压缩等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话层&lt;/strong&gt;&lt;br&gt;负责建立、管理和终止进程之间的会话和数据交换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传输层：&lt;/strong&gt;&lt;br&gt;对上层应用层，提供处于网络连接种的两台计算机之间的数据传输（TCP、UDP）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络层：&lt;/strong&gt;&lt;br&gt;用来处理网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。&lt;br&gt;与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路层&lt;/strong&gt;（又名数据链路层，网络接口层）：&lt;br&gt;用来管理／操作连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡、光纤等物理可见部分。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://www.yusuzi.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络编程" scheme="http://www.yusuzi.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
