<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>玉蘇子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brokge.github.io/"/>
  <updated>2020-06-06T09:37:10.172Z</updated>
  <id>https://brokge.github.io/</id>
  
  <author>
    <name>brokge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络协议梳理</title>
    <link href="https://brokge.github.io/2020/06/06/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/"/>
    <id>https://brokge.github.io/2020/06/06/网络协议梳理/</id>
    <published>2020-06-06T09:35:01.000Z</published>
    <updated>2020-06-06T09:37:10.172Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80osi-%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">一、OSI 网络七层模型</a></li><li><a href="#%E4%BA%8C-osi-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%8F%E8%AE%AE">二、 OSI 七层模型对应的协议</a></li><li><a href="#tcpudp-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B">TCP/UDP 网络请求过程</a><ul><li><a href="#tcp-%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF">TCP 头部信息</a></li><li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81">TCP 可靠性保证</a></li><li><a href="#tcp-%E6%8F%A1%E6%89%8B%E5%92%8C%E6%8C%A5%E6%89%8B%E6%9C%BA%E5%88%B6">TCP 握手和挥手机制</a></li></ul></li><li><a href="#%E4%B8%89-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%9C%B0%E5%9D%80-%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">三、 浏览器中输入一个域名地址 发生了什么？</a></li><li><a href="#%E5%9B%9B-websocket-%E5%92%8C-http-socket-%E5%8C%BA%E5%88%AB">四、 WebSocket 和 HTTP, Socket 区别</a><ul><li><a href="#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B">连接过程</a></li><li><a href="#websocket%E4%B8%8Ehttp%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9">WebSocket与HTTP的相同点和不同点</a></li><li><a href="#websocket-%E4%B8%8E-socket%E7%9A%84%E5%85%B3%E7%B3%BB">WebSocket 与 Socket的关系</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="一-osi-网络七层模型">一、OSI 网络七层模型</span></h2><p><img src="http://note.youdao.com/yws/res/10005/0A162883B11F412DBAF35E4FDB31D054" alt="image"></p><p><strong>应用层</strong>：<br>决定向用户提供应用服务时通信的活动，此处的活动包括比如待传送数据的处理（应用内部生成特定格式的数据，后对数据进行标准协议的格式的编码）。</p><p><strong>表示层</strong><br>负责数据格式转换、数据加密与解密、压缩解压缩等</p><p><strong>会话层</strong><br>负责建立、管理和终止进程之间的会话和数据交换。</p><p><strong>传输层：</strong><br>对上层应用层，提供处于网络连接种的两台计算机之间的数据传输（TCP、UDP）。</p><p><strong>网络层：</strong><br>用来处理网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。<br>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><p><strong>链路层</strong>（又名数据链路层，网络接口层）：<br>用来管理／操作连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡、光纤等物理可见部分。</p><h2><span id="二-osi-七层模型对应的协议">二、 OSI 七层模型对应的协议</span></h2><p><img src="http://note.youdao.com/yws/res/9979/2B803AB503B144418B043A283CC22B3A" alt="image"></p><h2><span id="tcpudp-网络请求过程">TCP/UDP 网络请求过程</span></h2><p><img src="http://note.youdao.com/yws/res/10019/451F2587D1F4416198ED3CEACAB3052B" alt="image"></p><p>发送端：在层与层之间传输数据时，每一层都会被打上当前层所属的头部信息。</p><p>接收端：在层与层之间传输数据时，每一层都会取消当前层所属的头部信息。</p><h3><span id="tcp-头部信息">TCP 头部信息</span></h3><p><img src="http://note.youdao.com/yws/res/10021/8890607AEBBB48C286631BC8087B2941" alt="image"></p><h3><span id="tcp-可靠性保证">TCP 可靠性保证</span></h3><ul><li>三次握手和四次挥手机制<blockquote><p>在建立连接的时候，通过3 次握手机制。在结束连接的时候通过4次挥手。这样保证连接的可靠性。</p></blockquote></li><li><p>校验和</p><blockquote><p>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p></blockquote></li><li><p>确认应答+序列号</p><blockquote><p>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p></blockquote></li><li><p>超时重传</p><blockquote><p>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。那么发送方发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p><p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p><p>超时以500ms（0.5秒）为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2<em>500ms的时间后，再次重传。等待4</em>500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。</p></blockquote></li><li><p>流量控制</p><blockquote><p>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。接收方有即时窗口（滑动窗口），随ACK报文发送。</p></blockquote></li><li><p>拥塞控制</p><blockquote><p>而且 TCP 引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。发送过程中当网络拥塞时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的及时窗口。</p></blockquote></li></ul><h3><span id="tcp-握手和挥手机制">TCP 握手和挥手机制</span></h3><p><img src="http://note.youdao.com/yws/res/10027/3467CABB79EC412A955A981B18752DE3" alt="image"></p><h2><span id="三-浏览器中输入一个域名地址-发生了什么">三、 浏览器中输入一个域名地址 发生了什么？</span></h2><p><img src="http://note.youdao.com/yws/res/10053/9FF77B5A7DF74377A11A7049C637C1C6" alt="image"></p><pre class="line-numbers language-shell"><code class="language-shell">$ nslookup www.baidu.comServer:        192.168.1.1Address:    192.168.1.1#53Non-authoritative answer:www.baidu.com    canonical name = www.a.shifen.com.Name:    www.a.shifen.comAddress: 36.152.44.95Name:    www.a.shifen.comAddress: 36.152.44.96<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="四-websocket-和-http-socket-区别">四、 WebSocket 和 HTTP, Socket 区别</span></h2><p>WebSocket 同 HTTP 一样也是应用层的协议,但是它是一种双向通信协议,是建立在TCP之上的。</p><h3><span id="连接过程">连接过程</span></h3><ol><li><p>浏览器、服务器通过三次握手建立TCP连接 。这是通信的基础,若失败后续都不执行。</p></li><li><p>TCP连接成功后,浏览器通过HTTP协议向服务器传送WebSocket 支持的版本号等信息。(开始前的HTTP握手）</p></li><li>服务器收到客户端的握手请求后,同样采用HTTP协议回馈数据。</li><li>当收到了连接成功的消息后,通过TCP通道进行传输通信。</li></ol><h3><span id="websocket与http的相同点和不同点">WebSocket与HTTP的相同点和不同点</span></h3><ul><li>相同点</li></ul><ol><li>都是一样基于TCP的,都是可靠性传输协议。</li><li>都是应用层协议</li></ol><ul><li>不同点</li></ul><ol><li>WebSocket是双向通信协议,模拟Socket协议,可以双向发送或接受信息,HTTP是单向的。</li><li>WebSocket是需要握手进行建立连接的 ，WebSocket在建立握手时,数据是通过HTTP传输的。但是建立之后,在真正传输时候是不需要HTTP协议的。</li></ol><h3><span id="websocket-与-socket的关系">WebSocket 与 Socket的关系</span></h3><p>Socket 其实并不是一个协议,而是为了方便使用 TCP 或 UDP 而抽象出来的层,是位于应用层和传输控制层之间的—组接口。</p><p><img src="http://note.youdao.com/yws/res/10065/5F3C32A779AF4085B1EFA79585EFA7F0" alt="image"></p><blockquote><p>Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层,它是一组接口。在设计模式中, Socket其实就是一个门面模式,它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面,对用户来说,一组简单的接口就是全部,让 Socket去组织数据,以符合指定的协议。</p></blockquote><p>当两台主机通信时,必须通过 Socket 连接, Socket则利用 TCP/IP 协议建立 TCP 连接。TCP连接则更依靠于底层的 IP 协议, IP 协议的连接则依赖于链路层等更低层次。</p><p>WebSocket 则是一个典型的应用层协议。</p><ul><li>区别</li></ul><p>Socket是传输控制层协议, WebSocket是应用层协议。</p><h2><span id="参考">参考</span></h2><p>图解 http</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="网络" scheme="https://brokge.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络编程" scheme="https://brokge.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程如何确定线程个数</title>
    <link href="https://brokge.github.io/2020/06/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E4%B8%AA%E6%95%B0/"/>
    <id>https://brokge.github.io/2020/06/05/多线程编程如何确定线程个数/</id>
    <published>2020-06-05T13:08:38.000Z</published>
    <updated>2020-06-06T09:39:14.707Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E4%B8%AA%E6%95%B0">多线程编程如何确定线程个数？</a><ul><li><a href="#%E4%B8%80cpu-%E5%AF%86%E9%9B%86%E5%9E%8B">一、CPU 密集型</a></li><li><a href="#%E4%BA%8C-io%E5%AF%86%E9%9B%86%E5%9E%8B">二、 I/O密集型</a></li><li><a href="#%E4%B8%89%E9%97%AE%E9%A2%98">三、问题</a></li><li><a href="#%E5%9B%9B%E5%A2%9E%E5%8A%A0-cpu-%E6%A0%B8%E6%95%B0%E4%B8%80%E5%AE%9A%E8%83%BD%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E5%90%97">四、增加 CPU 核数一定能解决问题吗</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="多线程编程如何确定线程个数">多线程编程如何确定线程个数？</span></h2><p>在具体的优化场景中，可以分为以下两种场景着手。</p><ul><li><p>CPU 密集型程序</p></li><li><p>I/O 密集型程序</p></li></ul><h3><span id="一-cpu-密集型">一、CPU 密集型</span></h3><ol><li>单核CPU处理 CPU 密集型程序，这种情况并不太适合使用多线程。</li><li>如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率</li></ol><p>线程数量 = CPU 核数（逻辑） 就可以了，但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1, 这是因为：计算(CPU)密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。</p><h3><span id="二-io密集型">二、 I/O密集型</span></h3><blockquote><p>与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分</p></blockquote><p>线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程。</p><p>最佳线程数 = CPU核心数 <em>  (1/CPU利用率) =  CPU核心数 </em> (1 + (I/O耗时/CPU耗时))</p><p>假如几乎全是 I/O耗时，所以纯理论你就可以说是 2N（N=CPU核数），当然也有说 2N + 1的。</p><h3><span id="三-问题">三、问题</span></h3><blockquote><p>假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为 20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s</p></blockquote><p>答案：<br>因为 一个线程处理一个 Transaction 时间是4秒，那1秒 处理 0.25 个 Transaction；</p><p>所以 ： 20 / 0.25 = 80（个）。</p><p>但是，这是因为没有考虑到CPU数目。一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销。</p><blockquote><p>计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？</p></blockquote><p>线程数 = 8 * (1 + 100/5) = 168 (个)</p><blockquote><p>那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？</p></blockquote><p>答案： 因为 1 s = 1000ms  完成一个完整的db 操作等于 100+5  =105 ms。 那一个线程一秒可以处理的任务数是  1000/105。168 个线程 就是 168 * 1000/105 = 1600（QPS）。</p><p>如果 db 的QPS 上限是 1000 ，则168*1000/1600 = 105 个。</p><h3><span id="四-增加-cpu-核数一定能解决问题吗">四、增加 CPU 核数一定能解决问题吗</span></h3><p>即便我算出了理论线程数，但实际CPU核数不够，会带来线程上下文切换的开销，所以下一步就需要增加 CPU 核数，那我们盲目的增加 CPU 核数就一定能解决问题吗？</p><p><img src="http://note.youdao.com/yws/res/9278/21A8D6F6DF074BAB8A79192C8190C38E" alt="image"></p><p><img src="http://note.youdao.com/yws/res/9282/DC07610E6E0E4003B7B1F29B8219F936" alt="image"></p><p>假如我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。</p><p>所谓串行率： 临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行率</p><p>因为临界区的大小往往就是瓶颈问题的所在，所以尽可能的最小化临界区范围，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="优化" scheme="https://brokge.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="多线程" scheme="https://brokge.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo详解</title>
    <link href="https://brokge.github.io/2020/06/02/Dubbo%E8%AF%A6%E8%A7%A3/"/>
    <id>https://brokge.github.io/2020/06/02/Dubbo详解/</id>
    <published>2020-06-02T08:28:45.000Z</published>
    <updated>2020-06-05T13:29:15.476Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80%E5%89%8D%E8%A8%80">一、前言</a><ul><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E7%9A%84-%E6%9C%89-3-%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><strong>分布式架构的 有 3 种解决方案</strong></a></li><li><a href="#%E5%9F%BA%E4%BA%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84">基于反向代理的集中式分布式架构</a><ul><li><a href="#%E5%B5%8C%E5%85%A5%E5%BA%94%E7%94%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E6%9E%B6%E6%9E%84">嵌入应用内部的去中心化架构</a></li><li><a href="#%E5%9F%BA%E4%BA%8E%E7%8B%AC%E7%AB%8B%E4%BB%A3%E7%90%86%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9E%B6%E6%9E%84service-mesh">基于独立代理进程的架构(Service Mesh)</a></li></ul></li><li><a href="#%E4%B8%89%E7%A7%8D%E6%9E%B6%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83">三种架构的比较</a></li></ul></li><li><a href="#%E4%BA%8C%E4%BB%80%E4%B9%88%E6%98%AF-dubbo">二、什么是 Dubbo</a><ul><li><a href="#dubbo-spi-%E6%9C%BA%E5%88%B6">Dubbo SPI 机制</a></li></ul></li><li><a href="#%E4%B8%89dubbo%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%AF%A6%E8%A7%A3">三、Dubbo注册中心详解</a><ul><li><a href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BD%9C%E7%94%A8">注册中心的作用</a></li><li><a href="#dubbo%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">Dubbo所支持的注册中心</a></li><li><a href="#redis-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><strong>Redis 注册中心</strong></a><ul><li><a href="#1-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%8E%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB">1. 如何存储服务的注册与订阅关系</a></li><li><a href="#2-%E6%98%AF%E5%BD%93%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E6%97%B6%E5%A6%82%E4%BD%95%E5%8D%B3%E6%97%B6%E6%9B%B4%E6%96%B0">2. 是当服务状态改变时如何即时更新？</a></li></ul></li><li><a href="#zookeeper-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><strong>Zookeeper 注册中心</strong></a><ul><li><a href="#%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B">源码查看</a></li></ul></li></ul></li><li><a href="#%E4%B8%89-dubbo-%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9D%97">三、 Dubbo 调用模块</a><ul><li><a href="#%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86">透明代理：</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><strong>负载均衡</strong></a></li><li><a href="#%E5%AE%B9%E9%94%99"><strong>容错</strong></a></li><li><a href="#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><strong>异步调用</strong></a></li><li><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><strong>过滤器</strong></a></li></ul></li><li><a href="#%E8%B0%83%E7%94%A8%E9%80%9A%E4%BF%A1--%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">调用通信  内部实现原理</a><ul><li><a href="#dubbo-%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%AE%9E%E7%8E%B0%E4%B8%8E%E9%85%8D%E7%BD%AE"><strong>Dubbo 长连接实现与配置</strong></a></li><li><a href="#dubbo-%E4%BC%A0%E8%BE%93%E5%8D%8F%E4%BD%9C%E7%BA%BF%E7%A8%8B"><strong>Dubbo 传输协作线程</strong></a></li></ul></li><li><a href="#%E5%9B%9Bdubbo-%E5%8D%8F%E8%AE%AE">四、Dubbo 协议</a><ul><li><a href="#rpc-%E5%8D%8F%E8%AE%AE%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><strong>RPC 协议名词解释</strong></a></li><li><a href="#dubbo-%E6%94%AF%E6%8C%81%E7%9A%84rpc%E5%8D%8F%E8%AE%AE">dubbo 支持的RPC协议</a></li><li><a href="#%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE"><strong>协议的使用与配置:</strong></a></li><li><a href="#dubbo-%E6%94%AF%E6%8C%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96">dubbo 支持的序列化：</a></li><li><a href="#hessian-%E5%BA%8F%E5%88%97%E5%8C%96">Hessian 序列化</a></li></ul></li><li><a href="#%E4%BA%94rpc%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E7%BC%96%E7%A0%81%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3">五、RPC协议报文编码与实现详解</a><ul><li><a href="#rpc-%E4%BC%A0%E8%BE%93%E5%AE%9E%E7%8E%B0"><strong>RPC 传输实现：</strong></a></li><li><a href="#%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><strong>拆包与粘包产生的原因：</strong></a></li><li><a href="#%E6%8B%86%E5%8C%85%E4%B8%8E%E7%B2%98%E5%8C%85%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><strong>拆包与粘包解决办法：</strong></a></li><li><a href="#dubbo-%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E7%BC%96%E7%A0%81">Dubbo 协议报文编码：</a></li></ul></li><li><a href="#%E5%85%AD%E6%9C%80%E5%90%8E">六、最后</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="一-前言">一、前言</span></h2><p><img src="http://note.youdao.com/yws/res/9311/64A03BA7F21B4BB29F4ABC5F11140870" alt="image"></p><h4><span id="分布式架构的-有-3-种解决方案"><strong>分布式架构的 有 3 种解决方案</strong></span></h4><ol><li>基于反向代理的中心化架构</li><li>嵌入应用内部的去中心化架构</li><li>基于独立代理进程的Service Mesh架构</li></ol><h4><span id="基于反向代理的集中式分布式架构">基于反向代理的集中式分布式架构</span></h4><p>这是最简单和传统做法，在服务消费者和生产者之间，代理作为独立一层集中部署，由独立团队(一般是运维或框架)负责治理和运维。常用的集中式代理有硬件负载均衡器(如F5)，或者软件负载均衡器(如Nginx)，这种软硬结合两层代理也是业内常见做法，兼顾配置的灵活性(Nginx比F5易于配置)。</p><p><img src="http://note.youdao.com/yws/res/9352/29E919D8DA684D4E99671F5A16013855" alt="image"></p><p><strong>Http+Nginx 方案总结</strong></p><p><strong>优点：</strong> 简单快速、几乎没有学习成本</p><p><strong>适用场景：</strong> 轻量级分布式系统、局部分布式架构。</p><p><strong>瓶颈：</strong> Nginx中心负载、Http传输、JSON序列化、开发效率、运维效率。</p><h3><span id="嵌入应用内部的去中心化架构">嵌入应用内部的去中心化架构</span></h3><p>这是很多互联网公司比较流行的一种做法，代理(包括服务发现和负载均衡逻辑)以客户库的形式嵌入在应用程序中。这种模式一般需要独立的服务注册中心组件配合，服务启动时自动注册到注册中心并定期报心跳，客户端代理则发现服务并做负载均衡。我们所熟悉的 duboo 和spring cloud Eureka +Ribbon/‘rɪbən/ 都是这种方式实现。</p><p><img src="http://note.youdao.com/yws/res/9359/91E7A4D0836A49B395A817DDC2CF2376" alt="image"><br>相比第一代架构它有以下特点几点：</p><ul><li>去中心化，客户端直连服务端</li><li>动态注册和发现服务</li><li>高效稳定的网络传输</li><li>高效可容错的序列化</li></ul><h3><span id="基于独立代理进程的架构service-mesh">基于独立代理进程的架构(Service Mesh)</span></h3><p>这种做法是上面两种模式的一个折中，代理既不是独立集中部署，也不嵌入在客户应用程序中，而是作为独立进程部署在每一个主机上，一个主机上的多个消费者应用可以共用这个代理，实现服务发现和负载均衡，如下图所示。这个模式一般也需要独立的服务注册中心组件配合，作用同第二代架构。</p><p><img src="http://note.youdao.com/yws/res/9364/E7DE6B068DC74C7D8AE0808F46AB24AF" alt="image"></p><h4><span id="三种架构的比较">三种架构的比较</span></h4><table><thead><tr><th style="text-align:left"><strong>模式</strong></th><th style="text-align:left"><strong>优点</strong></th><th style="text-align:left"><strong>缺点</strong></th><th style="text-align:left"><strong>适应场景</strong></th><th style="text-align:left"><strong>案例</strong></th></tr></thead><tbody><tr><td style="text-align:left">集中式负载架构</td><td style="text-align:left">简单  集中式治理  与语言无关</td><td style="text-align:left">配置维护成本高  多了一层IO  单点问题</td><td style="text-align:left">大部分公司都适用，对运维有要求</td><td style="text-align:left">亿贝、携程、早期互联网公司</td></tr><tr><td style="text-align:left">客户端嵌入式架构</td><td style="text-align:left">无单点  性能更好</td><td style="text-align:left">客户端复杂  语言栈要求</td><td style="text-align:left">中大规模公司、语言栈统一</td><td style="text-align:left">Dubbo    、  Twitter finagle、  Spring Cloud Ribbon</td></tr><tr><td style="text-align:left">独立进程代理架构</td><td style="text-align:left">无单点  性能更好  与语言无关</td><td style="text-align:left">运维部署复杂  开发联调复杂</td><td style="text-align:left">中大规模公司  对运维有要求</td><td style="text-align:left">Smart Stack  Service Mesh</td></tr></tbody></table><h2><span id="二-什么是-dubbo">二、什么是 Dubbo</span></h2><p>dubbo 阿里开源的一个 SOA（面向服务的架构） 服务治理框架，从目前来看把它称作是一个RPC远程调用框架更为贴切。单从RPC框架来说，功能较完善，支持多种传输和序列化方案。所以想必大家已经知道他的核心功能了：就是远程调用。</p><p><img src="http://note.youdao.com/yws/res/9319/81A705F26C0346EA871AB8936296BFE1" alt="image"></p><p><strong>流程说明：</strong></p><ol><li>Provider(提供者)绑定指定端口并启动服务</li><li>指供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储</li><li>Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心</li><li>注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。</li><li>Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。</li><li>Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer</li></ol><p><strong>这么设计的意义：</strong></p><ol><li>Consumer 与Provider 解偶，双方都可以横向增减节点数。</li><li>注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台</li><li>去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li></ol><p><strong>Dubbo 设计层级</strong></p><p><img src="http://note.youdao.com/yws/res/9322/60BD217B1ED345898A01578CF19291CB" alt="image"></p><ul><li>config <strong>配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li>proxy <strong>服务代理层</strong>：服务接口透明代理，生成动态代理 扩展接口为 ProxyFactory</li><li>registry <strong>注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li><li>cluster <strong>路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li><li>monitor <strong>监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li><li>protocol <strong>远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li><li>exchange <strong>信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li><li>transport <strong>网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li><li>serialize <strong>数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li></ul><p><img src="http://note.youdao.com/yws/res/9335/7DC769031DD64DDABC42BDFBC7384599" alt="image"></p><h3><span id="dubbo-spi-机制">Dubbo SPI 机制</span></h3><p>Java SPI 的具体约定为:当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类java.util.ServiceLoader</p><p><img src="http://note.youdao.com/yws/res/9338/0723FDE7587148BAB47925D8471D652D" alt="image"></p><p>META-INF/services/xxx.dubbo.server.UserService 中的值：</p><pre><code>xxx.dubbo.server.impl.UserServiceImpl2</code></pre><p>装载获取SPI实现类：</p><pre><code>public static void main(String[] args) {    Iterator&lt;UserService&gt; services = ServiceLoader.load(UserService.class).iterator();    UserService service = null;    while (services.hasNext()) {        service = services.next();    }    System.out.println(service.getUser(111));}</code></pre><p>Dubbo SPI 在JAVA自带的SPI基础上加入了扩展点的功能，即每个实现类都会对应至一个扩展点名称，其目的是 应用可基于此名称进行相应的装配。</p><p><img src="http://note.youdao.com/yws/res/9343/B158D3A511A54EE0819951B33A188F0D" alt="image"><br>dubbo spi  文件内容：</p><pre><code>luban=xxx.dubbo.server.LubanFilter</code></pre><p>装配自定义Filter</p><p><img src="http://note.youdao.com/yws/res/9345/17D1822AA2FB4427A92566F2E64917B7" alt="image"></p><p>想了解更详细信息：<br><a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">官方文档</a></p><h2><span id="三-dubbo注册中心详解">三、Dubbo注册中心详解</span></h2><h3><span id="注册中心的作用">注册中心的作用</span></h3><p>为了到达服务集群动态扩容的目的，注册中心存储了服务的地址信息与可用状态信息，并实时推送给订阅了相关服务的客户端。<br><img src="http://note.youdao.com/yws/res/9386/8638BBF57BF946769ABFCE0DAF896809" alt="image"></p><p><strong>一个完整的注册中心需要实现以下功能：</strong></p><ol><li>接收服务端的注册与客户端的引用，即将引用与消费建立关联，并支持多对多。</li><li>当服务非正常关闭时能即时清除其状态</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>注册中心本身的集群 。</li></ol><h3><span id="dubbo所支持的注册中心">Dubbo所支持的注册中心</span></h3><ol><li><strong>Multicast 注册中心</strong><ol><li>基于组网广播技术，只能用在局域网内，一般用于简单的测试服务</li></ol></li><li><strong>Zookeeper 注册中心(**</strong>推荐<strong>**)</strong><ol><li><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper</a> 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用</li></ol></li><li><strong>Redis 注册中心</strong><ol><li>基于Redis的注册中心</li></ol></li><li><strong>Simple 注册中心</strong><ol><li>基于本身的Dubbo服务实现（SimpleRegistryService），不支持集群可作为自定义注册中心的参考，但不适合直接用于生产环境。 </li></ol></li></ol><h3><span id="redis-注册中心"><strong>Redis 注册中心</strong></span></h3><p>关于Redis注册中心我们需要了解两点，</p><h4><span id="1-如何存储服务的注册与订阅关系">1. 如何存储服务的注册与订阅关系</span></h4><p>redis 注册中心配置</p><pre><code>&lt;dubbo:registry protocol=&quot;redis&quot; address=&quot;192.168.0.147:6379&quot;/&gt;</code></pre><p>当我们启动两个服务端后发现，Reids中增加了一个Hash 类型的记录，其key为/dubbo/xxx.dubbo.server.UserService/providers。Value中分别存储了两个服务提供者的URL和有效期。</p><p><img src="http://note.youdao.com/yws/res/9377/89233BE1BB03402C9224A6348FAA7007" alt="image"></p><p><strong>同样消费者也是类似其整体结构如下：</strong></p><pre><code>//服务提供者注册信息 /dubbbo/com.xxx.teach.service.DemoService/providers  dubbo://192.168.246.1:20880/XXX.DemoService=1542619052964   dubbo://192.168.246.2:20880/XXX.DemoService=1542619052964 //服务消费订阅信息/dubbbo/com.xxx.teach.service.DemoService/consumers  dubbo://192.168.246.1:20880/XXX.DemoService=1542619788641</code></pre><ul><li>主 Key 为服务名和类型</li><li>Map 中的 Key 为 URL 地址</li><li>Map 中的 Value 为过期时间，用于判断脏数据，脏数据由监控中心删除</li></ul><h4><span id="2-是当服务状态改变时如何即时更新">2. 是当服务状态改变时如何即时更新？</span></h4><p>第二个问题 <strong>当提供者突然 宕机状态能即里变更吗</strong>？<br>这里Dubbo采用的是<strong>定时心跳的机制</strong> 来维护服务URL的有效期，默认<strong>每30秒更新一次有效期</strong>。即URL对应的毫秒值。具体代码参见：com.alibaba.dubbo.registry.redis.RedisRegistry#expireExecutor</p><p><img src="http://note.youdao.com/yws/res/9390/F32248B7D113492EBC48590051A3CD04" alt="image"></p><p>com.alibaba.dubbo.registry.redis.RedisRegistry#deferExpired<br>com.alibaba.dubbo.registry.integration.RegistryDirectory<br>com.alibaba.dubbo.registry.support.ProviderConsumerRegTable</p><h3><span id="zookeeper-注册中心"><strong>Zookeeper 注册中心</strong></span></h3><p>关于Zookeeper 注册中心同样需要了解其存储结构和更新机制。<br>Zookeper是一个树型的目录服务，本身支持变更推送相比 redis 的实现 Publish/Subscribe 功能更稳定。</p><ol><li>Provider和Consumer向Zookeeper注册临时节点，当连接断开时删除相应的注册节点。</li><li>Consumer订阅 Providers节点的子节点，通过 watch 事件，当 Zookeeper 删除临时节点时，实时感知 Provider 的变化情况，实时同步自身的Invoker对象，保证 RPC的可用性。</li></ol><p>结构：</p><p><img src="http://note.youdao.com/yws/res/9425/D8B581F4BF944E94AF6382ECA1CB770F" alt="image"></p><h4><span id="源码查看">源码查看</span></h4><pre class="line-numbers language-java"><code class="language-java"> <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doRegister</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            zkClient<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token function">toUrlPath</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>DYNAMIC_KEY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RpcException</span><span class="token punctuation">(</span><span class="token string">"Failed to register "</span> <span class="token operator">+</span> url <span class="token operator">+</span> <span class="token string">" to zookeeper "</span> <span class="token operator">+</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", cause: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">create</span><span class="token punctuation">(</span>String path<span class="token punctuation">,</span> <span class="token keyword">boolean</span> ephemeral<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ephemeral<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkExists</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把前面的先创建好   dubbo/com.xx.xx/providers</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 创建持久节点</span>            <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ephemeral<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建一个临时节点,node 节点（保存具体地址）。</span>            <span class="token function">createEphemeral</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 创建持久节点</span>            <span class="token function">createPersistent</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>失败重连：</strong><br>com.alibaba.dubbo.registry.support.FailbackRegistry</p><p><strong>提供者突然断开：</strong><br>存储基于Zookeeper 临时节点机制实现，在客户端会话超时后（默认为40秒） Zookeeper 会自动删除所有临时节点。 </p><pre><code>// 创建临时节点com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient#createEphemeral</code></pre><p><strong>在 zookeeper 断开的40秒内 如果 有客户端加入 会调用 已失效的提供者连接吗？</strong></p><blockquote><p>答：不会，提供者宕机后 ，其与客户端的链接也随即断开，客户端在调用前会检测长连接是否可用状态的方法。</p><pre><code>// 检测连接是否有效 com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker#isAvailable</code></pre></blockquote><p>创建 configurators与 routers  会通过 <strong>持久节点</strong>来创建, 比如：“dubbo/com.xx.xx/providers”</p><pre><code>com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperClient#createPersistent</code></pre><p><strong>服务订阅机制实现：</strong></p><pre><code>// 注册目录com.alibaba.dubbo.registry.integration.RegistryDirectory</code></pre><p><img src="http://note.youdao.com/yws/res/9435/7903EF7E728C436EBABA5AB637CB1588" alt="image"></p><h2><span id="三-dubbo-调用模块">三、 Dubbo 调用模块</span></h2><p>dubbo调用模块核心功能是发起一个远程方法的调用并顺利拿到返回结果，其体系组成如下：</p><ol><li><strong>透明代理：</strong> 通过动态代理技术，屏蔽远程调用细节以提高编程友好性。</li><li><strong>负载均衡：</strong> 当有多个提供者是，如何选择哪个进行调用的负载算法。</li><li><strong>容错机制：</strong> 当服务调用失败时采取的策略</li><li><strong>调用方式：</strong> 支持同步调用、异步调用</li></ol><p><img src="http://note.youdao.com/yws/res/9440/C29CEB5BE9E4479EA5988A07FC429C28" alt="image"></p><h3><span id="透明代理">透明代理：</span></h3><p>针对代理 dubbo 提供 三种方式：</p><p><img src="http://note.youdao.com/yws/res/9448/BCE9E2B8BB9F4E1DBE9E0249FCE1D4C7" alt="image"></p><p>默认方式是：</p><pre><code>    public static final String DEFAULT_PROXY = &quot;javassist&quot;;</code></pre><p>调用链如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>config<span class="token punctuation">.</span>ReferenceConfig#createProxy<span class="token operator">--</span><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>javassist<span class="token punctuation">.</span>JavassistProxyFactory<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>bytecode<span class="token punctuation">.</span>Proxy#<span class="token function">getProxy</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">,</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>bytecode<span class="token punctuation">.</span>ClassGenerator#<span class="token function">newInstance</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>ClassLoader<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://note.youdao.com/yws/res/9461/2835D117E1FE424F84ED8907FC986A2B" alt="image"></p><p><img src="http://note.youdao.com/yws/res/9451/5B1BA7C374ED444DAFD557DF5055D4D9" alt="image"></p><p><img src="http://note.youdao.com/yws/res/9453/B8DCD49FB51847ED97BBA2C316A5BCDF" alt="image"></p><p><img src="http://note.youdao.com/yws/res/9463/E7EF7C875FBD48A4B2037B3A74D5BC62" alt="image"></p><h3><span id="负载均衡"><strong>负载均衡</strong></span></h3><p>Dubbo 目前官方支持以下负载均衡策略：</p><ol><li><strong>随机</strong>(random)：按权重设置随机概率。此为默认算法.</li><li><strong>轮循</strong>(roundrobin):按公约后的权重设置轮循比率。</li><li><strong>最少活跃调用数</strong>(leastactive):相同活跃数的随机，活跃数指调用前后计数差。</li><li><strong>一致性Hash</strong>(consistenthash ):相同的参数总是发到同一台机器</li></ol><p><img src="http://note.youdao.com/yws/res/9468/EDE99CF742414CB5921E56E2BD341282" alt="image"><br>设置方式支持如下四种方式设置，优先级由低至高</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 服务端级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 客户端级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 服务端方法级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>service</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 客户端方法级别--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roundrobin<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="容错"><strong>容错</strong></span></h3><p>Dubbo 官方目前支持以下容错策略：</p><ol><li><strong>失败自动切换：</strong> 调用失败后基于retries=“2” 属性重试其它服务器</li><li><strong>快速失败：</strong> 快速失败，只发起一次调用，失败立即报错。</li><li><strong>勿略失败：</strong> 失败后勿略，不抛出异常给客户端。</li><li><strong>失败重试：</strong> 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作</li><li><strong>并行调用:</strong> 只要一个成功即返回，并行调用指定数量机器，可通过 forks=”2” 来设置最大并行数。</li><li><strong>广播调用：</strong> 广播调用所有提供者，逐个调用，任意一台报错则报错</li></ol><p><img src="http://note.youdao.com/yws/res/9473/CD04A0766E944919A0D62EBFE9F964C6" alt="image"><br>设置方式支持如下两种方式设置，优先级由低至高</p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>Failover 失败自动切换 retries<span class="token operator">=</span><span class="token string">"1"</span> 切换次数Failfast 快速失败Failsafe 勿略失败Failback 失败重试，<span class="token number">5</span>秒后仅重试一次Forking 并行调用 forks<span class="token operator">=</span><span class="token string">"2"</span> 最大并行数Broadcast 广播调用<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dubbo<span class="token operator">:</span>service <span class="token keyword">interface</span><span class="token operator">=</span><span class="token string">"..."</span> cluster<span class="token operator">=</span><span class="token string">"broadcast"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>dubbo<span class="token operator">:</span>reference <span class="token keyword">interface</span><span class="token operator">=</span><span class="token string">"..."</span> cluster<span class="token operator">=</span><span class="token string">"broadcast"</span><span class="token operator">/</span> <span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：容错机制 在基于 API设置时无效 如  referenceConfig.setCluster(“failback”); 经测试不启作用 </p><h3><span id="异步调用"><strong>异步调用</strong></span></h3><p>异步调用是指发起远程调用之后获取结果的方式。</p><ol><li>同步等待结果返回（默认）</li><li>异步等待结果返回</li><li>不需要返回结果</li></ol><p><img src="http://note.youdao.com/yws/res/9475/F1C320C5A219405B8EFC66F1FE4CC78B" alt="image"></p><p>异步调用配置:</p><pre><code>&lt;dubbo:reference id=&quot;asyncDemoService&quot;    interface=&quot;com.xxx.teach.service.async.AsyncDemoService&quot;&gt;   &lt;!-- 异步调async：true 异步调用 false 同步调用--&gt;   &lt;dubbo:method name=&quot;sayHello1&quot; async=&quot;false&quot;/&gt;   &lt;dubbo:method name=&quot;sayHello2&quot; async=&quot;false&quot;/&gt;   &lt;dubbo:method name=&quot;notReturn&quot; return=&quot;false&quot;/&gt;&lt;/dubbo:reference&gt;</code></pre><p>注：在进行异步调用时 容错机制不能为  cluster=”forking” 或  cluster=”broadcast”</p><p><em>异步调用结果获取Demo</em></p><pre class="line-numbers language-java"><code class="language-java">demoService<span class="token punctuation">.</span><span class="token function">sayHello1</span><span class="token punctuation">(</span><span class="token string">"han"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future1 <span class="token operator">=</span> RpcContext<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>demoService<span class="token punctuation">.</span><span class="token function">sayHello2</span><span class="token punctuation">(</span><span class="token string">"han2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Future<span class="token operator">&lt;</span>Object<span class="token operator">></span> future2 <span class="token operator">=</span> RpcContext<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object r1 <span class="token operator">=</span> null<span class="token punctuation">,</span> r2 <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// wait 直到拿到结果 或超时</span>r1 <span class="token operator">=</span> future1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// wait 直到拿到结果 或超时</span>r2 <span class="token operator">=</span> future2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="过滤器"><strong>过滤器</strong></span></h3><p><strong> 类似于 WEB 中的Filter ，Dubbo本身提供了Filter 功能用于拦截远程方法的调用。其支持自定义过滤器与官方的过滤器使用：</strong></p><p>#TODO 演示添加日志访问过滤:</p><pre><code>&lt;dubbo:provider  filter=&quot;accesslog&quot; accesslog=&quot;logs/dubbo.log&quot;/&gt;</code></pre><p>以上配置 就是 为 服务提供者 添加 日志记录过滤器， 所有访问日志将会集中打印至 accesslog 当中。</p><h2><span id="调用通信-内部实现原理">调用通信  内部实现原理</span></h2><p><img src="http://note.youdao.com/yws/res/9490/17E56F436154424BA5E8AAC97BD84B13" alt="image"></p><p><strong>IO模型：</strong></p><ol><li>BIO 同步阻塞</li><li>NIO 同步非阻塞</li><li>AIO 异步非阻塞</li></ol><p><strong>连接模型：</strong></p><ol><li>长连接</li><li>短连接</li></ol><p><strong>线程分类：</strong></p><ol><li>IO线程</li><li>服务端业务线程</li><li>客户端调度线程</li><li>客户端结果exchange线程。</li><li>保活心跳线程</li><li>重连线程</li></ol><p><strong>线程池模型：</strong></p><ol><li>固定数量线程池</li><li>缓存线程池</li><li>有限线程池</li></ol><h3><span id="dubbo-长连接实现与配置"><strong>Dubbo 长连接实现与配置</strong></span></h3><p><strong>初始连接：</strong></p><p>引用服务增加提供者 —&gt; 获取连接 –&gt; 是否获取共享连接 –&gt;创建连接客户端–&gt;开启心跳检测状态检查定时任务–&gt; 开启连接状态检测.</p><blockquote><p>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#getClients</p></blockquote><p><strong>心跳发送：</strong><br>在创建一个连接客户端同时也会创建一个心跳客户端，客户端默认基于60秒发送一次心跳来保持连接的存活，可通过 heartbeat 设置。</p><blockquote><p>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchangeClient#startHeatbeatTimer</p></blockquote><p><strong>断线重连：</strong><br>每创建一个客户端连接都会启动一个定时任务每两秒中检测一次当前连接状态，如果断线则自动重连。</p><blockquote><p>com.alibaba.dubbo.remoting.transport.AbstractClient#initConnectStatusCheckCommand</p></blockquote><p><strong>连接销毁:</strong><br>基于注册中心通知，服务端断开后销毁</p><blockquote><p>com.alibaba.dubbo.remoting.transport.AbstractClient#close()</p></blockquote><h3><span id="dubbo-传输协作线程"><strong>Dubbo 传输协作线程</strong></span></h3><ol><li><strong>客户端调度线程</strong>：用于发起远程方法调用的线程。</li><li><strong>客户端结果Exchange线程：</strong> 当远程方法返回response后由该线程填充至指定ResponseFuture，并叫醒等待的调度线程。</li><li><strong>客户端IO线程</strong> 由传输框架实现，用于request 消息流发送、response 消息流读取与解码等操作。</li><li><strong>服务端IO线程</strong>：由传输框架实现，用于request消息流读取与解码 与Response发送。</li><li><strong>业务执行线程：</strong> 服务端具体执行业务方法的线程</li></ol><p><strong>客户端线程协作：</strong><br><img src="http://note.youdao.com/yws/res/9495/9564293312B2420DB80E156C7FB00CF5" alt="image"></p><ol><li><strong>调度线程</strong><ol><li>调用远程方法</li><li>对request 进行协议编码</li><li>发送request 消息至IO线程</li><li>等待结果的获取</li></ol></li><li><strong>IO线程</strong><ol><li>读取response流</li><li>response 解码</li><li>提交Exchange 任务</li></ol></li><li><strong>Exchange线程</strong><ol><li>填写response值 至 ResponseFuture</li><li>唤醒调度线程，通知其获取结果</li></ol></li></ol><p><strong>服务端线程协作：</strong><br><img src="http://note.youdao.com/yws/res/9500/6E0C6D20EF8C4276B16C4BCF37D183CF" alt="image"></p><ol><li><strong>IO线程：</strong><ol><li>request 流读取</li><li>request 解码</li><li>提交业务处理任务</li></ol></li><li><strong>业务线程：</strong><ol><li>业务方法执行</li><li>response 编码</li><li>回写结果至channel</li></ol></li></ol><p><strong>线程池</strong></p><ol><li><strong>fixed：</strong> 固定线程池,此线程池启动时即创建固定大小的线程数，不做任何伸缩，</li><li><strong>cached：</strong> 缓存线程池,此线程池可伸缩，线程空闲一分钟后回收，新请求重新创建线程</li><li><strong>Limited：</strong> 有限线程池,此线程池一直增长，直到上限，增长后不收缩。</li></ol><h2><span id="四-dubbo-协议">四、Dubbo 协议</span></h2><h3><span id="rpc-协议名词解释"><strong>RPC 协议名词解释</strong></span></h3><p>在一个典型RPC的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中RPC协议就指明了程序如何进行网络传输和序列化 。也就是说一个RPC协议的实现就等于一个非透明的远程调用实现，如何做到的的呢？</p><p><img src="http://note.youdao.com/yws/res/9510/AFE8EDF1A5B0427FA856137A2B9C6B12" alt="image"></p><p><img src="http://note.youdao.com/yws/res/9512/35AAA35E698A442687702615820C1AD7" alt="image"></p><ol><li>地址：服务提供者地址</li><li>端口：协议指定开放的端口</li><li>报文编码：协议报文编码 ，分为请求头和请求体两部分。</li><li>序列化方式：将请求体序列化成对象<br><img src="http://note.youdao.com/yws/res/9516/A8AA0D50758B4D9BA51737391F3AE4CE" alt="image"></li><li>运行服务: 网络传输实现<br><img src="http://note.youdao.com/yws/res/9514/3DC6FD7E7BFB4F4786B0CCD6A9BF87DA" alt="image"></li></ol><h3><span id="dubbo-支持的rpc协议">dubbo 支持的RPC协议</span></h3><p><img src="http://note.youdao.com/yws/res/9523/DC0DB69BE0F449DF870E40A1093A57CC" alt="image"></p><table><thead><tr><th style="text-align:left"><strong>名称</strong></th><th style="text-align:left"><strong>实现描述</strong></th><th style="text-align:left"><strong>连接描述</strong></th><th style="text-align:left"><strong>适用场景</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>dubbo</strong></td><td style="text-align:left">传输服务: mina, netty(默认), grizzy序列化: hessian2(默认), java, fastjson自定义报文</td><td style="text-align:left">单个长连接NIO异步传输</td><td style="text-align:left">1、常规RPC调用2、传输数据量小3、提供者少于消费者</td></tr><tr><td style="text-align:left"><strong>rmi</strong></td><td style="text-align:left">传输：java rmi 服务序列化：java原生二进制序列化</td><td style="text-align:left">多个短连接BIO同步传输</td><td style="text-align:left">1、常规RPC调用2、与原RMI客户端集成3、可传少量文件4、不支持防火墙穿透</td></tr><tr><td style="text-align:left"><strong>hessian</strong></td><td style="text-align:left">传输服务：servlet容器序列化：hessian二进制序列化</td><td style="text-align:left">基于Http 协议传输，依懒servlet容器配置</td><td style="text-align:left">1、提供者多于消费者2、可传大字段和文件3、跨语言调用</td></tr><tr><td style="text-align:left"><strong>http</strong></td><td style="text-align:left">传输服务：servlet容器序列化：java原生二进制序列化</td><td style="text-align:left">依懒servlet容器配置</td><td style="text-align:left">1、数据包大小混合</td></tr><tr><td style="text-align:left"><strong>thrift</strong></td><td style="text-align:left">与thrift RPC 实现集成，并在其基础上修改了报文头</td><td style="text-align:left">长连接、NIO异步传输</td></tr></tbody></table><p><strong><em>关于RMI不支持防火墙穿透的补充说明：</em></strong><br>    原因在于RMI 底层实现中会有两个端口，一个是固定的用于服务发现的注册端口，另外会生成一个<strong><em>随机</em></strong>端口用于网络传输。因为这个随机端口就不能在防火墙中提前设置开放开。所以存在<em>防火墙穿透问题</em></p><h3><span id="协议的使用与配置"><strong>协议的使用与配置:</strong></span></h3><p>Dubbo框架配置协议非常方便，用户只需要在 provider 应用中 配置<em>&lt;**dubbo:protocol&gt;</em>元素即可。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- name: 协议名称 dubbo|rmi|hessian|http|host:本机IP可不填，则系统自动获取port：端口、填-1表示系统自动选择server：运行服务 mina|netty|grizzy|servlet|jetty serialization：序列化方式 hessian2|java|compactedjava|fastjson 详细配置参见dubbo 官网 dubbo.io--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>protocol</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dubbo<span class="token punctuation">"</span></span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>192.168.0.11<span class="token punctuation">"</span></span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20880<span class="token punctuation">"</span></span> <span class="token attr-name">server</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>netty<span class="token punctuation">"</span></span> <span class="token attr-name">serialization</span><span class="token attr-value"><span class="token punctuation">=</span>“hessian2”</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span>“UTF-8”</span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="dubbo-支持的序列化">dubbo 支持的序列化：</span></h3><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td style="text-align:left">fastjson</td><td style="text-align:left">文本型：体积较大，性能慢、跨语言、可读性高</td></tr><tr><td style="text-align:left">fst</td><td style="text-align:left">二进制型：体积小、兼容 JDK 原生的序列化。要求 JDK 1.7 支持。</td></tr><tr><td style="text-align:left">hessian2</td><td style="text-align:left">二进制型：跨语言、容错性高、体积小</td></tr><tr><td style="text-align:left">java</td><td style="text-align:left">二进制型：在JAVA原生的基础上 可以写入Null</td></tr><tr><td style="text-align:left">compactedjava</td><td style="text-align:left">二进制型：与java 类似，内容做了压缩</td></tr><tr><td style="text-align:left">nativejava</td><td style="text-align:left">二进制型：原生的JAVA 序列化</td></tr><tr><td style="text-align:left">kryo</td><td style="text-align:left">二进制型：体积比hessian2 还要小，但容错性 没有hessian2 好</td></tr></tbody></table><h3><span id="hessian-序列化">Hessian 序列化</span></h3><ul><li>参数及返回值需实现 Serializable 接口</li><li>参数及返回值不能自定义实现 List,Map,Number,Date,Calendar等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。</li><li>Hessian 序列化，只传成员属性值和值的类型，不传方法或静态变量，兼容情况 <a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn1" target="_blank" rel="noopener">[1]</a><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html#fn2" target="_blank" rel="noopener">[2]</a>：</li></ul><table><thead><tr><th style="text-align:left"><strong>数据通讯</strong></th><th style="text-align:left"><strong>情况</strong></th><th style="text-align:left"><strong>结果</strong></th></tr></thead><tbody><tr><td style="text-align:left">A-&gt;B</td><td style="text-align:left">类A多一种 属性（或者说类B少一种 属性）</td><td style="text-align:left">不抛异常，A多的那 个属性的值，B没有， 其他正常</td></tr><tr><td style="text-align:left">A-&gt;B</td><td style="text-align:left">枚举A多一种 枚举（或者说B少一种 枚举），A使用多 出来的枚举进行传输</td><td style="text-align:left">抛异常</td></tr><tr><td style="text-align:left">A-&gt;B</td><td style="text-align:left">枚举A多一种 枚举（或者说B少一种 枚举），A不使用 多出来的枚举进行传输</td><td style="text-align:left">不抛异常，B正常接 收数据</td></tr><tr><td style="text-align:left">A-&gt;B</td><td style="text-align:left">A和B的属性 名相同，但类型不相同</td><td style="text-align:left">抛异常</td></tr><tr><td style="text-align:left">A-&gt;B</td><td style="text-align:left">serialId 不相同</td><td style="text-align:left">正常传输</td></tr></tbody></table><blockquote><p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署。输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署。<br>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。</p></blockquote><p>总结：服务器端和客户端对领域对象并不需要完全一致，而是按照最大匹配原则。</p><h2><span id="五-rpc协议报文编码与实现详解">五、RPC协议报文编码与实现详解</span></h2><h3><span id="rpc-传输实现"><strong>RPC 传输实现：</strong></span></h3><p>RPC的协议的传输是基于 TCP/IP 做为基础使用Socket 或Netty、mina等网络编程组件实现。但有个问题是TCP是面向字节流的无边边界协议，其只管负责数据传输并不会区分每次请求所对应的消息，这样就会出现TCP协义传输当中的拆包与粘包问题</p><h3><span id="拆包与粘包产生的原因"><strong>拆包与粘包产生的原因：</strong></span></h3><p>我们知道tcp是以流动的方式传输数据，传输的最小单位为一个报文段（segment）。tcp Header中有个Options标识位，常见的标识为mss(Maximum Segment Size)指的是，连接层每次传输的数据有个最大限制MTU(Maximum Transmission Unit)，一般是1500比特，超过这个量要分成多个报文段，mss则是这个最大限制减去TCP的header，光是要传输的数据的大小，一般为1460比特。换算成字节，也就是180多字节。</p><p>tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。这时就会出现以下情况：</p><ol><li>应用程序写入的数据大于MSS大小，这将会发生拆包。</li><li>应用程序写入数据小于MSS大小，这将会发生粘包。</li><li>接收方法不及时读取套接字缓冲区数据，这将发生粘包。</li></ol><h3><span id="拆包与粘包解决办法"><strong>拆包与粘包解决办法：</strong></span></h3><ol><li>设置定长消息，服务端每次读取既定长度的内容作为一条完整消息。</li><li>{“type”:”message”,”content”:”hello”}\n</li><li>使用带消息头的协议、消息头存储消息开始标识及消息长度信息，服务端获取消息头的时候解析出消息长度，然后向后读取该长度的内容。</li></ol><p><strong>比如：</strong> Http协议 heade 中的 Content-Length 就表示消息体的大小。</p><p><img src="http://note.youdao.com/yws/res/9536/1627E3D71B36459393AAD1066002AFE6" alt="image"></p><h3><span id="dubbo-协议报文编码">Dubbo 协议报文编码：</span></h3><p><strong>dubbo 协议报文编码：</strong></p><p><img src="http://note.youdao.com/yws/res/9538/25B9C2C5C20C46168D641144B2B6A07E" alt="image"></p><ul><li><strong>magic</strong>：类似java字节码文件里的魔数，用来判断是不是dubbo协议的数据包。魔数是常量0xdabb,用于判断报文的开始。</li><li><strong>flag</strong>：标志位, 一共8个地址位。低四位用来表示消息体数据用的序列化工具的类型（默认hessian），高四位中，第一位为1表示是request请求，第二位为1表示双向传输（即有返回response），第三位为1表示是心跳ping事件。</li><li><strong>status</strong>：状态位, 设置请求响应状态，dubbo定义了一些响应的类型。具体类型见 com.alibaba.dubbo.remoting.exchange.Response</li><li><strong>invoke id：</strong> 消息id, long 类型。每一个请求的唯一识别id（由于采用异步通讯的方式，用来把请求request和返回的response对应上）</li><li><strong>body length：</strong> 消息体 body 长度, int 类型，即记录Body Content有多少个字节。</li></ul><p><img src="http://note.youdao.com/yws/res/9542/B37D5C57C013452AA75C1DCB90F2766A" alt="image"></p><ul><li>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#encodeRequestData()</li></ul><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">encodeRequestData</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> ObjectOutput out<span class="token punctuation">,</span> Object data<span class="token punctuation">,</span> String version<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        RpcInvocation inv <span class="token operator">=</span> <span class="token punctuation">(</span>RpcInvocation<span class="token punctuation">)</span> data<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//版本号</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//接口路径</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getAttachment</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>PATH_KEY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//接口版本</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getAttachment</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>VERSION_KEY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//方法名称</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//参数类型</span>        out<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>ReflectUtils<span class="token punctuation">.</span><span class="token function">getDesc</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//参数值</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> inv<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>args <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token function">encodeInvocationArgument</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> inv<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>inv<span class="token punctuation">.</span><span class="token function">getAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#encodeResponseData()</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">encodeResponseData</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> ObjectOutput out<span class="token punctuation">,</span> Object data<span class="token punctuation">,</span> String version<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>      Result result <span class="token operator">=</span> <span class="token punctuation">(</span>Result<span class="token punctuation">)</span> data<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// currently, the version value in Response records the version of Request</span>      <span class="token keyword">boolean</span> attach <span class="token operator">=</span> Version<span class="token punctuation">.</span><span class="token function">isSupportResponseAttatchment</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>      Throwable th <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>th <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          Object ret <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              out<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span>attach <span class="token operator">?</span> RESPONSE_NULL_VALUE_WITH_ATTACHMENTS <span class="token operator">:</span> RESPONSE_NULL_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              out<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span>attach <span class="token operator">?</span> RESPONSE_VALUE_WITH_ATTACHMENTS <span class="token operator">:</span> RESPONSE_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>              out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          out<span class="token punctuation">.</span><span class="token function">writeByte</span><span class="token punctuation">(</span>attach <span class="token operator">?</span> RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS <span class="token operator">:</span> RESPONSE_WITH_EXCEPTION<span class="token punctuation">)</span><span class="token punctuation">;</span>          out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>th<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>attach<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// returns current version of Response to consumer side.</span>          result<span class="token punctuation">.</span><span class="token function">getAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>DUBBO_VERSION_KEY<span class="token punctuation">,</span> Version<span class="token punctuation">.</span><span class="token function">getProtocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          out<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">getAttachments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>解码</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Object <span class="token function">decodeBody</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> InputStream is<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> header<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">byte</span> flag <span class="token operator">=</span> header<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> proto <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> SERIALIZATION_MASK<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取 request id</span>        <span class="token keyword">long</span> id <span class="token operator">=</span> Bytes<span class="token punctuation">.</span><span class="token function">bytes2long</span><span class="token punctuation">(</span>header<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断是request 解码还是 response 解码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_REQUEST<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//客户端： 解码 response.</span>            Response res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_EVENT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">setEvent</span><span class="token punctuation">(</span>Response<span class="token punctuation">.</span>HEARTBEAT_EVENT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// get status.</span>            <span class="token keyword">byte</span> status <span class="token operator">=</span> header<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> Response<span class="token punctuation">.</span>OK<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Object data<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">isHeartbeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        data <span class="token operator">=</span> <span class="token function">decodeHeartbeatData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span>  CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">isEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        data <span class="token operator">=</span> <span class="token function">decodeEventData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span>  CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        DecodeableRpcResult result<span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>                                Constants<span class="token punctuation">.</span>DECODE_IN_IO_THREAD_KEY<span class="token punctuation">,</span>                                Constants<span class="token punctuation">.</span>DEFAULT_DECODE_IN_IO_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcResult</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> res<span class="token punctuation">,</span> is<span class="token punctuation">,</span>                                    <span class="token punctuation">(</span>Invocation<span class="token punctuation">)</span> <span class="token function">getRequestData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                            result<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcResult</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> res<span class="token punctuation">,</span>                                    <span class="token keyword">new</span> <span class="token class-name">UnsafeByteArrayInputStream</span><span class="token punctuation">(</span><span class="token function">readMessageData</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                    <span class="token punctuation">(</span>Invocation<span class="token punctuation">)</span> <span class="token function">getRequestData</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        data <span class="token operator">=</span> result<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    res<span class="token punctuation">.</span><span class="token function">setResult</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">setErrorMessage</span><span class="token punctuation">(</span>CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Decode response failed: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>Response<span class="token punctuation">.</span>CLIENT_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">setErrorMessage</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 服务端 ：解码 request.</span>            Request req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            req<span class="token punctuation">.</span><span class="token function">setVersion</span><span class="token punctuation">(</span>Version<span class="token punctuation">.</span><span class="token function">getProtocolVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            req<span class="token punctuation">.</span><span class="token function">setTwoWay</span><span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_TWOWAY<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> FLAG_EVENT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                req<span class="token punctuation">.</span><span class="token function">setEvent</span><span class="token punctuation">(</span>Request<span class="token punctuation">.</span>HEARTBEAT_EVENT<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Object data<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">isHeartbeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    data <span class="token operator">=</span> <span class="token function">decodeHeartbeatData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">isEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    data <span class="token operator">=</span> <span class="token function">decodeEventData</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> CodecSupport<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    DecodeableRpcInvocation inv<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>                            Constants<span class="token punctuation">.</span>DECODE_IN_IO_THREAD_KEY<span class="token punctuation">,</span>                            Constants<span class="token punctuation">.</span>DEFAULT_DECODE_IN_IO_THREAD<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        inv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcInvocation</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> req<span class="token punctuation">,</span> is<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                        inv<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        inv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecodeableRpcInvocation</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> req<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">UnsafeByteArrayInputStream</span><span class="token punctuation">(</span><span class="token function">readMessageData</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    data <span class="token operator">=</span> inv<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Decode request failed: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// bad request</span>                req<span class="token punctuation">.</span><span class="token function">setBroken</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                req<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> req<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://note.youdao.com/yws/res/9545/298139E160AA428486709FD4E1641C6A" alt="image"></p><h2><span id="六-最后">六、最后</span></h2><ol><li>负载均衡：多个机器调用哪一台?<blockquote><p>答：多种负载均衡策略。</p></blockquote></li><li>服务发现：怎样发现新的服务地址呢？<blockquote><p>答：服务注册与发现。</p></blockquote></li><li>健康检测：服务关宕机或恢复后怎么办？<blockquote><p>答：两种情况，消费者还是用老的请求，则</p></blockquote></li><li>容错：如果调用其中一台调用出错了怎么办？<blockquote><p>答：容错策略。</p></blockquote></li></ol><ul><li><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo官方文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="https://brokge.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="微服务" scheme="https://brokge.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis核心原理详解</title>
    <link href="https://brokge.github.io/2020/02/11/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://brokge.github.io/2020/02/11/Redis核心原理详解/</id>
    <published>2020-02-11T12:04:17.000Z</published>
    <updated>2020-06-05T13:29:56.986Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80redis-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">一、Redis 基础数据结构</a><ul><li><a href="#%E5%88%97%E8%A1%A8list">列表（list）</a></li><li><a href="#%E5%AD%97%E5%85%B8hash">字典（hash）</a></li><li><a href="#%E9%9B%86%E5%90%88set">集合（set）</a></li><li><a href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88sortedset">有序集合（sortedset）</a></li></ul></li><li><a href="#%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4">一些高级命令</a></li><li><a href="#%E4%BA%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86">二、线程模型核心原理</a></li><li><a href="#%E4%B8%89%E6%8C%81%E4%B9%85%E5%8C%96">三、持久化</a><ul><li><a href="#rdb%E5%BF%AB%E7%85%A7snapshot">RDB快照（snapshot）</a></li><li><a href="#aofappend-only-file">AOF（append-only file）</a></li><li><a href="#rdb-%E5%92%8C-aof-%E6%88%91%E5%BA%94%E8%AF%A5%E7%94%A8%E5%93%AA%E4%B8%80%E4%B8%AA">RDB 和 AOF ，我应该用哪一个？</a></li><li><a href="#redis-40-%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96">Redis 4.0 混合持久化</a></li></ul></li><li><a href="#%E5%9B%9B%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">四、缓存淘汰策略</a></li><li><a href="#%E4%BA%94redis%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">五、Redis集群原理分析</a><ul><li><a href="#%E6%A7%BD%E4%BD%8D%E5%AE%9A%E4%BD%8D%E7%AE%97%E6%B3%95">槽位定位算法</a></li><li><a href="#%E8%B7%B3%E8%BD%AC%E9%87%8D%E5%AE%9A%E4%BD%8D">跳转重定位</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E6%8A%96%E5%8A%A8">网络抖动</a></li><li><a href="#%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2-%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86">主从切换 选举原理</a></li></ul></li><li><a href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6">发布订阅机制</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="一-redis-基础数据结构">一、Redis 基础数据结构</span></h2><p>Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)，下面就详细说说这几种数据结构。<br><img src="http://note.youdao.com/yws/res/9583/0A3FCFF09EFA4D6A8B1F6D5CCCF848A8" alt="image"></p><h3><span id="列表list">列表（list）</span></h3><p>我们先来看列表。列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是压缩列表（ziplist），另一种是双向循环链表。当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><ol><li>列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；</li><li>列表中数据个数少于 512 个。</li></ol><p>所谓压缩列表，它并不是基础数据结构，而是 Redis为了<strong>压缩内存和支持存储不同类型的数据</strong>， 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同,由于分配的空间不同，所以不能通过地址索引随机访问。<br><img src="http://note.youdao.com/yws/res/9733/5909E6B696754BF0BD809353853E6B34" alt="image"><br>如果不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了。</p><h3><span id="字典hash">字典（hash）</span></h3><p>典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的压缩列表，另一种是散列表。同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。<br>具体需要满足两个条件：</p><ol><li>字典中保存的键和值的大小都要小于 64 字节；</li><li>字典中键值对的个数要小于 512 个。</li></ol><p>当不能同时满足上面两个条件的时候 Redis 就使用散列表来实现字典类型。Redis 使用<strong>MurmurHash2</strong>这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。</p><h3><span id="集合set">集合（set）</span></h3><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。</p><ol><li>存储的数据都是整数；</li><li>存储的数据元素个数不超过 512个。</li></ol><p>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</p><h3><span id="有序集合sortedset">有序集合（sortedset）</span></h3><p>有序集合这种数据类型，它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，进行数据结构组织。当数据量比较小的时候，Redis 会用压缩列表来实现有序集合。</p><ol><li>所有数据的大小都要小于 64 字节；</li><li>元素个数要小于 128 个。</li></ol><p>当两者都不满足时，会采用跳表这样的数据结构来存储。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p><h2><span id="一些高级命令">一些高级命令</span></h2><ul><li>keys：全量遍历键，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用</li></ul><ul><li><p>scan：渐进式遍历键，scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是遍历的 limit hint。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。</p></li><li><p>Info：查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是: </p><blockquote><p>Server 服务器运行的环境参数<br>  Clients 客户端相关信息<br>  Memory 服务器运行内存统计数据<br>  Persistence 持久化信息<br>  Stats 通用统计数据<br>  Replication 主从复制相关信息<br>  CPU CPU 使用情况<br>  Cluster 集群信息 </p></blockquote></li></ul><h2><span id="二-线程模型核心原理">二、线程模型核心原理</span></h2><p>Redis的单线程和高性能</p><p>Redis 单线程为什么还能这么快？</p><blockquote><p>因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。 </p></blockquote><p>Redis 单线程如何处理那么多的并发客户端连接？</p><blockquote><p>Redis的IO多路复用：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</p></blockquote><p>Nginx也是采用IO多路复用原理解决C10K问题</p><p><img src="http://note.youdao.com/yws/res/9595/F5F6FED5FA534F7CA467AD6D634E8E49" alt="image"></p><h2><span id="三-持久化">三、持久化</span></h2><h3><span id="rdb快照snapshot">RDB快照（snapshot）</span></h3><p>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。<br>你可以对 Redis 进行设置， 让它在“N秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。<br>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：</p><blockquote><p> save 60 1000</p></blockquote><h3><span id="aofappend-only-file">AOF（append-only file）</span></h3><p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将修改的每一条指令记录进文件<br>你可以通过修改配置文件来打开 AOF 功能：</p><blockquote><p>appendonly yes</p></blockquote><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。<br>这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。<br>你可以配置 Redis 多久才将数据 fsync 到磁盘一次。</p><p>有三个选项：</p><ol><li>每次有新命令追加到 AOF 文件时就执行一次 fsync：非常慢，也非常安全。</li><li>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li><li>从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。<br>推荐（并且也是默认）的措施为每秒 fsync一次， 这种 fsync 策略可以兼顾速度和安全性。 </li></ol><h3><span id="rdb-和-aof-我应该用哪一个">RDB 和 AOF ，我应该用哪一个？</span></h3><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。<br>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h3><span id="redis-40-混合持久化">Redis 4.0 混合持久化</span></h3><p>重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。AOF在重写(aof文件里可能有太多没用指令，所以aof会定期根据内存的最新数据生成aof文件)时将重写这一刻之前的内存rdb快照文件的内容和增量的 AOF修改内存数据的命令日志文件存在一起，都写入新的aof文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换；<br>AOF根据配置规则在后台自动重写，也可以人为执行命令bgrewriteaof重写AOF。 于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><p>开启混合持久化：</p><blockquote><p>aof-use-rdb-preamble yes   </p></blockquote><p>混合持久化aof文件结构</p><p><img src="http://note.youdao.com/yws/res/9610/00BB6062917B4FC4A6F72ADD90007BB4" alt="image"></p><h2><span id="四-缓存淘汰策略">四、缓存淘汰策略</span></h2><p>当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样龟速的存取效率基本上等于不可用。<br>在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小。<br>当实际内存超出 maxmemory 时，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务。</p><ul><li>noeviction 不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。</li><li>volatile-lru 尝试淘汰设置了过期时间的 key，最少使用的 key 优先被淘汰。没有设置过期时间的 key 不会被淘汰，这样可以保证需要持久化的数据不会突然丢失。</li><li>volatile-ttl 跟上面一样，除了淘汰的策略不是 LRU，而是 key 的剩余寿命 ttl 的值，ttl 越小越优先被淘汰。</li><li>volatile-random 跟上面一样，不过淘汰的 key 是过期 key 集合中随机的 key。</li><li>allkeys-lru 区别于 volatile-lru，这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰。</li><li>allkeys-random 跟上面一样，不过淘汰的策略是随机的 key。</li></ul><blockquote><p>volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。</p></blockquote><h2><span id="五-redis集群原理分析">五、Redis集群原理分析</span></h2><p>redis cluster 是 redis 分布式集群解决方案，从 3.0 之后推出解决 redis 分布式方面需求，实现数据分片、故障转移、扩容所容机制等。</p><p><img src="http://note.youdao.com/yws/res/9642/7EDE606229F6415BBA9A4C7A9FB975FB" alt="image"></p><p>Redis Cluster 将所有数据划分为 16384 的 slots(槽位)，每个节点负责其中一部分槽 位。槽位的信息存储于每个节点中。 当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将 其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。 同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实 现槽位信息的校验调整。</p><ul><li>redis集群大小的选择,可以装多少数据?<blockquote><p>理论是可以做到16384个集群,每个槽对应一个实例,但是redis官方建议是最大1000个实例。存储足够大了。另外：节点之间会有频繁通信，传递的包括槽位信息，集群太大会有带宽消耗。</p></blockquote></li></ul><h3><span id="槽位定位算法">槽位定位算法</span></h3><p>槽位定位算法 也就是常说的 一致性Hash算法<br>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整 数值对 16384 进行取模来得到具体槽位。 HASH_SLOT = CRC16(key) mod 16384</p><ul><li>那么增加了slot槽的计算,是不是比单机性能差?<blockquote><p>共16384个槽, slots槽计算方式公开的,<br>为了避免每次都需要服务器计算重定向,优秀的java客户端都实现了本地计算,并且缓存服务器slots分配,有变动时再更新本地内容,从而避免了多次重定向带来的性能损耗</p></blockquote></li></ul><ul><li>访问倾斜和数据存储倾斜问题怎么处理？<blockquote><p>倾斜导致某些节点量大，压力大 可以从两方面着手</p><ol><li>事前预测数据哪些会是热点数据，设计的时候规避。</li><li>事后 通过 slot 调整，压力分摊（slot 调整：rebalance 和 reshared）</li></ol></blockquote></li></ul><h3><span id="跳转重定位">跳转重定位</span></h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归 自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告 诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操 作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射 表。</p><p><img src="http://note.youdao.com/yws/res/9620/F13207F13DBB421EAD5B865697A65B79" alt="image"></p><ul><li>ask和moved重定向的区别<blockquote><p>重定向包括两种情况,若确定slot不属于当前节点, redis会返回moved<br>,若当煎redis节点正在处理slot迁移,则代表此处请求对应的key暂时不在此节定向。</p></blockquote></li></ul><h3><span id="网络抖动">网络抖动</span></h3><p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比 如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又 恢复正常。 为解决这种问题，Redis Cluster 提供了一种选项cluster node timeout，表示当某 个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切 换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p><h3><span id="主从切换-选举原理">主从切换 选举原理</span></h3><p>Redis 集群使用一个类似于木筏算法（Raft algorithm）概念。如果没有了解过可以看看这个  <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft</a>, 在 Redis 集群中这个术语叫做 阶段（epoch）。</p><p>Redis 集群中的每个节点，包括主节点和从节点，都在创建的时候设置了 currentEpoch 为0。每次主从选举之后 Epoch 会相应的加 1。如果出现脑裂的情况，其他主节点只认 epoch 最大的那个。</p><p>Redis集群选举原理分析当 slave 发现自己的 master 变为FAIL状态时，便尝试进行 Failover，以期成为新的 master。由于挂掉的master 可能会有多个 slave，从而存在多个 slave 竞争成为 master节点的过程， 其过程如下：</p><ol><li>slave 发现自己的 master变为FAIL</li><li>将自己记录的集群currentEpoch（年代，纪元）加 1，并广播FAILOVER_AUTH_REQUEST 信息</li><li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li><li>尝试failover的slave收集FAILOVER_AUTH_ACK</li><li>超过半数后变成新Master</li><li>广播 Pong 通知其他集群节点。</li></ol><p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p><ul><li>延迟计算公式：<blockquote><p>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p></blockquote></li><li>SLAVE_RANK 表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</li></ul><h2><span id="发布订阅机制">发布订阅机制</span></h2><p>发布/订阅（Publish/Subscribe）<br>在一个 Redis 集群中，客户端能订阅任何一个节点，也能发布消息给任何一个节点。集群会确保发布的消息都会按需进行转发。 目前的实现方式是单纯地向所有节点广播所有的发布消息，在将来的实现中会用 bloom filters 或其他算法来优化。</p><h2><span id="参考">参考</span></h2><ul><li><a href="http://redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">Redis 集群教程</a></li><li>数据结构与算法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="https://brokge.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Redis" scheme="https://brokge.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis5 集群搭建</title>
    <link href="https://brokge.github.io/2020/02/10/redis5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://brokge.github.io/2020/02/10/redis5集群搭建/</id>
    <published>2020-02-10T04:50:24.000Z</published>
    <updated>2020-06-05T13:30:06.047Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#1-%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF">1、 环境信息</a></li><li><a href="#2%E6%95%B4%E4%BD%93%E9%9B%86%E7%BE%A4%E4%BF%A1%E6%81%AF">2、整体集群信息</a></li><li><a href="#3%E6%AF%8F%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%9D%A2%E9%83%BD%E8%A6%81%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">3、每台服务器上面都要下载安装</a></li><li><a href="#4%E5%87%86%E5%A4%876%E4%B8%AAredisconf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E5%AD%A6%E4%B9%A0redisconf%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3%E6%9D%A5%E5%91%BD%E5%90%8D%E6%96%B9%E4%BE%BF%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%9E%84%E5%BB%BA%E4%BC%AA%E9%9B%86%E7%BE%A4">4、准备6个redis.conf配置文件（为了方便学习，redis.conf根据不同端口来命名，方便一台机器上构建伪集群）</a></li><li><a href="#5%E5%90%AF%E5%8A%A86%E4%B8%AAredis%E5%AE%9E%E4%BE%8B">5、启动6个Redis实例</a></li><li><a href="#6-%E5%88%9B%E5%BB%BAcluster">6、 创建cluster</a></li><li><a href="#7-%E9%9B%86%E7%BE%A4%E6%A3%80%E9%AA%8C%E5%92%8C%E6%B5%8B%E8%AF%95">7、 集群检验和测试</a></li><li><a href="#8%E9%9B%86%E7%BE%A4slot%E6%95%B0%E9%87%8F%E6%95%B4%E7%90%86-reshard">8、集群slot数量整理 reshard</a></li><li><a href="#9-%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">9、 测试自动故障转移</a></li><li><a href="#10%E6%89%8B%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB">10、手动故障转移</a></li><li><a href="#11%E6%89%A9%E5%AE%B9">11、扩容</a></li><li><a href="#12%E7%BC%A9%E5%AE%B9%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">12、缩容（删除节点）</a></li><li><a href="#13%E5%85%B3%E5%BF%83%E7%9A%84%E9%97%AE%E9%A2%98">13、关心的问题</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>[TOC]</p><h1><span id="1-环境信息">1、 环境信息</span></h1><pre class="line-numbers language-bash"><code class="language-bash">centos7redis5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1><span id="2-整体集群信息">2、整体集群信息</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 以直接在一台机器上实现上述的伪集群，因为端口号特意设置为不同的。</span><span class="token comment" spellcheck="true"># 重点：不论机器多少，对于部署过程都是一样的，只不过是在不同机器启动redis-server而已</span>192.168.100.242 <span class="token punctuation">(</span>6381- 6386共6个端口）<span class="token comment" spellcheck="true"># 注意事项：如果你的服务器有多个IP，那你操作下面步骤时，尽量使用你的客户端能够访问的IP</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="3-每台服务器上面都要下载安装">3、每台服务器上面都要下载安装</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> http://download.redis.io/releases/redis-5.0.3.tar.gz<span class="token function">tar</span> -zxvf redis-5.0.3.tar.gz<span class="token function">cd</span> redis-5.0.3 <span class="token function">make</span><span class="token comment" spellcheck="true"># 安装到 /usr/local/redis 目录中 安装的文件只有一个bin目录</span><span class="token function">make</span> <span class="token function">install</span> PREFIX<span class="token operator">=</span>/usr/local/redis/ <span class="token comment" spellcheck="true"># 创建配置文件和data存放目录</span><span class="token function">mkdir</span> /usr/local/redis/conf /usr/local/redis/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="4-准备6个redisconf配置文件为了方便学习redisconf根据不同端口来命名方便一台机器上构建伪集群">4、准备6个redis.conf配置文件（为了方便学习，redis.conf根据不同端口来命名，方便一台机器上构建伪集群）</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改</span><span class="token comment" spellcheck="true">#后台启动的意思</span>daemonize <span class="token function">yes</span>  <span class="token comment" spellcheck="true">#端口号</span>port 6381<span class="token comment" spellcheck="true"># IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病</span>bind 0.0.0.0<span class="token comment" spellcheck="true"># redis数据文件存放的目录</span><span class="token function">dir</span> /usr/local/redis/data<span class="token comment" spellcheck="true"># 开启AOF</span>appendonly <span class="token function">yes</span> <span class="token comment" spellcheck="true"># 开启集群</span>cluster-enabled <span class="token function">yes</span><span class="token comment" spellcheck="true"># 会自动生成在上面配置的dir目录下</span>cluster-config-file nodes-6381.conf cluster-node-timeout 5000<span class="token comment" spellcheck="true"># 这个文件会自动生成</span>pidfile /var/run/redis_6381.pid <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="5-启动6个redis实例">5、启动6个Redis实例</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 一定要注意每个配置文件中的端口号哦</span>/usr/local/redis/bin/redis-server /usr/local/redis/conf/6381.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6382.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6383.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6384.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6385.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/6386.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="6-创建cluster">6、 创建cluster</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 5.0版本的方式</span>/usr/local/redis/bin/redis-cli --cluster create 192.168.100.242:6381 192.168.100.242:6382 \192.168.100.242:6383 192.168.100.242:6384 192.168.100.242:6385 192.168.100.242:6386 \--cluster-replicas 1<span class="token comment" spellcheck="true"># 自动设置主从，而且会提示你，是否运行使用自动的配置</span>Can I <span class="token keyword">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span class="token function">yes</span><span class="token comment" spellcheck="true"># 执行后的信息</span><span class="token operator">>></span><span class="token operator">></span> Performing <span class="token function">hash</span> slots allocation on 6 nodes<span class="token punctuation">..</span>.Master<span class="token punctuation">[</span>0<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 0 - 5460Master<span class="token punctuation">[</span>1<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 5461 - 10922Master<span class="token punctuation">[</span>2<span class="token punctuation">]</span> -<span class="token operator">></span> Slots 10923 - 16383Adding replica 192.168.100.242:6384 to 192.168.100.242:6381Adding replica 192.168.100.242:6385 to 192.168.100.242:6382Adding replica 192.168.100.242:6386 to 192.168.100.242:6383<span class="token operator">>></span><span class="token operator">></span> Trying to optimize slaves allocation <span class="token keyword">for</span> anti-affinity<span class="token punctuation">[</span>WARNING<span class="token punctuation">]</span> Some slaves are <span class="token keyword">in</span> the same host as their masterM: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> masterM: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> masterM: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> masterS: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7S: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3cCan I <span class="token keyword">set</span> the above configuration? <span class="token punctuation">(</span>type <span class="token string">'yes'</span> to accept<span class="token punctuation">)</span>: <span class="token function">yes</span><span class="token operator">>></span><span class="token operator">></span> Nodes configuration updated<span class="token operator">>></span><span class="token operator">></span> Assign a different config epoch to each node<span class="token operator">>></span><span class="token operator">></span> Sending CLUSTER MEET messages to <span class="token function">join</span> the clusterWaiting <span class="token keyword">for</span> the cluster to <span class="token function">join</span><span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Performing Cluster Check <span class="token punctuation">(</span>using node 192.168.100.242:6381<span class="token punctuation">)</span>M: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86S: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7M: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>M: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3c<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">>></span><span class="token operator">></span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All 16384 slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="7-集群检验和测试">7、 集群检验和测试</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 检查集群，查看所有节点信息</span>/usr/local/redis/bin/redis-cli -c -h 192.168.100.242 -p 6381 cluster nodes<span class="token comment" spellcheck="true"># 执行后的信息</span><span class="token punctuation">[</span>root@node3 redis<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># /usr/local/redis/bin/redis-cli -c -h 192.168.100.242 -p 6381 cluster nodes</span>0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385@16385 slave 93293699b8966ccc202bb29c659a9f60e26e4c86 0 1550635081000 5 connecteda842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384@16384 slave 764500b86fadebd535ac2b5b778a73486fe7d2b7 0 1550635081565 4 connected93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383@16383 master - 0 1550635081665 3 connected 10923-16383764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382@16382 master - 0 1550635081000 2 connected 5461-1092268326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381@16381 myself,master - 0 1550635080000 1 connected 0-546042806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386@16386 slave 68326caa0238cb877afc3e6df23eb92558fcbc3c 0 1550635080664 6 connected<span class="token comment" spellcheck="true"># 节点id ip+端口 角色 masterid 处理的ping数量 最后一个pong时间 节点配置版本 节点连接状态 slot槽分配情况</span><span class="token comment" spellcheck="true"># 测试Redis Cluster的一种简单方法是使用redis-cli命令行实用程序</span><span class="token comment" spellcheck="true"># -c 是支持cluster重定向</span><span class="token punctuation">[</span>root@node3 redis<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># /usr/local/redis/bin/redis-cli -c -h 192.168.100.242 -p 6381</span>192.168.100.242:6381<span class="token operator">></span> <span class="token keyword">set</span> a 1-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>15495<span class="token punctuation">]</span> located at 192.168.100.242:6383OK192.168.100.242:6383<span class="token operator">></span> get a<span class="token string">"1"</span>192.168.100.242:6383<span class="token operator">></span> <span class="token keyword">set</span> hello tony-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>866<span class="token punctuation">]</span> located at 192.168.100.242:6381OK192.168.100.242:6381<span class="token operator">></span> get hello<span class="token string">"tony"</span>192.168.100.242:6381<span class="token operator">></span> get a-<span class="token operator">></span> Redirected to slot <span class="token punctuation">[</span>15495<span class="token punctuation">]</span> located at 192.168.100.242:6383<span class="token string">"1"</span><span class="token comment" spellcheck="true"># 查看一个key属于哪一个节点</span>CLUSTER KEYSLOT key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="8-集群slot数量整理-reshard">8、集群slot数量整理 reshard</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#  /usr/local/redis/bin/redis-cli --cluster help 可以查看所有这个命令和子命令的帮助信息</span><span class="token comment" spellcheck="true"># 默认是master平均分了0-16383的所有虚拟slot</span><span class="token comment" spellcheck="true"># 可以进行调整，部分节点放多一点slot(槽或者位置)。</span>/usr/local/redis/bin/redis-cli --cluster reshard  <span class="token operator">&lt;</span>host<span class="token operator">></span>:<span class="token operator">&lt;</span>port<span class="token operator">></span> --cluster-from <span class="token operator">&lt;</span>node-id<span class="token operator">></span> --cluster-to <span class="token operator">&lt;</span>node-id<span class="token operator">></span> --cluster-slots <span class="token operator">&lt;</span>number of slots<span class="token operator">></span> --cluster-yes<span class="token comment" spellcheck="true"># 重新检查集群</span><span class="token punctuation">[</span>root@node3 redis<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># /usr/local/redis/bin/redis-cli --cluster check 192.168.100.242:6382</span>192.168.100.242:6382 <span class="token punctuation">(</span>764500b8<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">></span> 0 keys <span class="token operator">|</span> 5462 slots <span class="token operator">|</span> 1 slaves.192.168.100.242:6383 <span class="token punctuation">(</span>93293699<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">></span> 1 keys <span class="token operator">|</span> 5461 slots <span class="token operator">|</span> 1 slaves.192.168.100.242:6381 <span class="token punctuation">(</span>68326caa<span class="token punctuation">..</span>.<span class="token punctuation">)</span> -<span class="token operator">></span> 1 keys <span class="token operator">|</span> 5461 slots <span class="token operator">|</span> 1 slaves.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> 2 keys <span class="token keyword">in</span> 3 masters.0.00 keys per slot on average.<span class="token operator">>></span><span class="token operator">></span> Performing Cluster Check <span class="token punctuation">(</span>using node 192.168.100.242:6382<span class="token punctuation">)</span>M: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382   slots:<span class="token punctuation">[</span>5461-10922<span class="token punctuation">]</span> <span class="token punctuation">(</span>5462 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7M: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383   slots:<span class="token punctuation">[</span>10923-16383<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span>S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3cS: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385   slots: <span class="token punctuation">(</span>0 slots<span class="token punctuation">)</span> slave   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86M: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381   slots:<span class="token punctuation">[</span>0-5460<span class="token punctuation">]</span> <span class="token punctuation">(</span>5461 slots<span class="token punctuation">)</span> master   1 additional replica<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All nodes agree about slots configuration.<span class="token operator">>></span><span class="token operator">></span> Check <span class="token keyword">for</span> <span class="token function">open</span> slots<span class="token punctuation">..</span>.<span class="token operator">>></span><span class="token operator">></span> Check slots coverage<span class="token punctuation">..</span>.<span class="token punctuation">[</span>OK<span class="token punctuation">]</span> All 16384 slots covered.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="9-测试自动故障转移">9、 测试自动故障转移</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># cluster集群不保证数据一致，数据也可能丢失</span><span class="token comment" spellcheck="true"># 首先是运行客户端不断的写入或读取数据，以便能够发现问题</span><span class="token comment" spellcheck="true"># 然后是模拟节点故障：找一个主节点关闭，主从故障切换的过程中，这个时间端的操作，客户端而言，只能是失败</span><span class="token comment" spellcheck="true"># 官方描述 https://redis.io/topics/cluster-spec  </span>There is always a window of <span class="token function">time</span> when it is possible to lose writes during partitions.分区的时间窗口内总是有可能丢失写操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="10-手动故障转移">10、手动故障转移</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 可能某个节点需要维护（机器下线、硬件升级、系统版本调整等等场景），需要手动的实现转移</span><span class="token comment" spellcheck="true"># 在slave节点上执行命令</span>CLUSTER FAILOVER <span class="token comment" spellcheck="true"># 注：CLUSTER  help 可以看到帮助文档和简介。 相对安全的做法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="11-扩容">11、扩容</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、 启动新节点</span>/usr/local/redis/bin/redis-server /usr/local/redis/conf/6387.conf<span class="token comment" spellcheck="true"># 2、 加入到已经存在的集群作为master</span>/usr/local/redis/bin/redis-cli --cluster add-node 192.168.100.242:6387 192.168.100.242:6382<span class="token comment" spellcheck="true"># 本质就是发送一个新节点通过 CLUSTER MEET命令加入集群</span><span class="token comment" spellcheck="true"># 新节点没有分配hash槽</span><span class="token comment" spellcheck="true"># 3、 加入到已经存在的集群作为slave</span>/usr/local/redis/bin/redis-cli --cluster add-node 192.168.100.242:7006 192.168.100.242:7000 --cluster-slave<span class="token comment" spellcheck="true"># 可以手工指定master，否则就是选择一个slave数量较少的master </span>/usr/local/redis/bin/redis-cli --cluster add-node 192.168.100.242:7006 192.168.100.242:7000 --cluster-slave --cluster-master-id <span class="token operator">&lt;</span>node-id<span class="token operator">></span><span class="token comment" spellcheck="true"># 还可以将空master，转换为slave</span>cluster replicate <span class="token operator">&lt;</span>master-node-id<span class="token operator">></span><span class="token comment" spellcheck="true"># 4、 检查集群</span>/usr/local/redis/bin/redis-cli --cluster check 192.168.100.242:6382<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="12-缩容删除节点">12、缩容（删除节点）</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 注意：删除master的时候要把数据清空或者分配给其他主节点</span>/usr/local/redis/bin/redis-cli --cluster del-node 192.168.100.242:6381 <span class="token operator">&lt;</span>node-id<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1><span id="13-关心的问题">13、关心的问题</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、 增加了slot槽的计算，是不是比单机性能差？</span>共16384个槽，slots槽计算方式公开的，java客户端中就使用了：HASH_SLOT <span class="token operator">=</span> CRC16<span class="token punctuation">(</span>key<span class="token punctuation">)</span> mod 16384为了避免每次都需要服务器计算重定向，优秀的java客户端都实现了本地计算，和服务器slots分配进行映射，有变动时再更新本地内容。<span class="token comment" spellcheck="true"># 2、 redis集群大小</span>理论是可以做到16384个槽，但是redis官方建议是最大1000个实例<span class="token comment" spellcheck="true"># 3、 批量操作或者</span><span class="token comment" spellcheck="true"># 4、cluster meet命令中的bus-port是什么？</span>MEET <span class="token operator">&lt;</span>ip<span class="token operator">></span> <span class="token operator">&lt;</span>port<span class="token operator">></span> <span class="token punctuation">[</span>bus-port<span class="token punctuation">]</span>每个Redis群集节点都有一个额外的TCP端口，用于接收来自其他Redis群集节点的传入连接<span class="token comment" spellcheck="true"># 5、集群节点间的通信方式</span>每个节点使用TCP连接与每个其他节点连接。<span class="token comment" spellcheck="true"># 6、ask和moved重定向的区别</span>重定向包括两种情况如果是确定slot不属于当前节点，redis会返回moved如果当前redis节点正在处理slot迁移，则代表此处请求对应的key暂时不在此节点，返回ask，告诉客户端本次请求重定向<span class="token comment" spellcheck="true"># 7、数据倾斜和访问倾斜的问题</span>解决办法 调整key的策略 + slot迁移迁移过程如下，完整的迁移流程：在迁移目的节点执行cluster setslot <span class="token operator">&lt;</span>slot<span class="token operator">></span> IMPORTING <span class="token operator">&lt;</span>node ID<span class="token operator">></span>命令，指明需要迁移的slot和迁移源节点。在迁移源节点执行cluster setslot <span class="token operator">&lt;</span>slot<span class="token operator">></span> MIGRATING <span class="token operator">&lt;</span>node ID<span class="token operator">></span>命令，指明需要迁移的slot和迁移目的节点。在迁移源节点执行cluster getkeysinslot获取该slot的key列表。在迁移源节点执行对每个key执行migrate命令，该命令会同步把该key迁移到目的节点。在迁移源节点反复执行cluster getkeysinslot命令，直到该slot的列表为空。在迁移源节点和目的节点执行cluster setslot <span class="token operator">&lt;</span>slot<span class="token operator">></span> NODE <span class="token operator">&lt;</span>node ID<span class="token operator">></span>，完成迁移操作。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="https://brokge.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Redis" scheme="https://brokge.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵高可用搭建</title>
    <link href="https://brokge.github.io/2020/02/06/redis%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://brokge.github.io/2020/02/06/redis哨兵高可用搭建/</id>
    <published>2020-02-06T12:50:24.000Z</published>
    <updated>2020-06-05T13:30:29.772Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#redis%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">Redis下载安装</a></li><li><a href="#%E5%87%86%E5%A4%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">准备配置文件</a></li><li><a href="#%E5%87%86%E5%A4%87%E4%B8%89%E4%B8%AAredis%E6%9C%8D%E5%8A%A1">准备三个redis服务</a></li><li><a href="#%E5%87%86%E5%A4%87%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">准备哨兵配置文件</a></li><li><a href="#%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4">启动哨兵集群</a></li><li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li><li><a href="#%E5%93%A8%E5%85%B5%E5%90%8C%E6%AD%A5pubsub%E6%9C%BA%E5%88%B6%E5%8F%91%E5%87%BA%E6%9D%A5%E7%9A%84%E6%B6%88%E6%81%AF">哨兵同步pubsub机制发出来的消息</a></li><li><a href="#%E5%93%A8%E5%85%B5%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90">哨兵日志分析</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p> [TOC]</p><h1><span id="redis下载安装">Redis下载安装</span></h1><pre class="line-numbers language-bash"><code class="language-bash">下载redishttps://redis.io/download<span class="token comment" spellcheck="true"># 下载</span><span class="token function">wget</span> http://download.redis.io/releases/redis-5.0.3.tar.gz<span class="token comment" spellcheck="true"># Installation</span><span class="token function">tar</span> xzf redis-5.0.3.tar.gz<span class="token function">cd</span> redis-5.0.3<span class="token function">make</span><span class="token comment" spellcheck="true"># 创建文件夹 </span><span class="token function">mkdir</span> /usr/local/redis/conf<span class="token function">mkdir</span> /usr/local/redis/data<span class="token function">mkdir</span> /usr/local/redis/logs<span class="token comment" spellcheck="true"># run</span>src/redis-server<span class="token comment" spellcheck="true"># warning 1 > 提示修改 linux内核参数</span><span class="token comment" spellcheck="true"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><span class="token keyword">echo</span> 1024 <span class="token operator">></span>/proc/sys/net/core/somaxconn<span class="token comment" spellcheck="true"># warn 2 > 提示如下</span><span class="token comment" spellcheck="true"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span><span class="token keyword">echo</span> <span class="token string">"vm.overcommit_memory = 1"</span> <span class="token operator">>></span> /etc/sysctl.confsysctl vm.overcommit_memory<span class="token operator">=</span>1<span class="token comment" spellcheck="true"># warning 3</span><span class="token comment" spellcheck="true"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled</span><span class="token keyword">echo</span> never <span class="token operator">></span> /sys/kernel/mm/transparent_hugepage/enabled<span class="token comment" spellcheck="true"># 云服务器要注意ip要写对，端口要开放</span><span class="token comment" spellcheck="true"># 虚拟机要注意防火墙要关闭 systemctl stop firewalld.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="准备配置文件">准备配置文件</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改</span><span class="token comment" spellcheck="true">#后台启动的意思</span>daemonize <span class="token function">yes</span>  <span class="token comment" spellcheck="true">#端口号(如果同一台服务器上启动，注意要修改为不同的端口)</span>port 6380<span class="token comment" spellcheck="true"># IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病</span>bind 0.0.0.0<span class="token comment" spellcheck="true"># 这个文件会自动生成(如果同一台服务器上启动，注意要修改为不同的端口)</span>pidfile /var/run/redis_6380.pid <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="准备三个redis服务">准备三个redis服务</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1、启动三个Redis</span>/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6380.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6381.conf/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis-6382.conf<span class="token comment" spellcheck="true"># 2、配置为 1主2从</span>/usr/local/redis/bin/redis-cli -p 6381 slaveof 192.168.100.241 6380/usr/local/redis/bin/redis-cli -p 6382 slaveof 192.168.100.241 6380<span class="token comment" spellcheck="true"># 3、检查集群</span>/usr/local/redis/bin/redis-cli -p 6380 info Replication<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="准备哨兵配置文件">准备哨兵配置文件</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置文件：sentinel.conf，在sentinel运行期间是会被动态修改的</span><span class="token comment" spellcheck="true"># sentinel如果重启时，根据这个配置来恢复其之前所监控的redis集群的状态</span><span class="token comment" spellcheck="true"># 绑定IP</span>bind 0.0.0.0<span class="token comment" spellcheck="true"># 后台运行</span>daemonize <span class="token function">yes</span><span class="token comment" spellcheck="true"># 默认yes，没指定密码或者指定IP的情况下，外网无法访问</span>protected-mode no<span class="token comment" spellcheck="true"># 哨兵的端口，客户端通过这个端口来发现redis</span>port 26380<span class="token comment" spellcheck="true"># 哨兵自己的IP，手动设定也可自动发现，用于与其他哨兵通信</span><span class="token comment" spellcheck="true"># sentinel announce-ip</span><span class="token comment" spellcheck="true"># 临时文件夹</span><span class="token function">dir</span> /tmp<span class="token comment" spellcheck="true"># 日志</span>logfile <span class="token string">"/usr/local/redis/logs/sentinel-26380.log"</span><span class="token comment" spellcheck="true"># sentinel监控的master的名字叫做mymaster,初始地址为 192.168.100.241 6380,2代表两个及以上哨兵认定为死亡，才认为是真的死亡</span>sentinel monitor mymaster 192.168.100.241 6380 2<span class="token comment" spellcheck="true"># 发送心跳PING来确认master是否存活</span><span class="token comment" spellcheck="true"># 如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了</span>sentinel down-after-milliseconds mymaster 1000<span class="token comment" spellcheck="true"># 如果在该时间（ms）内未能完成failover操作，则认为该failover失败</span>sentinel failover-timeout mymaster 3000<span class="token comment" spellcheck="true"># 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span>sentinel parallel-syncs mymaster 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="启动哨兵集群">启动哨兵集群</span></h1><pre class="line-numbers language-bash"><code class="language-bash">/usr/local/redis/bin/redis-server /usr/local/redis/conf/sentinel-26380.conf --sentinel/usr/local/redis/bin/redis-server /usr/local/redis/conf/sentinel-26381.conf --sentinel/usr/local/redis/bin/redis-server /usr/local/redis/conf/sentinel-26382.conf --sentinel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1><span id="测试">测试</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 停掉master，主从切换过程</span>启动哨兵<span class="token punctuation">(</span>客户端通过哨兵发现Redis实例信息<span class="token punctuation">)</span>哨兵通过连接master发现主从集群内的所有实例信息哨兵监控redis实例的健康状况哨兵一旦发现master不能正常提供服务，则通知给其他哨兵当一定数量的哨兵都认为master挂了选举一个哨兵作为故障转移的执行者执行者在slave中选取一个作为新的master将其他slave重新设定为新master的从属<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="哨兵同步pubsub机制发出来的消息">哨兵同步pubsub机制发出来的消息</span></h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># https://redis.io/topics/sentinel#pubsub-messages</span>+reset-master <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当master被重置时.+slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当检测到一个slave并添加进slave列表时.+failover-state-reconf-slaves <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- Failover状态变为reconf-slaves状态时+failover-detected <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当failover发生时+slave-reconf-sent <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- sentinel发送SLAVEOF命令把它重新配置时+slave-reconf-inprog <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- slave被重新配置为另外一个master的slave，但数据复制还未发生时。+slave-reconf-done <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- slave被重新配置为另外一个master的slave并且数据复制已经与master同步时。-dup-sentinel <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 删除指定master上的冗余sentinel时 <span class="token punctuation">(</span>当一个sentinel重新启动时，可能会发生这个事件<span class="token punctuation">)</span>.+sentinel <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当master增加了一个sentinel时。+sdown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 进入SDOWN状态时<span class="token punctuation">;</span>-sdown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 离开SDOWN状态时。+odown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 进入ODOWN状态时。-odown <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 离开ODOWN状态时。+new-epoch <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当前配置版本被更新时。+try-failover <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 达到failover条件，正等待其他sentinel的选举。+elected-leader <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 被选举为去执行failover的时候。+failover-state-select-slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 开始要选择一个slave当选新master时。+no-good-slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 没有合适的slave来担当新master+selected-slave <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 找到了一个适合的slave来担当新master+promoted-slave -- 确认成功+failover-state-reconf-slaves -- 开始对slaves进行reconfig操作+slave-reconf-sent -- 向指定的slave发送“slaveof”指令，告知此slave跟随新的master+slave-reconf-inprog -- 此slave正在执行slaveof + SYNC过程，slave收到“+slave-reconf-sent”之后将会执行slaveof操作+slave-reconf-done -- 此slave同步完成，此后leader可以继续下一个slave的reconfig操作failover-state-send-slaveof-noone <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- 当把选择为新master的slave的身份进行切换的时候。failover-end-for-timeout <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- failover由于超时而失败时。failover-end <span class="token operator">&lt;</span>instance details<span class="token operator">></span> -- failover成功完成,故障转移结束switch-master <span class="token operator">&lt;</span>master name<span class="token operator">></span> <span class="token operator">&lt;</span>oldip<span class="token operator">></span> <span class="token operator">&lt;</span>oldport<span class="token operator">></span> <span class="token operator">&lt;</span>newip<span class="token operator">></span> <span class="token operator">&lt;</span>newport<span class="token operator">></span> -- 当master的地址发生变化时。通常这是客户端最感兴趣的消息了。+tilt -- 进入Tilt模式。-tilt -- 退出Tilt模式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1><span id="哨兵日志分析">哨兵日志分析</span></h1><pre class="line-numbers language-bash"><code class="language-bash">sdow <span class="token punctuation">(</span>sdown subjectively down<span class="token punctuation">)</span>odown <span class="token punctuation">(</span>objectively down<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 通过日志逐步分析</span>996:X 23 Nov 01:00:30.020 <span class="token comment" spellcheck="true"># +sdown master mymaster 60.205.209.106 6381</span>996:X 23 Nov 01:00:30.143 <span class="token comment" spellcheck="true"># +new-epoch 4</span>996:X 23 Nov 01:00:30.144 <span class="token comment" spellcheck="true"># +vote-for-leader 699538b978f33f677c8be471eed344b3933eca8c 4</span>996:X 23 Nov 01:00:31.111 <span class="token comment" spellcheck="true"># +odown master mymaster 60.205.209.106 6381 #quorum 3/2</span>996:X 23 Nov 01:00:31.111 <span class="token comment" spellcheck="true"># Next failover delay: I will not start a failover before Thu Nov 23 01:00:36 2017</span>996:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +config-update-from sentinel 699538b978f33f677c8be471eed344b3933eca8c 172.17.171.34 26381 @ mymaster 60.205.209.106 6381</span>996:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span>996:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6380996:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380996:X 23 Nov 01:00:32.233 <span class="token comment" spellcheck="true"># +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span>1073:X 23 Nov 01:00:30.087 <span class="token comment" spellcheck="true"># +sdown master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +odown master mymaster 60.205.209.106 6381 #quorum 3/2</span>1073:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +new-epoch 4</span>1073:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +try-failover master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.141 <span class="token comment" spellcheck="true"># +vote-for-leader 699538b978f33f677c8be471eed344b3933eca8c 4</span>1073:X 23 Nov 01:00:30.142 <span class="token comment" spellcheck="true"># 8412b6b2ac39a3d36c171590cd23cbe025517c15 voted for 8412b6b2ac39a3d36c171590cd23cbe025517c15 4</span>1073:X 23 Nov 01:00:30.144 <span class="token comment" spellcheck="true"># f8c7e052744926747ef1f31c27da4721fde3faf4 voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span>1073:X 23 Nov 01:00:30.232 <span class="token comment" spellcheck="true"># +elected-leader master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.232 <span class="token comment" spellcheck="true"># +failover-state-select-slave master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.294 <span class="token comment" spellcheck="true"># +selected-slave slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:30.294 * +failover-state-send-slaveof-noone slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:30.356 * +failover-state-wait-promotion slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:31.153 <span class="token comment" spellcheck="true"># +promoted-slave slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:31.153 <span class="token comment" spellcheck="true"># +failover-state-reconf-slaves master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:31.200 * +slave-reconf-sent slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:32.149 * +slave-reconf-inprog slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:32.149 * +slave-reconf-done slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63811073:X 23 Nov 01:00:32.220 <span class="token comment" spellcheck="true"># -odown master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:32.220 <span class="token comment" spellcheck="true"># +failover-end master mymaster 60.205.209.106 6381</span>1073:X 23 Nov 01:00:32.220 <span class="token comment" spellcheck="true"># +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span>1073:X 23 Nov 01:00:32.220 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63801073:X 23 Nov 01:00:32.220 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 63801073:X 23 Nov 01:00:33.227 <span class="token comment" spellcheck="true"># +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span>1009:X 23 Nov 01:00:30.039 <span class="token comment" spellcheck="true"># +sdown master mymaster 60.205.209.106 6381</span>1009:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +odown master mymaster 60.205.209.106 6381 #quorum 2/2</span>1009:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +new-epoch 4</span>1009:X 23 Nov 01:00:30.139 <span class="token comment" spellcheck="true"># +try-failover master mymaster 60.205.209.106 6381</span>1009:X 23 Nov 01:00:30.142 <span class="token comment" spellcheck="true"># +vote-for-leader 8412b6b2ac39a3d36c171590cd23cbe025517c15 4</span>1009:X 23 Nov 01:00:30.142 <span class="token comment" spellcheck="true"># 699538b978f33f677c8be471eed344b3933eca8c voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span>1009:X 23 Nov 01:00:30.144 <span class="token comment" spellcheck="true"># f8c7e052744926747ef1f31c27da4721fde3faf4 voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span>1009:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +config-update-from sentinel 699538b978f33f677c8be471eed344b3933eca8c 172.17.171.34 26381 @ mymaster 60.205.209.106 6381</span>1009:X 23 Nov 01:00:31.200 <span class="token comment" spellcheck="true"># +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span>1009:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 63801009:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 63801009:X 23 Nov 01:00:32.258 <span class="token comment" spellcheck="true"># +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据一致性的处理办法之一</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 这些配置仅当redis为master时才有效</span><span class="token comment" spellcheck="true"># 当master不符合这些条件时，它将停止对外的服务。这种场景主要是用于master在网络上被孤立了。</span>min-slaves-to-write 1min-slaves-max-lag 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="https://brokge.github.io/tags/Redis/"/>
    
      <category term="缓存" scheme="https://brokge.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://brokge.github.io/2020/01/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://brokge.github.io/2020/01/08/单例模式/</id>
    <published>2020-01-08T06:39:53.992Z</published>
    <updated>2020-06-05T13:21:55.813Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#%E5%8D%95%E4%BE%8B">单例</a><ul><li><a href="#%E6%A6%82%E5%BF%B5%E7%89%B9%E7%82%B9">概念特点</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a><ul><li><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F">饿汉式</a></li><li><a href="#%E6%87%92%E6%B1%89%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%94%81%E5%AE%9A">懒汉式与线程锁定</a></li><li><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB%E4%B8%8E%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB%E6%AF%94%E8%BE%83">饿汉式单例类与懒汉式单例类比较</a></li></ul></li><li><a href="#%E4%BB%A5%E4%B8%8A%E6%80%BB%E7%BB%93">以上总结</a><ul><li><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">静态内部类</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><hr><p>title: 单例模式<br>date: 2019-12-08 14:39:53<br>tags:</p><ul><li>设计模式<br>categories:<ul><li>人文</li></ul></li></ul><hr><p>[toc]</p><h1><span id="单例">单例</span></h1><h2><span id="概念特点">概念特点</span></h2><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><ul><li>三要点：</li></ul><ol><li>某个类只能有一个实例；</li><li>是它必须自行创建这个实例；</li><li>是它必须自行向整个系统提供这个实例。</li></ol><ul><li>实现过程：</li></ul><p>在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p><ul><li>单例模式唯一实例为什么是静态的？</li></ul><blockquote><p>因为程序调用类中方法只有两种方式</p><ol><li>创建类的一个对象，用该对象去调用类中方法；</li><li>使用类名直接调用类中方法，格式“类名.方法名()”； </li></ol><p>上面说了，构造函数私有化后第一种情况就不能用，只能使用第二种方法。 而使用类名直接调用类中方法，类中方法必须是静态的，而静态方法不能访问非静态成员变量，因此类自定义的实例变量也必须是静态的。 这就是单例模式唯一实例必须设置为静态的原因</p></blockquote><h2><span id="实现方式">实现方式</span></h2><h3><span id="饿汉式">饿汉式</span></h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//饿汉式</span><span class="token keyword">class</span> <span class="token class-name">EagerSingleton</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> EagerSingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EagerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token function">EagerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> EagerSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。</p><h3><span id="懒汉式与线程锁定">懒汉式与线程锁定</span></h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> LazySingleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>     <span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized</p><p>在getInstance()方法前面增加了关键字synchronized进行线程锁，以处理多个线程同时访问的问题。但是，上述代码虽然解决了线程安全问题，但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。如何既解决线程安全问题又不影响系统性能呢？</p><p>我们继续对懒汉式单例进行改进。事实上，我们无须对整个getInstance()方法进行锁定，只需对其中的代码“instance = new LazySingleton();”进行锁定即可。因此getInstance()方法可以进行如下改进</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LazySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在<strong>单例对象不唯一</strong>。</p><p>原因如下：</p><blockquote><p>假如在某一瞬间线程A和线程B都在调用 getInstance() 方法，此时instance对象为null值，均能通过instance == null的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，这种方式称为<strong>双重检查锁定(Double-Check Locking)</strong>。使用双重检查锁定实现的懒汉式单例类完整代码如下所示：</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> LazySingleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//第一重判断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//锁定代码块</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LazySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//第二重判断</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建单例实例</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需要注意的是</strong></p><blockquote><p>如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符<strong>volatile</strong>，被<strong>volatile</strong>修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。由于 volatile 关键字会屏蔽 Java 虚拟机所做的一些代码优化，可能会导致系统运行效率降低。因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p></blockquote><h3><span id="饿汉式单例类与懒汉式单例类比较">饿汉式单例类与懒汉式单例类比较</span></h3><p><strong>饿汉式单例类在类被加载时就将自己实例化，</strong></p><p>优点：</p><ol><li><p>无须考虑多线程访问问题，可以确保实例的唯一性；</p></li><li><p>从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。</p></li></ol><p>缺点：</p><ol><li>但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</li></ol><p><strong>懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载</strong></p><p>优点：</p><ol><li>无须一直占用系统资源，实现了延迟加载。</li></ol><p>缺点：</p><ol><li>但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</li></ol><h2><span id="以上总结">以上总结</span></h2><p>饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；</p><p>懒汉式单例类线程安全控制烦琐，而且性能受影响。</p><p>可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题,有没有更好的方式？</p><h3><span id="静态内部类">静态内部类</span></h3><blockquote><p>Initialization Demand Holder (IoDH)</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HolderClass</span> <span class="token punctuation">{</span>            <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> HolderClass<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Singleton s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>             s1 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s2 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://brokge.github.io/2020/01/08/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://brokge.github.io/2020/01/08/原型模式/</id>
    <published>2020-01-08T06:29:19.000Z</published>
    <updated>2020-06-05T13:28:18.737Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a><ul><li><a href="#1-%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1. 通用实现方法：</a></li><li><a href="#2-java-%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E7%9A%84-clone-%E6%96%B9%E6%B3%95">2. Java 语言提供的 clone 方法</a></li></ul></li><li><a href="#%E6%B5%85%E5%85%8B%E9%9A%86%E6%B7%B1%E5%85%8B%E9%9A%86">浅克隆、深克隆</a><ul><li><a href="#1-%E6%B5%85%E5%85%8B%E9%9A%86">1. 浅克隆</a></li><li><a href="#2-%E6%B7%B1%E5%85%8B%E9%9A%86">2. 深克隆</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结：</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="概念">概念</span></h2><p><strong>原型模式(Prototype  Pattern)：</strong> 使用原型实例指定创建对象的种类，并且通过克隆拷贝的方式利用原型实例创建新的对象。原型模式是一种对象创建型模式。</p><p>通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p><h2><span id="实现方式">实现方式</span></h2><h3><span id="1-通用实现方法">1. 通用实现方法：</span></h3><p>定义 Prototype 接口 和 clone() 方法。<br>原型对象继承其接口，实现clone 方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Prototype</span><span class="token punctuation">{</span>   Prototype  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">implements</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span><span class="token keyword">private</span> String  attr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//成员属性</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAttr</span><span class="token punctuation">(</span>String attr<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>attr <span class="token operator">=</span> attr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> String <span class="token function">getAttr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>attr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//克隆方法</span><span class="token keyword">public</span> Prototype <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//创建新对象</span>    Prototype prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     prototype<span class="token punctuation">.</span><span class="token function">setAttr</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> prototype<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方通过下列方法，获得原型实例并得到克隆对象。 </p><pre class="line-numbers language-java"><code class="language-java">Prototype obj1  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span><span class="token function">setAttr</span><span class="token punctuation">(</span><span class="token string">"Sunny"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Prototype obj2  <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="2-java-语言提供的-clone-方法">2. Java 语言提供的 clone 方法</span></h3><p>Java类都继承自java.lang.Object。事实上，Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。我们可以直接利用Object类的clone()方法，具体步骤如下：</p><ol><li>在派生类中覆盖基类的clone()方法，并声明为public；</li><li>在派生类的clone()方法中，调用super.clone()；</li><li>派生类需实现Cloneable接口。</li></ol><p>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</p><p>需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">implements</span>  <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> Prototype  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    　　Object object <span class="token operator">=</span> null<span class="token punctuation">;</span>    　　<span class="token keyword">try</span> <span class="token punctuation">{</span>    　　　　　object <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    　　<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>    　　　　　System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Not support cloneable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    　　<span class="token punctuation">}</span>    　　<span class="token keyword">return</span> <span class="token punctuation">(</span>Prototype <span class="token punctuation">)</span>object<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用方：</p><pre class="line-numbers language-java"><code class="language-java">Prototype obj1  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Prototype obj2  <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Java 语言中的clone()方法满足：</p><p>(1) 对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</p><p>(2) 对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</p><p>(3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p><h2><span id="浅克隆-深克隆">浅克隆、深克隆</span></h2><p>通过 Java 的clone 方式可以实现原型模式，但是通过深克隆实现还是浅克隆实现，所达到的结果是不一样的。因为在Java语言中，<strong>数据类型</strong>分为<strong>值类型</strong>（基本数据类型）和<strong>引用类型</strong>，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。</p><h3><span id="1-浅克隆">1. 浅克隆</span></h3><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p><p>简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/java%20%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86-%E6%B5%85.png" alt="浅克隆"></p><h3><span id="2-深克隆">2. 深克隆</span></h3><p>深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。</p><p>简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制</p><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/java%20%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86.png" alt="深克隆"></p><ol><li>实现深克隆方法：序列化(Serialization)</li></ol><blockquote><p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">WeeklyLog</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Attachment attachment<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String date<span class="token punctuation">;</span>    <span class="token keyword">private</span> String content<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAttachment</span><span class="token punctuation">(</span>Attachment attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>attachment  <span class="token operator">=</span> attachment<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDate</span><span class="token punctuation">(</span>String date<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> date<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContent</span><span class="token punctuation">(</span>String content<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Attachment <span class="token function">getAttachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>attachment<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span><span class="token punctuation">(</span>String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//使用序列化技术实现深克隆</span>    <span class="token keyword">public</span> WeeklyLog <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> OptionalDataException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将对象写入流中</span>        ByteArrayOutputStream bao<span class="token operator">=</span><span class="token keyword">new</span>  <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectOutputStream oos<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bao<span class="token punctuation">)</span><span class="token punctuation">;</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//将对象从流中取出</span>        ByteArrayInputStream bis<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bao<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectInputStream ois<span class="token operator">=</span><span class="token keyword">new</span>  <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>WeeklyLog<span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="总结">总结：</span></h2><ul><li>原型模式的主要优点如下：</li></ul><p>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p><p>(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p><p>(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p><p>(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p><ul><li>原型模式的主要缺点如下：</li></ul><p>(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p><p>(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p><ul><li>在以下情况下可以考虑使用原型模式：</li></ul><p>(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</p><p>(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</p><p>(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>批量添加Java文件头部注释</title>
    <link href="https://brokge.github.io/2020/01/08/%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0Java%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E6%B3%A8%E9%87%8A/"/>
    <id>https://brokge.github.io/2020/01/08/批量添加Java文件头部注释/</id>
    <published>2020-01-08T03:45:00.000Z</published>
    <updated>2020-06-05T13:27:55.393Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82">环境要求</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li><li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li><li><a href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%B3%A8%E9%87%8A%E6%AE%8B%E7%BC%BA%E7%B1%BB%E5%9E%8B">支持的注释残缺类型</a></li><li><a href="#addannotationpy-%E4%BB%A3%E7%A0%81">addAnnotation.py 代码</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="背景">背景</span></h2><p>在一般情况下，作为 Java 开发，如果事先在 Idea 或者 Eclipse中配置模版。在创建一个新类时，会自动生成 头部注释信息，比如下面这种。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * * @author name * @since xxxx-xx-xx */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有在 Idea 或 Eclipse 配置模版，需要手动插入。文件少还好，文件多的话那就mmp了。特别是历史遗留问题，有很多类文件没有加头部注释且编译时又做了代码检查，领导又让你加的时候。<br>事实上本人就碰到了这个问题，大概两三百个文件。</p><p>如果你属于上面的情况，那恭喜你。</p><h2><span id="环境要求">环境要求</span></h2><blockquote><p>python3</p></blockquote><h2><span id="使用方法">使用方法</span></h2><ol><li><p>拷贝py脚本到对应文件</p></li><li><p>执行以下命令</p></li></ol><pre class="line-numbers language-bash"><code class="language-bash"> python3 addAnnotation.py <span class="token variable">${authornName}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如：<code>python3 addAnnotation.py brokge</code><br>${authornName}  默认值为 <code>yusuzi</code> </p></blockquote><h2><span id="说明">说明</span></h2><blockquote><p>只处理脚本所在目录以下目录和文件 且后缀为 <code>.java</code> 文件 文件<br>如果存在 <code>@author</code> 或 <code>Created by xxx</code> 不处理</p></blockquote><h2><span id="支持的注释残缺类型">支持的注释残缺类型</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aa</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@xxxx</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aa</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 这是个测试类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aa</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="addannotationpy-代码">addAnnotation.py 代码</span></h2><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!usr/bin/python3</span><span class="token comment" spellcheck="true"># -*- coding:UTF-8 -*-</span><span class="token keyword">import</span> pickle<span class="token keyword">import</span> pprint<span class="token keyword">import</span> re<span class="token keyword">import</span> time<span class="token keyword">import</span> os<span class="token punctuation">,</span>sys<span class="token comment" spellcheck="true">#from dateutil.parser import parse</span><span class="token triple-quoted-string string">'''使用方法：  python3 addAnnotation.py ${authornName}  ${authornName}  有默认值'''</span><span class="token keyword">def</span> <span class="token function">eachFile</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> _authorName<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#print(path)</span>    <span class="token comment" spellcheck="true">#authorName = _authorName</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"authorName:"</span><span class="token operator">+</span> authorName<span class="token punctuation">)</span>    files <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span>    <span class="token keyword">for</span> _file <span class="token keyword">in</span> files<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#判断是否为文件夹</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token string">'/'</span><span class="token operator">+</span>_file<span class="token punctuation">)</span> <span class="token operator">and</span> _file<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'.java'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            matchAndReplace<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token string">'/'</span><span class="token operator">+</span>_file<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>_file<span class="token punctuation">)</span>        <span class="token keyword">elif</span>  os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token string">'/'</span><span class="token operator">+</span>_file<span class="token punctuation">)</span><span class="token punctuation">:</span>            eachFile<span class="token punctuation">(</span>path<span class="token operator">+</span><span class="token string">'/'</span><span class="token operator">+</span>_file<span class="token punctuation">,</span> authorName<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">matchAndReplace</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">:</span>    fo <span class="token operator">=</span> open<span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token string">"r+"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#content = fo.read()</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"#正在处理文件名:"</span><span class="token punctuation">,</span>fo<span class="token punctuation">.</span>name<span class="token punctuation">)</span>    lines <span class="token operator">=</span> fo<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> checkIsExist<span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">" 已经存在注释"</span><span class="token punctuation">,</span>fo<span class="token punctuation">.</span>name<span class="token punctuation">)</span>        <span class="token keyword">return</span>    isOnlyAuthor <span class="token operator">=</span> checkInsertPosition<span class="token punctuation">(</span>lines<span class="token punctuation">)</span>    position <span class="token operator">=</span> getInsertPosition<span class="token punctuation">(</span>lines<span class="token punctuation">)</span>    <span class="token keyword">if</span> position <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'插入行:%d'</span><span class="token operator">%</span>position<span class="token punctuation">)</span>    templateStr <span class="token operator">=</span> getTemplate<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>isOnlyAuthor<span class="token punctuation">)</span>    lines<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>position<span class="token number">-1</span><span class="token punctuation">,</span>templateStr<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#content = content[:position+1]+ templateStr + content[position+1:]</span>    <span class="token comment" spellcheck="true">#content = templateStr</span>    content <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>lines<span class="token punctuation">)</span>    fo<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    writeFile<span class="token punctuation">(</span>content<span class="token punctuation">,</span>file<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">writeFile</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span>file<span class="token punctuation">)</span><span class="token punctuation">:</span>    fo <span class="token operator">=</span> open<span class="token punctuation">(</span>file<span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">)</span>    fo<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>content<span class="token punctuation">)</span>    fo<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">checkInsertPosition</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>    isOnlyAuthor <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token comment" spellcheck="true">#lines = fo.readlines()</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">:</span>        <span class="token keyword">if</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">' */'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            isOnlyAuthor <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">break</span>     <span class="token keyword">return</span> isOnlyAuthor<span class="token keyword">def</span> <span class="token function">getInsertPosition</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>    positionTemp <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">#lines = fo.readlines()</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">:</span>        positionTemp <span class="token operator">=</span> positionTemp<span class="token operator">+</span><span class="token number">1</span>        <span class="token keyword">if</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">' */'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>         <span class="token keyword">elif</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'@'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>         <span class="token keyword">elif</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'public class'</span><span class="token punctuation">)</span> <span class="token operator">or</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'public interface'</span><span class="token punctuation">)</span> <span class="token operator">or</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'public enum'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    <span class="token keyword">return</span> positionTemp<span class="token keyword">def</span> <span class="token function">getInsertPosition1</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    class_method <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>r<span class="token string">'(?&lt;=public class=)\w+(?=)'</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span>    classPosition <span class="token operator">=</span> class_method<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    atPosition <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token punctuation">)</span>    position <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">if</span> classPosition <span class="token operator">></span> atPosition<span class="token punctuation">:</span>        position <span class="token operator">=</span> atPosition    <span class="token keyword">return</span> position <span class="token keyword">def</span> <span class="token function">checkIsExist</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>    isExist <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> lines<span class="token punctuation">:</span>        result <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>r<span class="token string">'^\s+\* @author \w+|^\s+\* Created by \w+'</span><span class="token punctuation">,</span>line<span class="token punctuation">)</span>        <span class="token keyword">if</span> result <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            isExist <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">break</span>    <span class="token keyword">return</span> isExist<span class="token triple-quoted-string string">''' /** * * @author yusuzi * @since  */'''</span><span class="token keyword">def</span> <span class="token function">getTemplate</span><span class="token punctuation">(</span>defValue<span class="token punctuation">,</span> isOnlyAuthor<span class="token punctuation">)</span><span class="token punctuation">:</span>    templateStr <span class="token operator">=</span> <span class="token string">''</span>    <span class="token keyword">if</span> <span class="token operator">not</span> isOnlyAuthor<span class="token punctuation">:</span>        templateStr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'/**'</span><span class="token operator">+</span>        <span class="token string">'\n *'</span><span class="token operator">+</span> defValue<span class="token operator">+</span>        <span class="token string">'\n * @author '</span><span class="token operator">+</span>authorName<span class="token operator">+</span>        <span class="token string">'\n * @since '</span><span class="token operator">+</span> getCurrentDateTime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>        <span class="token string">'\n */\n'</span>        <span class="token punctuation">)</span>     <span class="token keyword">else</span> <span class="token punctuation">:</span>        templateStr <span class="token operator">=</span> <span class="token punctuation">(</span>            <span class="token string">' * @author '</span><span class="token operator">+</span>authorName<span class="token operator">+</span>            <span class="token string">'\n'</span><span class="token operator">+</span>            <span class="token string">' * @since '</span><span class="token operator">+</span> getCurrentDateTime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>            <span class="token string">'\n'</span>            <span class="token punctuation">)</span>    <span class="token keyword">return</span> templateStr    <span class="token keyword">def</span> <span class="token function">getCurrentDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#print(parse('2018-04-29T17:45:25Z'))</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%Y-%m-%d %H:%M:%S"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%Y-%m-%d %H:%M:%S"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    path <span class="token operator">=</span> sys<span class="token punctuation">.</span>path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    authorName <span class="token operator">=</span> <span class="token string">'yusuzi'</span>    <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">:</span>        authorName <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    eachFile<span class="token punctuation">(</span>path<span class="token punctuation">,</span> authorName<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 核心原理详解</title>
    <link href="https://brokge.github.io/2019/12/05/Zookeeper-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>https://brokge.github.io/2019/12/05/Zookeeper-原理解析/</id>
    <published>2019-12-05T12:52:10.000Z</published>
    <updated>2020-06-05T13:27:09.302Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80zookeeper-%E7%AE%80%E4%BB%8B">一、Zookeeper 简介</a><ul><li><a href="#zk-%E7%9A%84%E4%B8%80%E7%89%B9%E6%80%A7">ZK 的一特性</a></li></ul></li><li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">二、数据模型</a><ul><li><a href="#%E5%9B%9B%E7%A7%8D%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B">四种节点类型</a></li></ul></li><li><a href="#%E4%B8%89-watcher-%E6%9C%BA%E5%88%B6">三、 Watcher 机制</a><ul><li><a href="#watcher%E7%89%B9%E6%80%A7">Watcher特性</a></li></ul></li><li><a href="#%E5%9B%9B%E4%B8%80%E8%87%B4%E6%80%A7-%E5%8D%8F%E8%AE%AE">四、一致性 协议</a><ul><li><a href="#zab-%E5%8D%8F%E8%AE%AE">ZAB 协议</a></li></ul></li><li><a href="#%E4%BA%94cap-%E5%8E%9F%E5%88%99">五、CAP 原则</a></li><li><a href="#%E5%85%AD%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6">六、选举机制</a><ul><li><a href="#%E4%B8%89%E7%B1%BB%E8%A7%92%E8%89%B2">三类角色</a></li><li><a href="#%E5%9B%9B%E4%B8%AA%E6%95%B0%E6%8D%AE">四个数据</a></li><li><a href="#%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81">四种状态</a></li></ul></li><li><a href="#%E4%B8%83%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">七、应用场景</a></li><li><a href="#%E5%85%AB%E5%BC%95%E7%94%A8">八、引用</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="一-zookeeper-简介">一、Zookeeper 简介</span></h2><p>Zookeeper 是一个开源的分布式应用程序协调服务器，是 Hadoop 的重要组件。<br>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务器，是 Google 的<br>Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供<strong>一致<br>性</strong>服务的软件，提供的功能包括：<strong>配置维护、域名服务、分布式同步、集群管理等</strong>。ZooKeeper<br>的目标就是封装复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><h3><span id="zk-的一特性">ZK 的一特性</span></h3><ul><li><strong>顺序一致性</strong><br>从同一客户端发起的多个事务请求（写操作请求），最终会严格按照发起顺序存储到 zk中。</li><li><strong>原子性</strong><br>所有的事务请求结果，在集群中所有 Server 上的应用情况是一致的，要么全部成功要么都不成功，不会出现部分成功，部分失败的情况。</li><li><strong>单一视图</strong><br>无论客户端连接集群中的任意服务器，其读取到的数据模型都是一致的。</li><li><strong>可靠性</strong><br>一旦某事务成功应用到zk ，则会一直保留下来，除非另一个事务将其修改。</li><li><strong>最终一致性</strong><br>zk 可以保证在一段较短的时间内，客户端最终一定能够从服务端读取到最新的数据。但不保证实时性。</li></ul><p>以上特性 则由 zab 协议保证，后面会说。</p><h2><span id="二-数据模型">二、数据模型</span></h2><p>Zookeeper 数据模型，是一个树状目录结构（类似于我们的文件系统），最小单位为 znode.</p><p><img src="http://note.youdao.com/yws/res/9807/72B20BCC72D64D039C85C9EBF221B2F4" alt="image"></p><p>Znode 对象包含多个属性字段，其对象结构如下。</p><p><img src="http://note.youdao.com/yws/res/9810/3E46C0319A5C4E169200641D4EF68D66" alt="image"><br><img src="http://note.youdao.com/yws/res/9817/1B62DE5CC5E24BC980B64BAAB939FD27" alt="image"></p><h3><span id="四种节点类型">四种节点类型</span></h3><p>2 大类、四种类型： 持久、临时、持久有序、临时有序</p><ol><li>PERSISTENT 持久类型，如果不手动删除 是一直存在的</li><li>PERSISTENT_SEQUENTIAL 持久有序</li><li>EPHEMERAL 临时 客户端 session 失效就会随着删除节点 没有子节点</li><li>EPHEMERAL_SEQUENTIAL 临时有序 自增</li></ol><p>注意：有序节点 在创建 znode 时设置顺序标识，znode 名称后会附加一个值<br>顺序号是一个单调递增的计数器，由父节点维护<br>在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺<br>序号推断事件的顺序</p><h2><span id="三-watcher-机制">三、 Watcher 机制</span></h2><p>Watcher实现由三个部分组成：</p><ol><li>Zookeeper服务端；</li><li>Zookeeper客户端（常用 Zkclient、Curator）；</li><li>客户端的ZKWatchManager对象；</li></ol><p><img src="http://note.youdao.com/yws/res/9913/07DC35A8DE9E439F96B82D9C6BE95C36" alt="image"><br>客户端首先将Watcher注册到服务端，同时将Watcher 对象保存到客户端的 Watch管理器中。当 ZooKeeper 服务端监听的数据状态发生变化时，服务端会主动通知客户端，接着客户端的Watch管理器会触发相关Watcher来回调相应处理逻辑，从而完成整体的数据发布/订阅流程。</p><h3><span id="watcher特性">Watcher特性</span></h3><ul><li>一次性：Watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册。</li><li>客户端顺序回调： Watcher回调是顺序串行化执行的，只有回调后客户端才能看到最新的数据状态。一个Watcher回调逻辑不应该太多，以免影响别的watcher执行</li><li>轻量级： WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容；</li><li>时效性：Watcher只有在当前session彻底失效时才会无效，若在 session 有效期内快速重连成功，则 watcher 依然存在，仍可接收到通知；</li></ul><h2><span id="四-一致性-协议">四、一致性 协议</span></h2><p>说起 一致性协议，则不得不说，Paxos 算法 。<br>常用一致性协议包含 Paxos / Raft / zab 等协议，而 Raft，zab 其实就是 Paxos 的变种。</p><p>Paxos 算法由图灵奖获得者 Leslie Lamport 于 1990 年提出的一种基于消息传递且具有高度容错的特性的一致性算法。Paxos的出现就是为了解决 一致性问题。 </p><p>Paxos 有三种角色 </p><ol><li>倡议者（Proposer）：倡议者可以提出提案（数值或者操作命令）以供投票表决</li><li>接受者（Acceptor）：接受者可以对倡议者提出的提议进行投票表决，提议有超半数的接受者投票即被选中。</li><li>学习者（Learner）：学习者无投票权，只是从接受者那里获知哪个提议被选中 。</li></ol><p>Paxos 算法明确提出： 一个或多个倡议者发出提案。 必须针对所有提案中的某个提案达成一致也就是（接受者）半数以上；最多只能对一个确定的提案达成一致。</p><p>只要超半数的节点存活且可互相通信，整个系统一定能达成一致状态。</p><p>详细可查看： <a href="https://blog.xiaohansong.com/Paxos.html" target="_blank" rel="noopener">一致性算法 Paxos</a></p><h3><span id="zab-协议">ZAB 协议</span></h3><p>Zookeeper 的核心是广播，这个机制保证了各个 zkServer 间数据的同步，即数据的一致<br>性。实现这个机制的协议叫做 ZAB 协议，即 Zookeeper Atomic Broadcast，Zookeeper 原子广播协议。</p><p>ZAB 协议有三种模式：恢复模式、同步模式 和 广播模式。</p><ul><li>恢复模式：在服务重启过程中，或在 Leader 崩溃后，就进入了恢复模式，要恢复到 zk<br>集群正常的工作状态。</li><li>同步模式：在所有的 zkServer 启动完毕，或 Leader 崩溃后又被选举出来时，就进入了同步模式，各个 Follower 需要马上将 Leader 中的数据同步到自己的主机中。当大多数<br>zkServer 完成了与 Leader 的状态同步以后，恢复模式就结束了。所以，同步模式包含在恢复模式过程中。</li><li>广播模式：当 Leader 的提议被大多数 zkServer 同意后，Leader 会修改自身数据，然后会将修改后的数据广播给其它 Follower。</li></ul><p><img src="http://note.youdao.com/yws/res/9857/668AE0E49ED84CAE89DC441022551BA0" alt="image"></p><h2><span id="五-cap-原则">五、CAP 原则</span></h2><p><img src="http://note.youdao.com/yws/res/9840/3AA3192A598B4B11AEDD922A59D764D7" alt="image"></p><p>分布式领域 CAP 理论</p><ol><li>Consistency(一致性), 数据一致更新，所有数据变动都是同步的</li><li>Availability(可用性), 好的响应性能</li><li>Partition tolerance(分区容忍性) 可靠性</li></ol><p>定理：任何分布式系统只可同时满足二点，没法三者兼顾。</p><p>zookeeper是需要提供强一致性的服务，但是在zk集群中如果leader宕机，会进入leader选举过程，而在这个过程中zk不对外提供服务的，这会造成注册服务短时不可用。所以在分区容错性和数据一致性上得到保证的前提下，对 Availability(可用性) 做了折中。 <strong>所以 ZooKeeper 是个 CP 的，即任何时刻对 ZooKeeper 的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性</strong>。也就是在极端环境下，ZooKeeper 可能会丢弃一些请求，消费者程序需要重新请求才能获得结果</p><h2><span id="六-选举机制">六、选举机制</span></h2><h3><span id="三类角色">三类角色</span></h3><p>为了避免 Zookeeper 的单点问题，zk 也是以集群的形式出现的。zk 集群中的角色主要有<br>以下三类：</p><ul><li>Leader：zk 集群写请求的唯一处理者，并负责进行投票的发起和决议，更新系统状态。<br>Leader 是很民主的，并不是说其在接收到写请求后马上就修改其中保存的数据，而是首<br>先根据写请求提出一个提议，在大多数 zkServer 均同意时才会做出修改。</li><li>Follower：接收客户端请求，处理读请求，并向客户端返回结果；将写请求转给 Leader；<br>在选主(选 Leader)过程中参与投票。 </li><li>Observer：可以理解为无选主投票权的 Flollower，其主要是为了协助 Follower 处理更多<br>的读请求。如果 Zookeeper 集群的读请求负载很高，或者客户端非常非常多，多到跨机房，则可以设置一些 Observer 服务器，以提高读取的吞吐量。</li></ul><h3><span id="四个数据">四个数据</span></h3><ol><li>myid <blockquote><p>这是 zk 集群中服务器的唯一标识，称为 myid。例如，有三个 zk 服务器，那么编号分别<br>是 1,2,3。</p></blockquote></li><li>zxid<blockquote><p>zxid 为 Long 类型，其中高 32 位表示 epoch，低 32 位表示 xid。即 zxid 由两部分构成：<br>epoch 与 xid。<br>每个 Leader 都会具有一个不同的 epoch 值，表示一个时期、时代。新的 Leader 产生，<br>则会更新所有 zkServer 的 zxid 中的 epoch。 </p></blockquote></li><li>xid <blockquote><p>则为 zk 的事务id，只会增加，每一个写操作都是一个事务，都会有一个 xid。每一个写操作<br>都需要由 Leader 发起一个提议，由所有 Follower 表决是否同意本次写操作。</p></blockquote></li><li>逻辑时钟<blockquote><p>逻辑时钟，Logicalclock，是一个整型数，该概念在选举时称为 logicalclock，而在 zxid 中<br>则为 epoch 的值。即 epoch 与 logicalclock 是同一个值，在不同情况下的不同名称。</p></blockquote></li></ol><h3><span id="四种状态">四种状态</span></h3><p>根据不同角色和进行中的流程，每个服务器存在不同的状态，包括以下 4 中。</p><ol><li>LOOKING，选举状态(查找 Leader 的状态)。 </li><li>FOLLOWING，随从状态，同步 leader 状态。处于该状态的服务器称为 Follower。 </li><li>OBSERVING，观察状态，同步 leader 状态。处于该状态的服务器称为 Observer。 </li><li>LEADING，领导者状态。处于该状态的服务器称为 Leader。</li></ol><h2><span id="七-应用场景">七、应用场景</span></h2><ul><li>分布式配置中心</li><li>分布式锁</li><li>服务注册中心</li><li>分布式通知</li></ul><h2><span id="八-引用">八、引用</span></h2><p><a href="https://blog.xiaohansong.com/Paxos.html" target="_blank" rel="noopener">图解 Paxos 一致性协议</a></p><p><a href="https://www.jianshu.com/p/703f4eb40e92" target="_blank" rel="noopener">zooKeeper中的CAP模型以及它作为服务发现的缺点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="https://brokge.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://brokge.github.io/2019/09/23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://brokge.github.io/2019/09/23/责任链模式/</id>
    <published>2019-09-23T07:37:35.000Z</published>
    <updated>2020-06-05T13:21:55.855Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%9B%BE">结构图</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a><ul><li><a href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%E5%A6%82%E4%B8%8B">职责链模式的主要优点如下：</a></li><li><a href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9%E5%A6%82%E4%B8%8B">职责链模式的主要缺点如下：</a></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="概念">概念</span></h2><p>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><h2><span id="结构图">结构图</span></h2><p>责任链模式实现方式，有两种：集合形式、链表形式</p><p><img src="https://raw.githubusercontent.com/brokge/drawio/master/img/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="责任链模式-2019-9-23-14-53-40.png"></p><p><strong>Handler（抽象处理者）：</strong>  它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的 nextHandler），作为其对下家的引用。通过该引用，处理者可以连成一条链。</p><p><strong>ConcreteHandler（具体处理者）：</strong><br>它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p><h2><span id="示例代码">示例代码</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//维持对下家的引用</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler<span class="token operator">=</span>successor<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 具体处理者是抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>请求满足条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//处理请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//转发请求</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">HandlerProcessor</span><span class="token punctuation">{</span>    protect List<span class="token operator">&lt;</span>Handler<span class="token operator">></span> handlerList<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addHandler</span><span class="token punctuation">(</span>Handler handler<span class="token punctuation">)</span><span class="token punctuation">{</span>        handlerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Handler handler<span class="token operator">:</span>handlerList<span class="token punctuation">)</span><span class="token punctuation">{</span>            handler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。 </p><p>链表形式执行：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Handler a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>集合形式执行：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Handler a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HandlerProcessor handleProcessor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HandlerProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">processHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="小结">小结</span></h2><h3><span id="职责链模式的主要优点如下">职责链模式的主要优点如下：</span></h3><p>(1) 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。</p><p>(2) 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</p><p>(3) 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</p><p>(4) 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。</p><h3><span id="职责链模式的主要缺点如下">职责链模式的主要缺点如下：</span></h3><p>(1) 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。</p><p>(2) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</p><p>(3) 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</p><h3><span id="适用场景">适用场景</span></h3><p>在以下情况下可以考虑使用职责链模式：</p><p>(1) 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</p><p>(2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p><p>(3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>冰山模型</title>
    <link href="https://brokge.github.io/2019/09/17/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B/"/>
    <id>https://brokge.github.io/2019/09/17/冰山模型/</id>
    <published>2019-09-17T08:23:06.000Z</published>
    <updated>2020-06-05T13:21:55.812Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><p><a href="#%E4%B8%80%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B">一、冰山模型</a></p></li><li><p><a href="#%E4%B8%80%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B">一、冰山模型</a></p><ul><li><a href="#%E7%9F%A5%E8%AF%86%E5%92%8C%E6%8A%80%E8%83%BD">知识和技能</a></li><li><a href="#%E8%83%BD%E5%8A%9B">能力</a></li><li><a href="#%E4%BB%B7%E5%80%BC%E8%A7%82%E6%80%A7%E6%A0%BC%E5%8A%A8%E6%9C%BA">价值观、性格、动机</a></li></ul></li><li><a href="#%E4%BA%8C%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B%E7%A1%AE%E5%AE%9A%E8%81%8C%E4%BD%8D">二、如何根据冰山模型确定职位</a></li><li><a href="#%E4%B8%89%E6%8A%95%E5%85%A5%E5%9B%A0%E7%B4%A0%E7%9A%84%E4%B8%8D%E5%90%8C">三、投入因素的不同</a></li><li><a href="#%E5%9B%9B%E5%A4%A9%E8%B5%8B%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%A1%A8%E7%8E%B0-sign">四、天赋的四个表现 SIGN</a></li><li><a href="#%E4%BA%94%E4%B8%89%E4%B8%AA%E7%9F%A5%E8%AF%86%E5%86%85%E5%8C%96%E6%88%90%E8%83%BD%E5%8A%9B%E7%9A%84%E6%96%B9%E6%B3%95">五、三个知识内化成能力的方法</a></li><li><a href="#%E5%85%AD%E4%B8%89%E5%A4%A7%E7%B3%BB%E7%BB%9F-%E8%AE%A9%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%8D%E4%BE%9D%E9%9D%A0%E6%84%8F%E5%BF%97%E5%8A%9B">六、三大系统 让系统化学习不依靠意志力</a></li><li><a href="#%E4%B8%83%E5%AD%A6%E4%B9%A0%E4%B8%8D%E9%9D%A0%E6%84%8F%E5%BF%97%E5%8A%9B%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0">七、学习不靠意志力三个关键因素</a></li><li><a href="#%E5%85%AB%E4%B8%89%E4%B8%AA%E5%BB%BA%E8%AE%AE%E8%AE%A9%E4%BD%A0%E4%B8%8D%E5%81%9A%E5%AE%9A%E5%88%B6%E5%8C%96%E4%BA%BA%E6%89%8D">八、三个建议让你不做「定制化人才」</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>[toc]</p><h2><span id="一-冰山模型">一、冰山模型</span></h2><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B.png" alt="冰山模型"></p><blockquote><p>动机可能就是天赋本身</p></blockquote><h3><span id="知识和技能">知识和技能</span></h3><p>………</p><h3><span id="能力">能力</span></h3><p>知识技能属于特定领域，能力则是通用可迁移的。如果：沟通能力、学习能力、思考能力、交往能力。</p><h3><span id="价值观-性格-动机">价值观、性格、动机</span></h3><p>受基因、家庭教育、童年经历有关。后续改变相对较难。所以后续选择职业、婚姻或者其他的时候，最重要的是匹配，而不是强制改变。</p><blockquote><p>工作跟伴侣是一样的，「匹配」比「优秀」更重要。</p></blockquote><p>感觉一份工作不喜欢，有可能是：</p><ol><li>缺乏知识技能，导致的慌乱和焦虑。</li><li>缺乏能力导致的挫败和低效。</li><li>价值观不匹配导致的矛盾和纠结。</li><li>动机不匹配导致的没热情。</li><li>性格不匹配导致的心累。</li></ol><h2><span id="二-如何根据冰山模型确定职位">二、如何根据冰山模型确定职位</span></h2><p>一. 确定要分析的岗位。</p><p>二. 根据招聘网站搜索这个岗位的招聘要求。</p><p>三. 按照冰山模型，综合分析招聘要求。</p><p>四. 按照岗位需求模型与自己进行对比。</p><blockquote><p>搞明白 「我应该选择什么养的工作」比「我应该如何在别人认为的好工作里面成功」更重要的多。</p><p>想要让自己获得成就感，就不应该把它绑在别人的记分牌上。</p><p>查理芒格在「穷查理宝典」中提到：掌握一定量的思维模型，能解决这世上90%的问题。</p></blockquote><h2><span id="三-投入因素的不同">三、投入因素的不同</span></h2><p>整个冰山模型越往下的要素，越难培养。越难发现。投入不同要素上，会有什么结果。</p><ol><li><p>首先知识<br>单纯的知识储备，如果不能结合思维能力解决一些问题，很难有市场价值提升。</p></li><li><p>技能<br>门槛高，不代表天花板也高，毕竟没人想要一直拿一个工作的门槛工资。</p></li><li><p>能力<br>门槛不高，不代表天花板也不高。能力提升可以跨行业、职业。一旦积累到一定高度。哪怕行业不行，换个行业一样可以值钱。</p></li><li><p>自我发现<br>人们总是倾向于做容易的事，而不是正确的事。</p></li></ol><blockquote><p>你选的不是一份工作，而是天花板。<br>任何工作都是在解决问题，一家公司也是在解决某类用户的问题。</p></blockquote><blockquote><p><strong>我们的时间永远应该花在正确的事情上，而不是容易的事情上。</strong></p></blockquote><blockquote><p>虽然 成功的道路有千万条，但成功人士基本上都遵循了一个原则，就是将自身天赋发挥到极致。</p><p>天赋并不是少数人的专属，每个人都有自己的天赋。</p><p>天赋不是达到一定成绩后，才发挥作用的东西，而是一个在起点就发挥作用的因素。</p></blockquote><h2><span id="四-天赋的四个表现-sign">四、天赋的四个表现 SIGN</span></h2><ol><li>自我效能 （self-efficacy）-对某件事特别有信心，觉得自己可以成功。</li><li>本能（Insict）- 让你迫不及待、跃跃欲试的事情。可能意味着天赋所在。</li><li>成长（Growth）- 在某一领域，你一接触就比别人进步更快一些。</li><li>满足（Needs）- 做完这件事后，就算感到疲倦，依然会有满足感。</li></ol><h2><span id="五-三个知识内化成能力的方法">五、三个知识内化成能力的方法</span></h2><ol><li>掌握 20% 核心- 一个领域 20% 核心内容，能解决80% 的问题。</li><li>知识和问题相互靠- 学一门知识的时候，要知道能解决什么问题。</li><li>做系统化训练-行为和思维的改变至少需要1个月。</li></ol><blockquote><p>我们习惯高估几天的变化，而低估几个月的变化。</p><p>大脑不单单是用来记忆的，还是用来思考的。</p></blockquote><p>20% 核心举例子：</p><blockquote><p>结构化思维：主题鲜明、归类分组、逻辑递进。<br>ppt逼格：填充色半透明、边框细、行间距1.5。 </p></blockquote><h2><span id="六-三大系统-让系统化学习不依靠意志力">六、三大系统 让系统化学习不依靠意志力</span></h2><blockquote><p>人的意志力是有限的额，任何让自己坚持的事情，都会消耗它。</p><p>当你坚持学习的时候，不是「学些」这件事拖累了你，而是「坚持」这件事累着你了。</p><p>人们醒着的时候，大约 1/4 的时间用来抵制欲望。</p><p>如果可以用环境，就不要用你的意志力来抵制欲望。</p></blockquote><h2><span id="七-学习不靠意志力三个关键因素">七、学习不靠意志力三个关键因素</span></h2><ol><li><p>理性上知道要学习</p></li><li><p>情感上愿意去学习啊。</p></li><li><p>情景上制造适合学习的场景。</p></li></ol><p>发挥理性作用：树立明确目标。</p><p>发挥感性作用：利用情绪冲动。</p><p>发挥情景作用：创造学习环境</p><h2><span id="八-三个建议让你不做定制化人才">八、三个建议让你不做「定制化人才」</span></h2><ol><li>调整主题，给自己定好发展空间。</li><li>提升能力，让自己成为横向可迁移的人才。</li><li>提升认知高度，让自己成为纵向可深挖的人才。</li></ol><blockquote><p>社会发展到今天，你所遇到的几乎每个问题，这个世界上都有人曾经解决过它。我们要做的就是学习和发现这个答案。</p><p>教育是让一个人成为最好版本的自己—-马斯洛</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="思维模型" scheme="https://brokge.github.io/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂</title>
    <link href="https://brokge.github.io/2019/09/06/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
    <id>https://brokge.github.io/2019/09/06/简单工厂/</id>
    <published>2019-09-06T08:23:55.000Z</published>
    <updated>2020-06-05T13:21:55.832Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82">简单工厂</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E7%89%B9%E7%82%B9">特点</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码：</a></li><li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">简单工厂模式总结</a><ul><li><a href="#%E4%BC%98%E7%82%B9"><strong>优点</strong></a></li><li><a href="#%E7%BC%BA%E7%82%B9"><strong>缺点</strong></a></li></ul></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>适用场景</strong></a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>[toc]</p><h1><span id="简单工厂">简单工厂</span></h1><h2><span id="概念">概念</span></h2><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><h2><span id="特点">特点</span></h2><p>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。<br>达到 <strong>创建和使用分离</strong>。</p><h2><span id="示例代码">示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象图表接口：抽象产品类</span><span class="token keyword">interface</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//柱状图类：具体产品类</span><span class="token keyword">class</span> <span class="token class-name">HistogramChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">HistogramChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//饼状图类：具体产品类</span><span class="token keyword">class</span> <span class="token class-name">PieChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">PieChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//折线图类：具体产品类</span><span class="token keyword">class</span> <span class="token class-name">LineChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">LineChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//图表工厂类：工厂类</span><span class="token keyword">class</span> <span class="token class-name">ChartFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//静态工厂方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Chart <span class="token function">getChart</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Chart chart <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"histogram"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HistogramChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PieChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"line"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LineChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token keyword">return</span> chart<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="简单工厂模式总结">简单工厂模式总结</span></h2><p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。</p><h3><span id="优点"><strong>优点</strong></span></h3><p> 简单工厂模式的主要优点如下：</p><blockquote><p>(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p><p>(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p><p>(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p></blockquote><h3><span id="缺点"><strong>缺点</strong></span></h3><p>简单工厂模式的主要缺点如下：</p><blockquote><p>(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p><p>(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p><p>(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p><p>(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p></blockquote><h2><span id="适用场景"><strong>适用场景</strong></span></h2><p>在以下情况下可以考虑使用简单工厂模式：</p><blockquote><p>(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p><p>(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="https://brokge.github.io/2019/09/06/%E6%B3%A8%E8%A7%A3/"/>
    <id>https://brokge.github.io/2019/09/06/注解/</id>
    <published>2019-09-06T08:22:07.000Z</published>
    <updated>2020-06-05T13:21:55.830Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80-%E6%B3%A8%E8%A7%A3%E5%88%86%E7%B1%BB">一 、注解分类</a><ul><li><a href="#1--java-%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3">1.  <strong>Java 内置注解</strong></a></li><li><a href="#2-%E6%A0%87%E6%B3%A8%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3">2. <strong>标注注解的元注解</strong></a></li></ul></li><li><a href="#%E4%BA%8C-%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89">二、 注解定义</a></li><li><a href="#%E4%B8%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8F%90%E5%8F%96">三、注解的提取</a></li><li><a href="#%E5%9B%9B%E5%85%B6%E4%BB%96">四、其他</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。</p><h2><span id="一-注解分类">一 、注解分类</span></h2><h4><span id="1-java-内置注解">1.  <strong>Java 内置注解</strong></span></h4><p> @Override、 @Deprecated、@SuppressWarnings、@SafeVarargs(jdk 7 新增)</p><h4><span id="2-标注注解的元注解">2. <strong>标注注解的元注解</strong></span></h4><p>元注解是用来修饰注解的注解，从而创建新的注解。</p><p><strong>@Targe</strong> </p><p>注解取值是一个 ElementType 类型的数组。<br>说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目的。</p><table><thead><tr><th>ElementType</th><th>说明</th></tr></thead><tbody><tr><td>- ElementType.TYPE</td><td>修饰类、接口或枚举类型。</td></tr><tr><td>- ElementType.FIELD</td><td>修饰成员变量。</td></tr><tr><td>- ElementType.METHOD</td><td>修饰方法。</td></tr><tr><td>- ElementType.PARAMETER</td><td>修饰参数。</td></tr><tr><td>- ElementType.CONSTRUCTOR</td><td>修饰构造方法。</td></tr><tr><td>- ElementType.LOCAL_VARIABLE</td><td>修饰局部变量。</td></tr><tr><td>- ElementType.ANNOTATION_TYPE</td><td>修饰注解。</td></tr><tr><td>- ElementType.PACKAGE</td><td>修饰包。</td></tr><tr><td>- ElementType.TYPE_PARAMETER</td><td>修饰参数声明。</td></tr><tr><td>- ElementType.TYPE_USR</td><td>使用类型。</td></tr></tbody></table><p><strong>@Retention</strong> </p><p>3种类型，分别表示不同的保留周期<br>定义了该Annotation被保留的时间长短，SOURCE、CLASS、RUNTIME（可通过反射获取内部属性）。</p><ol><li><strong>RetentionPolicy.SOURCE</strong>:源码级注解。<blockquote><p>注解信息只会保留在.java 源码中，源码在编译后，注解信息会被丢弃，不会保留到.class 中。</p></blockquote></li><li><strong>RetentionPolicy.CLASS</strong>:编译时注解。<blockquote><p>注解信息会保留在.java 源码以及.class 中。当运行java 程序时，JVM 会丢弃该注解信息，不会保留到 JVM 中。</p></blockquote></li><li><strong>RetentionPolicy.RUNTIME</strong>:运行时注解。<blockquote><p>当运行 java 程序时，JVM 也会保留该注解信息，可以通过反射获取该注解信息。</p></blockquote></li></ol><p><strong>@Documented</strong> </p><p>标记注解，可以工具文档化。</p><p><strong>@Inherited</strong> </p><p>当前注解是否可以继承。</p><p><strong>@Repeatable</strong></p><p>JDK 8 新增，允许一个注解在同一声明类型（类、属性或方法）上多次使用。</p><h2><span id="二-注解定义">二、 注解定义</span></h2><ol><li>基本定义</li></ol><p>定义新的注解类型使用 @interface 关键字。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>程序中使用该注解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Cup</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>定义成员变量(注解的属性)</li></ol><p>注解 只有成员变量，没有方法。注解的成员变量在注解定义中以“无形参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型；</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个成员变量以方法的形式来定义。使用该注解时候就应该为该成员变量赋值</p><pre class="line-numbers language-java"><code class="language-java">pubilc <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Cup</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"马克杯"</span><span class="token punctuation">,</span>price<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以在定义注解的时候通过 default 来指定默认值：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>   String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>定义运行时注解</li></ol><p>使用@Retention 来设定注解的保留策略 ，这三哥策略的生命周期长度为：SOURCE&lt;CLASS&lt;RUNTIME.</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 定义编译时注解</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>CLASS<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. Repeatable 定义可重复注解</strong></p><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Persons<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    String role <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"artist"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"coder"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"PM"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>以下代码中就是相关容器注解。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基于容器的注解适用方式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Persons</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"artist"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"coder"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="三-注解的提取">三、注解的提取</span></h2><p>注解通过反射获取。<br>首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后通过 getAnnotation() / getAnnotationsByType()（since 1.8） 方法来获取 Annotation 对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> A <span class="token function">getAnnotation</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>A<span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> A<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>A<span class="token operator">></span> annotationClass <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者是 getAnnotations() 方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p><p>在处理的注解的过程中可能会用到以下方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Field <span class="token function">getDeclaredField</span><span class="token punctuation">(</span>String attrbuteName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> Field<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> Method <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>String methodName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="四-其他">四、其他</span></h2><p>注解： 使用场景 分为 三类：<br>编译前、<br>编译时生成代码、<br>运行时。</p><p>运行时注解：<br>例如：ButterKnife ，黑科技、低性能</p><p>编译时注解：<br>Dagger2：生成中间代码，所以性能高</p><p>注解处理器：<br>编译时处理器、<br>运行时处理器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法</title>
    <link href="https://brokge.github.io/2019/09/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>https://brokge.github.io/2019/09/06/工厂方法/</id>
    <published>2019-09-06T08:22:07.000Z</published>
    <updated>2020-06-05T13:21:55.816Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E7%89%B9%E7%82%B9">特点</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码：</a></li><li><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">工厂方法模式总结</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="背景">背景</span></h2><p>简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：</p><blockquote><p>(1) 工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大；</p><p>(2) 系统扩展不灵活，当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”</p></blockquote><p>如何实现增加新产品而不影响已有代码？</p><h2><span id="概念">概念</span></h2><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)</p><h2><span id="特点">特点</span></h2><p>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p><h2><span id="示例代码">示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//日志记录器接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数据库日志记录器：具体产品</span><span class="token keyword">class</span> <span class="token class-name">DatabaseLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据库日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//文件日志记录器：具体产品</span><span class="token keyword">class</span> <span class="token class-name">FileLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//日志记录器工厂接口：抽象工厂</span><span class="token keyword">interface</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数据库日志记录器工厂类：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">DatabaseLoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//连接数据库，代码省略</span>            <span class="token comment" spellcheck="true">//创建数据库日志记录器对象</span>            Logger logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//初始化数据库日志记录器，代码省略</span>            <span class="token keyword">return</span> logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//文件日志记录器工厂类：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">FileLoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建文件日志记录器对象</span>            Logger logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//创建文件，代码省略</span>            <span class="token keyword">return</span> logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//调用</span><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LoggerFactory factory<span class="token punctuation">;</span>        Logger logger<span class="token punctuation">;</span>        factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLoggerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可引入配置文件实现</span>        logger <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="工厂方法模式总结">工厂方法模式总结</span></h2><p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p><ol><li>主要优点</li></ol><p>工厂方法模式的主要优点如下：</p><blockquote><p>(1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p><p>(2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p><p>(3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p></blockquote><ol start="2"><li>主要缺点</li></ol><p>工厂方法模式的主要缺点如下：</p><blockquote><p>(1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p><p>(2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p></blockquote><ol start="3"><li>适用场景</li></ol><p>在以下情况下可以考虑使用工厂方法模式：</p><blockquote><p>(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</p><p>(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂</title>
    <link href="https://brokge.github.io/2019/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://brokge.github.io/2019/09/05/抽象工厂/</id>
    <published>2019-09-05T11:55:06.000Z</published>
    <updated>2020-06-05T13:27:36.421Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">抽象工厂</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C">和工厂方法的不同</a></li><li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">抽象工厂 示例代码：</a></li><li><a href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-%E7%9A%84%E5%80%BE%E6%96%9C%E6%80%A7">开闭原则 的倾斜性</a></li><li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1><span id="抽象工厂">抽象工厂</span></h1><h2><span id="概念">概念</span></h2><p><strong>产品类型</strong>：单个产品类型。</p><p><strong>产品族</strong>：包含多个产品类型。</p><p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，</p><h2><span id="和工厂方法的不同">和工厂方法的不同</span></h2><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。</p><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是<strong>单个产品类型</strong>，而抽象工厂模式针对的是<strong>多个产品类型</strong>，一个工厂类型可以负责多个不同产品类型中的产品对象的创建。当一个工厂类型可以创建出分属于不同产品类型的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率</p><h2><span id="案例">案例</span></h2><p>软件 换肤 功能。</p><pre class="mermaid">graph LR;    A[皮肤库]-->B[SPRING];    A[皮肤库]-->C[SUMMER];    B[SPRING]-->绿色按钮;    B[SPRING]-->绿色文本框;    B[SPRING]-->绿色边框组合框;    C[SUMMER]-->蓝色按钮;    C[SUMMER]-->蓝色文本框;    C[SUMMER]-->蓝色边框组合框;</pre><p>采用工厂方法模式设计的问题：</p><p>(1) 当需要增加新的皮肤时，虽然不要修改现有代码，但是需要增加大量类，针对每一个新增具体组件都需要增加一个具体工厂，类的个数成对增加，这无疑会导致系统越来越庞大，增加系统的维护成本和运行开销；</p><p>(2) 由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱，虽然我们可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂。</p><h2><span id="抽象工厂-示例代码">抽象工厂 示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//按钮接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring按钮类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SpringButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示浅绿色按钮。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer按钮类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SummerButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示浅蓝色按钮。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//文本框接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring文本框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SpringTextField</span> <span class="token keyword">implements</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示绿色边框文本框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer文本框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SummerTextField</span> <span class="token keyword">implements</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示蓝色边框文本框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//组合框接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring组合框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SpringComboBox</span> <span class="token keyword">implements</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示绿色边框组合框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer组合框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SummerComboBox</span> <span class="token keyword">implements</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示蓝色边框组合框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//界面皮肤工厂接口：抽象工厂</span><span class="token keyword">interface</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring皮肤工厂：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">SpringSkinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer皮肤工厂：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">SummerSkinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//客户端调用</span><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用抽象层定义</span>        SkinFactory factory<span class="token punctuation">;</span>        Button bt<span class="token punctuation">;</span>        TextField tf<span class="token punctuation">;</span>        ComboBox cb<span class="token punctuation">;</span>        factory <span class="token operator">=</span> <span class="token punctuation">(</span>SkinFactory<span class="token punctuation">)</span>XMLUtil<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bt <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tf <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cb <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bt<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tf<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cb<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="开闭原则-的倾斜性">开闭原则 的倾斜性</span></h2><p>针对以上实现，如果我想添加新的组件（如：添加一个单选按钮），让这个组件也支持换肤功能。需要怎么做呢？</p><p>首先需要修改抽象工厂接口SkinFactory，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤中创建单选按钮，此外还需要修改客户端。</p><p>这时就发现：原有系统不能够在符合“开闭原则”的前提下增加新的组件。</p><p>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品类型很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。</p><p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><p>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</p><p>(2) 增加新的产品类型：对于增加新的产品类型，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</p><p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品类型提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品类型，也不会删除已有的产品类型，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p><h2><span id="优缺点">优缺点</span></h2><p>缺点：</p><p>增加新的产品类型麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p><p>优点：</p><p> (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</p><p> (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p><p> (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><h2><span id="适用场景">适用场景</span></h2><p>在以下情况下可以考虑使用抽象工厂模式：</p><p>(1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</p><p>(2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</p><p>(3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</p><p>(4) 产品类型稳定，设计完成之后，不会向系统中增加新的产品类型或者删除已有的产品类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://brokge.github.io/2019/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://brokge.github.io/2019/09/05/设计模式/</id>
    <published>2019-09-05T09:15:15.000Z</published>
    <updated>2020-06-05T13:21:55.853Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">设计模式概述：</a><ul><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%92%E5%88%86">设计模式划分</a></li><li><a href="#%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99">七大原则</a></li></ul></li><li><a href="#23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%92%E5%88%86">23 种设计模式划分</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B">创建型</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B">结构型</a></li><li><a href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型模式</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="设计模式概述">设计模式概述：</span></h2><h3><span id="设计模式划分">设计模式划分</span></h3><p>设计模式可分为<strong>创建型</strong>(Creational)，<strong>结构型</strong>(Structural)和<strong>行为型</strong>(Behavioral)三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责</p><h3><span id="七大原则">七大原则</span></h3><ol><li>单一职责<blockquote><p>职责单一，相对独立，不细说。</p></blockquote></li><li>开放封闭原则<blockquote><p>对扩展开放，修改封闭，这个也不细说了。</p></blockquote></li><li><strong>依赖倒转</strong><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程,依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。<strong>实现依赖倒转原则时</strong>，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入</p></blockquote></li><li><strong>里氏替换原则</strong><blockquote><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。<br>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p></blockquote></li><li><strong>组合复用原则</strong><blockquote><p>尽量使用对象组合，而不是继承来达到复用的目的。<br>如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p></blockquote></li><li><strong>接口隔离原则</strong><blockquote><p>使用多个特定的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。<br><strong>接口隔离原则=使用单一职责原则的思想+考虑客户端具体的功能需求+适当切分定义接口文件+编程语言支持可实现多接口的语法特性</strong></p></blockquote></li><li><strong>迪米特原则</strong><blockquote><p>一个软件实体应当尽可能少地与其他实体发生相互作用。<br>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过<strong>第三者</strong>转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 迪米特法则目的是降低系统的耦合度，使类与类之间保持松散的耦合关系</p></blockquote></li></ol><p>在代码的重构中，很多时候以上原则是相铺相成互相结合。</p><p>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。相互补充，目标一致，只是分析问题时所站角度不同而已。</p><h2><span id="23-种设计模式划分">23 种设计模式划分</span></h2><h3><span id="创建型">创建型</span></h3><ol><li><a href="https://blog.dxdoctor.com/2019/09/06/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">简单工厂</a></li><li><a href="https://blog.dxdoctor.com/2019/09/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">工厂方法</a></li><li><a href="https://blog.dxdoctor.com/2019/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">抽象工厂</a></li><li>单例模式</li><li>原型模式</li><li>建造者模式</li></ol><h3><span id="结构型">结构型</span></h3><ol><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ol><h3><span id="行为型模式">行为型模式</span></h3><ol><li><a href="https://blog.dxdoctor.com/2019/09/23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">职责链模式</a></li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模版方法模式</li><li>访问者模式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>线程池详解 </title>
    <link href="https://brokge.github.io/2019/09/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://brokge.github.io/2019/09/03/线程池详解/</id>
    <published>2019-09-02T16:31:36.000Z</published>
    <updated>2020-06-05T13:28:13.549Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD">线程是不是越多越好？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">线程池组成部分：</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-api-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB">线程池 API-接口定义和实现类</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86-%E4%BB%BB%E5%8A%A1-execute-%E8%BF%87%E7%A8%8B">线程池原理-任务 execute 过程</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">示例代码分析</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2">线程终止</a></li><li><a href="#%E6%9C%80%E5%90%8E%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E9%80%89%E6%8B%A9">最后线程数量的选择</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1><span id="线程池">线程池</span></h1><h2><span id="线程是不是越多越好">线程是不是越多越好？</span></h2><ol><li>线程在 Java 中是一个对象，更是操作系统的资源，线程创建、销毁需要时间。如果创建时间+销毁时间 <code>&gt;</code> 执行任务时间，这样就很不合算。</li><li>Java 对象占用堆内存，操作系统线程占用系统内存，根据 JVM 规范，一个线程默认最大栈大小为 1 M，这个栈空间是需要从系统内存中分配的。线程过多，会消耗很多的内存。</li><li>操作系统需要频繁切换线程上下文（大家都想被运行），影响性能。</li></ol><p>线程池的推出，就是为了方便控制线程数量。</p><h2><span id="线程池组成部分">线程池组成部分：</span></h2><ol><li>线程池管理器：用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务。</li><li>工作线程：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务。</li><li>任务接口（Runnable）: 每个任务必须实现接口，以供工作线程调度任务执行，它主要规定了任务的入口、任务执行完后的收尾工作、任务的执行状态等。</li><li>任务队列：用于存放没有处理的任务。提供一种缓冲机制</li></ol><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt></p><h2><span id="线程池-api-接口定义和实现类">线程池 API-接口定义和实现类</span></h2><table><thead><tr><th>类型</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>接口</td><td>Executor</td><td>最上层的接口，定义了执行任务的方法 execute()</td></tr><tr><td>接口</td><td>ExecutorService</td><td>继承Executor 接口，拓展了 Callable、Future、关闭方法</td></tr><tr><td>接口</td><td>ScheduledExecutorService</td><td>继承ExecutorService 接口，增加了定时任务相关的方法</td></tr><tr><td>实现类</td><td>ThreadPoolExecutor</td><td>基础、标准的线程池实现</td></tr><tr><td>实现类</td><td>ScheduledThreadPoolExecutor</td><td>继承了 ThreadPoolExecutor，实现了 ScheduledExecutorService中相关定时任务的方法</td></tr></tbody></table><p><code>ScheduledThreadPoolExecutor</code>是功能最为丰富的类。</p><p><img src="media/15674328999538/15674332671245.jpg" alt></p><p><img src="media/15674328999538/15674335746028.jpg" alt></p><h2><span id="线程池原理-任务-execute-过程">线程池原理-任务 execute 过程</span></h2><ol><li>是否达到核心线程数量？没达到，创建一个工作线程来执行任务。</li><li>工作队列是否已满？没满，则将新提交的任务存储在工作队列里。</li><li>是否达到线程池最大数量？没达到，则创建一个新的工作线程来执行任务。</li><li>最后，执行拒绝策略来处理这个任务。</li></ol><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/%E7%BA%BF%E7%A8%8B%E6%B1%A0Execute%E5%8E%9F%E7%90%86.png" alt></p><h2><span id="示例代码分析">示例代码分析</span></h2><p>测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCommon</span><span class="token punctuation">(</span>ThreadPoolExecutor threadPoolExecutor<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 查看线程数量，查看队列等待数量</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>500L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>15000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>场景一：</li></ul><blockquote><p>线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行</p></blockquote><ul><li>场景二：</li></ul><blockquote><p> 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略.</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 预计结果：</p><ol><li>5个任务直接分配线程开始执行</li><li>3个任务进入等待队列</li><li>队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)</li><li>队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。</li><li>任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程</li></ol></blockquote><ul><li>场景三：</li></ul><blockquote><p>线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒 *  * @throws Exception */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newFixedThreadPool(int nThreads)一样的</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// </span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行</p></blockquote><ul><li>场景四：</li></ul><blockquote><p>线程池信息：核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>60000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"60秒后，再看线程池中的数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：</p><ol><li>线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行</li><li>所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0</li></ol></blockquote><blockquote><p>SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。<br>在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，<br>而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，<br>那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。<br>此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。<br>和Executors.newCachedThreadPool()一样的</p></blockquote><ul><li>场景五：</li></ul><blockquote><p>定时执行线程池信息：3秒后执行，一次性任务，到点就执行<br>核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newScheduledThreadPool()一样的</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                <span class="token string">"定时任务，提交成功，时间是："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 当前线程池中线程数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：任务在3秒后被执行一次</p></blockquote><ul><li>场景六：</li></ul><blockquote><p>定时执行线程池信息：线程固定数量5 , 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-1 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-2 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>周期性执行某一个任务，线程池提供了两种调度方式</p><p>测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别<br>效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。<br> 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）</p><p>效果2： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）</p></blockquote><h2><span id="线程终止">线程终止</span></h2><p>线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略.</p><ul><li>shutdown()</li></ul><p>创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。<br>默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 结果分析</p><ol><li>10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</li><li>调用shutdown后，不接收新的任务，等待13任务执行结束</li><li>追加的任务在线程池关闭后，无法再提交，会被拒绝执行</li></ol></blockquote><ul><li>shutdownNow()</li></ul><p>创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> shutdownNow <span class="token operator">=</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未结束的任务有："</span> <span class="token operator">+</span> shutdownNow<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>结果分析</p><ol><li>10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</li><li>调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止</li><li>追加的任务在线程池关闭后，无法再提交，会被拒绝执行</li></ol></blockquote><h2><span id="最后线程数量的选择">最后线程数量的选择</span></h2><ul><li><strong>计算型任务</strong>： cpu 数量的 1-2 倍。</li><li><strong>IO型任务</strong>：相对比计算型任务，需多一些线程，要根据具体的 IO阻塞时长进行考量决定。<br>如 tomcat 中默认的最大线程数为：200</li></ul><p>也可考虑根据需要在一个最小数量和最大数量间自动增减线程数。</p><p>以上测试完整代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>hc<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>chapter1<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RejectedExecutionHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ScheduledThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>SynchronousQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 线程池的使用 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo9</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况     *      * @param threadPoolExecutor 传入不同的线程池，看不同的结果     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCommon</span><span class="token punctuation">(</span>ThreadPoolExecutor threadPoolExecutor<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 查看线程数量，查看队列等待数量</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>500L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>15000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：</span>        <span class="token comment" spellcheck="true">// 1、 5个任务直接分配线程开始执行</span>        <span class="token comment" spellcheck="true">// 2、 3个任务进入等待队列</span>        <span class="token comment" spellcheck="true">// 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)</span>        <span class="token comment" spellcheck="true">// 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。</span>        <span class="token comment" spellcheck="true">// 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newFixedThreadPool(int nThreads)一样的</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 4、 线程池信息：     * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。</span>        <span class="token comment" spellcheck="true">// 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，</span>        <span class="token comment" spellcheck="true">// 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，</span>        <span class="token comment" spellcheck="true">// 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。</span>        <span class="token comment" spellcheck="true">// 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。</span>        <span class="token comment" spellcheck="true">// 和Executors.newCachedThreadPool()一样的</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：</span>        <span class="token comment" spellcheck="true">// 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行</span>        <span class="token comment" spellcheck="true">// 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>60000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"60秒后，再看线程池中的数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/>     * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newScheduledThreadPool()一样的</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                <span class="token string">"定时任务，提交成功，时间是："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 当前线程池中线程数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：任务在3秒后被执行一次</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/>     * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。</span>        <span class="token comment" spellcheck="true">// 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别</span>        <span class="token comment" spellcheck="true">// 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。</span>        <span class="token comment" spellcheck="true">// 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-1 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。</span>        <span class="token comment" spellcheck="true">// 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-2 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 结果分析</span>        <span class="token comment" spellcheck="true">// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</span>        <span class="token comment" spellcheck="true">// 2、调用shutdown后，不接收新的任务，等待13任务执行结束</span>        <span class="token comment" spellcheck="true">// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> shutdownNow <span class="token operator">=</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未结束的任务有："</span> <span class="token operator">+</span> shutdownNow<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 结果分析</span>        <span class="token comment" spellcheck="true">// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</span>        <span class="token comment" spellcheck="true">// 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止</span>        <span class="token comment" spellcheck="true">// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest1();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest2();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest3();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest4();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest5();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest6();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest7();</span>        <span class="token keyword">new</span> <span class="token class-name">Demo9</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">threadPoolExecutorTest8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="https://brokge.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java  注解</title>
    <link href="https://brokge.github.io/2019/08/30/Java-%E6%B3%A8%E8%A7%A3/"/>
    <id>https://brokge.github.io/2019/08/30/Java-注解/</id>
    <published>2019-08-30T12:44:41.000Z</published>
    <updated>2020-06-05T13:21:55.799Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><p><a href="#%E6%B3%A8%E8%A7%A3">注解</a></p></li><li><p><a href="#%E6%B3%A8%E8%A7%A3">注解</a></p><ul><li><a href="#%E4%B8%80-%E6%B3%A8%E8%A7%A3%E5%88%86%E7%B1%BB">一 、注解分类</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">定义注解</a></li><li><a href="#%E4%BA%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8F%90%E5%8F%96">二、注解的提取</a></li><li><a href="#%E4%B8%89%E5%85%B6%E4%BB%96">三、其他</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="注解">注解</span></h2><p>注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。</p><h3><span id="一-注解分类">一 、注解分类</span></h3><ol><li><p><strong>java 内置注解</strong> </p><p>@Override、 @Deprecated、@SuppressWarnings、@SafeVarargs(jdk 7 新增)</p></li><li><p><strong>标注注解的元注解</strong></p></li></ol><p>它是用来修饰注解的注解，从而创建新的注解。</p><ul><li>@Target, 说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目的。</li><li>@Retention, 定义了该Annotation被保留的时间长短，SOURCE、CLASS、RUNTIME（可通过反射获取内部属性）。</li><li>@Documented, 标记注解，可以工具文档化。</li><li>@Inherited 当前注解是否可以继承。</li><li>@Repeatable: JDK 8 新增，允许一个注解在同一声明类型（类、属性或方法）上多次使用。</li></ul><p><strong>@Targe</strong> 注解取值是一个 ElementType 类型的数组。</p><table><thead><tr><th>ElementType</th><th>说明</th></tr></thead><tbody><tr><td>- ElementType.TYPE</td><td>修饰类、接口或枚举类型。</td></tr><tr><td>- ElementType.FIELD</td><td>修饰成员变量。</td></tr><tr><td>- ElementType.METHOD</td><td>修饰方法。</td></tr><tr><td>- ElementType.PARAMETER</td><td>修饰参数。</td></tr><tr><td>- ElementType.CONSTRUCTOR</td><td>修饰构造方法。</td></tr><tr><td>- ElementType.LOCAL_VARIABLE</td><td>修饰局部变量。</td></tr><tr><td>- ElementType.ANNOTATION_TYPE</td><td>修饰注解。</td></tr><tr><td>- ElementType.PACKAGE</td><td>修饰包。</td></tr><tr><td>- ElementType.TYPE_PARAMETER</td><td>修饰参数声明。</td></tr><tr><td>- ElementType.TYOPE_USR</td><td>使用类型。</td></tr></tbody></table><p><strong>@Retention</strong> 3种类型，分别表示不同的保留周期</p><ul><li><strong>RetentionPolicy.SOURCE</strong>:源码级注解。<blockquote><p>注解信息只会保留在.java 源码中，源码在编译后，注解信息会被丢弃，不会保留到.class 中。</p></blockquote></li><li><strong>RetentionPolicy.CLASS</strong>:编译时注解。<blockquote><p>注解信息会保留在.java 源码以及.class 中。当运行java 程序时，JVM 会丢弃该注解信息，不会保留到 JVM 中。</p></blockquote></li><li><strong>RetentionPolicy.RUNTIME</strong>:运行时注解。<blockquote><p>当运行 java 程序时，JVM 也会保留该注解信息，可以通过反射获取该注解信息。</p></blockquote></li></ul><h3><span id="定义注解">定义注解</span></h3><p><strong>1. 基本定义</strong></p><p>定义新的注解类型使用 @interface 关键字。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>程序中使用该注解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Cup</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 定义成员变量(注解的属性)</strong></p><p>注解 只有成员变量，没有方法。注解的成员变量在注解定义中以“无形参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型；</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个成员变量以方法的形式来定义。使用该注解时候就应该为该成员变量赋值</p><pre class="line-numbers language-java"><code class="language-java">pubilc <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Cup</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"马克杯"</span><span class="token punctuation">,</span>price<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以在定义注解的时候通过 default 来指定默认值：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>   String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 定义运行时注解</strong></p><p>使用@Retention 来设定注解的保留策略 ，这三哥策略的生命周期长度为：SOURCE&lt;CLASS&lt;RUNTIME.</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 定义编译时注解</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>CLASS<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. Repeatable 定义可重复注解</strong></p><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Persons<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    String role <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"artist"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"coder"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"PM"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>以下代码中就是相关容器注解。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="二-注解的提取">二、注解的提取</span></h3><p>注解通过反射获取。<br>首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> A <span class="token function">getAnnotation</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>A<span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者是 getAnnotations() 方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p><p>在处理的注解的过程中可能会用到以下方法</p><pre class="line-numbers language-java"><code class="language-java">Field <span class="token function">getDeclaredField</span><span class="token punctuation">(</span>String attrbuteName<span class="token punctuation">)</span><span class="token punctuation">;</span>Method <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>String methodName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3><span id="三-其他">三、其他</span></h3><p>注解： 使用场景 分为 三类：<br>编译前、<br>编译时生成代码、<br>运行时。</p><p>运行时注解：<br>例如：ButterKnife ，黑科技、低性能</p><p>编译时注解：<br>Dagger2：生成中间代码，所以性能高</p><p>注解处理器：<br>编译时处理器、<br>运行时处理器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="注解" scheme="https://brokge.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM 类加载和初始化</title>
    <link href="https://brokge.github.io/2019/07/30/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://brokge.github.io/2019/07/30/JVM-类加载和初始化/</id>
    <published>2019-07-30T12:50:24.000Z</published>
    <updated>2020-06-05T13:21:55.793Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96">Java 类加载和初始化</a><ul><li><a href="#%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8A%A0%E8%BD%BD">类什么时候加载？</a></li><li><a href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F">类初始化的方式</a></li><li><a href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99">类初始化规则：</a><ul><li><a href="#%E5%90%8D%E8%AF%8D%E8%AF%B4%E6%98%8E">名词说明</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考：</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>[toc]</p><h1><span id="java-类加载和初始化">Java 类加载和初始化</span></h1><p>我们知道 当要实例化一个类时，JVM会首先加载该类，并且在加载过程中检查这个类是否有静态属性以及静态代码块，如果有，就按顺序分配内存并初始化他们，并且只在类加载的过程中初始化一次。</p><p>对于构造代码块，以及普通属性，是在类实例化时进行的，并且每次实例化都会调用，并且普通属性先于构造代码块，构造代码块先于构造方法执行。</p><p><img src="http://note.youdao.com/yws/res/8429/WEBRESOURCEfc10df5b4324dcf9adba0dd3c37d47ea" alt="java-load-class.png"></p><p><img src="http://note.youdao.com/yws/res/8434/19F1DA8485CF45BF9DEA8BA3DB0E5FFA" alt="image"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span> <span class="token string">"第一步 main 静态属性"</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3</span>    <span class="token keyword">private</span> String value <span class="token operator">=</span> <span class="token string">"第三步 main 普通属性"</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第二步 main 静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//4</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第四步 main 构造代码块 "</span><span class="token operator">+</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过查看时间戳，常规属性是在 构造代码块之前就初始化。</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//5</span>    <span class="token keyword">private</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第五步 main 构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getString()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Main main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制台输出：</p><pre><code>1565683686844第一步 main 静态属性15656836868441565683687848第二步 main 静态代码块1565683687849第四步 main 构造代码块 1565683688852第三步 main 普通属性1565683687849第五步 main 构造方法</code></pre><p>可以发现第三步和第四步顺序是掉换的，但是根据时间戳知道，第三步是发生在第四部之前，也就是说第三步的普通属性的初始化在构造代码块之前执行。</p><h3><span id="类什么时候加载">类什么时候加载？</span></h3><p>加载时机：</p><blockquote><ol><li>其他类引用时候（被使用的时候）。</li><li>类初始化（自己初始化）。</li></ol></blockquote><p>加载工具： Classloader(类加载器)</p><blockquote><p>类加载器：Bootstrap Loader(用于加载核心 jar)、Extension class Loader（扩展 jar）、Application class Loader（应用 jar）.</p><p>同一个类加载器对于类名一样的类，只会加载一次。单纯的加载 ，类的一切都不会执行。<br>当类满足以下两个条件会被卸载</p><ol><li>该类的所有实例都被 GC</li><li>加载该类的类加载器被 GC</li></ol></blockquote><h3><span id="类初始化的方式">类初始化的方式</span></h3><ol><li>实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。</li><li>类的静态方法被调用。</li><li>类的静态域（静态变量）被赋值。</li><li>静态域被访问，而且不是常量（final）。</li><li>顶层类中执行 assert 语句。</li></ol><h3><span id="类初始化规则">类初始化规则：</span></h3><ol><li>类从顶至底部顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</li><li>超类早于子类和衍生类的初始化</li><li>如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的初始化即使静态域被子类或子接口或者它的实现类所引用。</li><li>接口初始化不会导致父接口的初始化。</li><li>静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</li><li>非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类。</li></ol><h2><span id="名词说明">名词说明</span></h2><p><strong>类的初始化和类的实例化是不同的</strong>:<br>类的初始化发生在类实例化之前。<br>类的初始化是指类加载过程中的初始化阶段对类变量按照程序猿的意图进行赋值的过程；而类的实例化是指在类完全加载到内存中后创建对象的过程。</p><ul><li>静态域=静态变量</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span><span class="token string">"静态域"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>静态域：如果将类中的域定义为static，则这个域属于这个类，而不属于这个类的某个对象，每个类中只有 一个这样的域，而每一个类对象对于所有的实例域(即没有定义为static的域)都有自己的一份拷贝。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>　　<span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>　　<span class="token keyword">private</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span><span class="token string">"静态域"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果有1000个Employee对象，则有1000个实例域 id，但是只有一个静态域 staticValue；即使没有一个Employee对象，静态域nextId也存在，它属于类，不属于任何对象。</p></blockquote><ul><li>实例域=非静态变量</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span>  String staticValue <span class="token operator">=</span><span class="token string">"实例域"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>静态常量=final</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span><span class="token string">"静态常量"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>静态方法</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getString()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>静态代码块</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>构造代码块</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构造方法</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">main</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="参考">参考：</span></h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">类加载器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JVM" scheme="https://brokge.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
