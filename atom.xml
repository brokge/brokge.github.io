<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾与尔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brokge.github.io/"/>
  <updated>2019-08-30T12:53:21.500Z</updated>
  <id>https://brokge.github.io/</id>
  
  <author>
    <name>brokge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM 类加载和初始化</title>
    <link href="https://brokge.github.io/2019/08/30/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://brokge.github.io/2019/08/30/JVM-类加载和初始化/</id>
    <published>2019-08-30T12:50:24.000Z</published>
    <updated>2019-08-30T12:53:21.500Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Java-类加载和初始化"><a href="#Java-类加载和初始化" class="headerlink" title="Java 类加载和初始化"></a>Java 类加载和初始化</h1><p>我们知道 当要实例化一个类时，JVM会首先加载该类，并且在加载过程中检查这个类是否有静态属性以及静态代码块，如果有，就按顺序分配内存并初始化他们，并且只在类加载的过程中初始化一次。</p><p>对于构造代码块，以及普通属性，是在类实例化时进行的，并且每次实例化都会调用，并且普通属性先于构造代码块，构造代码块先于构造方法执行。</p><p><img src="https://raw.githubusercontent.com/brokge/drawio/master/java-load-class.png" alt="流程图"></p><pre><code>public class Main {    //1    private static String staticValue = &quot;第一步 main 静态属性&quot; + System.currentTimeMillis();    //3    private String value = &quot;第三步 main 普通属性&quot; + System.currentTimeMillis();    //2    static {        System.out.println(System.currentTimeMillis() + &quot;&quot;);        try {            Thread.sleep(1000);        } catch (InterruptedException e) {        }        System.out.println(staticValue);        System.out.println(System.currentTimeMillis() + &quot;&quot;);        System.out.println(&quot;第二步 main 静态代码块&quot;);    }    //4    {        System.out.println(System.currentTimeMillis() + &quot;&quot;);        try {            Thread.sleep(1000);        } catch (InterruptedException e) {        }        System.out.println(&quot;第四步 main 构造代码块 &quot;+System.currentTimeMillis());        //通过查看时间戳，常规属性是在 构造代码块之前就初始化。        System.out.println(value);    }    //5    private Main() {        System.out.println(&quot;第五步 main 构造方法&quot;);    }    public static String getString() {        System.out.println(&quot;getString()&quot;);        return &quot;&quot;;    }    public static void main(String[] args) {        Main main = new Main();    }}</code></pre><p>控制台输出：</p><pre><code>1565683686844第一步 main 静态属性15656836868441565683687848第二步 main 静态代码块1565683687849第四步 main 构造代码块 1565683688852第三步 main 普通属性1565683687849第五步 main 构造方法</code></pre><p>可以发现第三步和第四步顺序是掉换的，但是根据时间戳知道，第三步是发生在第四部之前，也就是说第三步的普通属性的初始化在构造代码块之前执行。</p><h3 id="类什么时候加载？"><a href="#类什么时候加载？" class="headerlink" title="类什么时候加载？"></a>类什么时候加载？</h3><p>加载时机：</p><blockquote><ol><li>其他类引用时候。</li><li>类初始化。</li></ol></blockquote><p>加载工具： Classloader(类加载器)</p><h3 id="类初始化的方式"><a href="#类初始化的方式" class="headerlink" title="类初始化的方式"></a>类初始化的方式</h3><ol><li>实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。</li><li>类的静态方法被调用。</li><li>类的静态域（静态变量）被赋值。</li><li>静态域被访问，而且不是常量（final）。</li><li>顶层类中执行 assert 语句。</li></ol><h3 id="类初始化规则："><a href="#类初始化规则：" class="headerlink" title="类初始化规则："></a>类初始化规则：</h3><ol><li>类从顶至底部顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</li><li>超类早于子类和衍生类的初始化</li><li>如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的初始化即使静态域被子类或子接口或者它的实现类所引用。</li><li>接口初始化不会导致父接口的初始化。</li><li>静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</li><li>非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类。</li></ol><h2 id="名词说明"><a href="#名词说明" class="headerlink" title="名词说明"></a>名词说明</h2><p><strong>类的初始化和类的实例化是不同的</strong>:<br>类的初始化发生在类实例化之前。</p><ul><li>静态域=静态变量<br><code>`</code><br>private static String staticValue =”静态域”;</li></ul><pre><code>&gt;静态域：如果将类中的域定义为static，则这个域属于这个类，而不属于这个类的某个对象，每个类中只有 一个这样的域，而每一个类对象对于所有的实例域(即没有定义为static的域)都有自己的一份拷贝。例如：&gt;</code></pre><blockquote><p>class Employee {<br>　　private int id;<br>　　private static String staticValue =”静态域”;<br>}<br><code>`</code><br>如果有1000个Employee对象，则有1000个实例域 id，但是只有一个静态域 staticValue；即使没有一个Employee对象，静态域nextId也存在，它属于类，不属于任何对象。</p></blockquote><ul><li>实例域=非静态变量<pre><code>private  String staticValue =&quot;实例域&quot;;</code></pre></li><li>静态常量=final<pre><code>private final static String staticValue =&quot;静态常量&quot;;</code></pre></li><li>静态方法<pre><code>public static String getString() {      System.out.println(&quot;getString()&quot;);      return &quot;&quot;;}</code></pre></li><li>静态代码块</li></ul><pre><code>static {}</code></pre><ul><li>构造代码块<br><code>`</code><br>{<br>  System.out.println(“构造代码块”);<br>}</li></ul><pre><code>- 构造方法</code></pre><p>class main{</p><p>   private main(){<br>        System.out.println(“构造方法”);<br>    }<br>}</p><p><code>`</code></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">类加载器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;Java-类加载和初始化&quot;&gt;&lt;a href=&quot;#Java-类加载和初始化&quot; class=&quot;headerlink&quot; title=&quot;Java 类加载和初始化&quot;&gt;&lt;/a&gt;Java 类加载和初始化&lt;/h1&gt;&lt;p&gt;我们知道 当要实例化一个类时，JV
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://brokge.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射进阶</title>
    <link href="https://brokge.github.io/2019/08/30/Java-%E5%8F%8D%E5%B0%84%E8%BF%9B%E9%98%B6/"/>
    <id>https://brokge.github.io/2019/08/30/Java-反射进阶/</id>
    <published>2019-08-30T12:46:34.000Z</published>
    <updated>2019-08-30T12:52:00.459Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/briblue/article/details/76223206" target="_blank" rel="noopener">参考博客</a></p><h3 id="获取不存在的对象？"><a href="#获取不存在的对象？" class="headerlink" title="获取不存在的对象？"></a>获取不存在的对象？</h3><p><strong>1. 获取不到 class 对象</strong></p><ul><li>通过一个对象的 getClass() 方法。</li><li>通过 .class 关键字。</li><li>通过 Class.forName()。</li></ul><p>抛出 ClassNotFoundException 异常。</p><p><strong>2. 获取不到 Field</strong></p><p>获取不到 Field 的情况分3种： </p><ul><li><p>确实不存在这个 Field </p><p>抛出 NoSuchFieldException</p></li><li><p>由于修饰符导致的权限问题。</p><p>抛出 SecurityException</p></li><li><p>Field 存在，但获取不到</p><p>抛出 NoSuchFieldException </p></li></ul><p>针对 Field 存在，但获取不到情况：<br>由于 getField 和 getDeclaredField 在父类获取的限制（参照反射.md）。<br>可以先获取 当前类的 父类，即 superClass ，然后 通过 getField或者getDeclaredField的方式获取</p><pre><code>Class superClass = clzBase.getSuperclass();</code></pre><p><strong>3. 获取不到 Method</strong></p><ul><li><p>获取本身就不存在的 Method</p><p> 抛出 NoSuchMethodException</p></li><li><p>参数类型不匹配而找不到</p><p> 抛出NoSuchMethodException，传递参数的方式：<br><code>`</code><br>Method methodtest = class1.getDeclaredMethod(“test”,int.class,float.class);</p></li></ul><p>Method methodtest = class1.getDeclaredMethod(“test”,new Class[]{int.class,float.class});</p><pre><code>**4. 获取不到 Constructor**与 method 的类似**5. getInterfaces() 的作用**大家可能都会觉得 getInterfaces() 的作用是获取一个类中定义的接口，但是其实不是的，getInterfaces() 获取的是一个类所有实现的接口。### 反射中的权限问题**1. 操纵非 public 修饰的 Field**抛出 IllegalAccessException 错误</code></pre><p>field.setAccessible(true);</p><pre><code>我这里以 private 为例，其实 protected 和 default 也是一样的，但是它们不同于 private 的地方在于，它们在本 package 范围内是可见的，有兴趣的同学可以测试一下，测试代码在一个 package，而测试的类在另外一个 package。**2. 操纵一个 final 类型的 Field**抛出 IllegalAccessException 错误</code></pre><p>setAccessible(true)</p><pre><code>虽然被 public 修饰，但是它同样被 final 修饰，这在正常的开发流程说明这个属性不能够再被改变。如果要解决这个问题，同样可以使用 setAccessible(true) 方法**3. 操纵非 public 修饰的 Method**</code></pre><p>method.setAccessible(true);</p><pre><code>通过 setAccessible(true) 同样可以解决这个问题。**4. 操纵非 public 修饰的 Constructor**同前面两种，同样是通过 setAccessible(true) 来搞定。所以，在反射中如果要操作被 private 修饰的对象，那么就必须调用它的 setAccessible(true)。### setAccessible() 的秘密### Class.newInstance() 和 Constructor.newInstance() 的区别Class.newInstance() 的使用有严格的限制，那就是一个 Class 对象中，必须存在一个无参数的 Constructor，并且这个 Constructor 必须要有访问的权限。通过 Constructor.newInstance() 却没有这种限制。Constructor.newInstance() 适应任何类型的 Constructor,无论它们有参数还是无参数，只要通过 setAccessible() 控制好访问权限就可以了。### 谨慎使用 Method.invoke() 方法</code></pre><p>public Object invoke(Object obj, Object… args)<br>        throws IllegalAccessException, IllegalArgumentException,<br>           InvocationTargetException</p><pre><code>第一个 Object 参数代表的是对应的 Class 对象实例，这在上面一节已经见识到了。而后面的参数就是可变形参了，它接受多个参数。我们考虑一种特殊情况。</code></pre><p>public class TestT<t>{</t></p><pre><code>public  void test(T t){}</code></pre><p>}</p><pre><code>这是一个泛型类，T 表示接受任意类型的参数。</code></pre><p> Method tMethod = clzT.getDeclaredMethod(“test”,Integer.class);<br> tMethod.setAccessible(true);<br> tMethod.invoke(new TestT<integer>(),1);</integer></p><pre><code>报错 ：NoSuchMethodException，提示找不到这个方法。原因是类型擦除。当一个方法有泛型参数时，编译器会自动向上转型，T 向上转型是 Object。所以实际上是 void test(Object t); 上面的代码试图去找 test(Integer t) 这个方法，自然是找不到。</code></pre><p>Method tMethod = clzT.getDeclaredMethod(“test”,Object.class);<br>tMethod.setAccessible(true);</p><p>tMethod.invoke(new TestT<integer>(),1);<br><code>`</code></integer></p><h3 id="Method-中处理-Exception"><a href="#Method-中处理-Exception" class="headerlink" title="Method 中处理 Exception"></a>Method 中处理 Exception</h3><p>在 Java 反射中，一个 Method 执行时遭遇的异常会被包装在一个特定的异常中，这个异常就是 InvocationTargetException。</p><p>总结：</p><table><thead><tr><th>异常名称</th><th>原因</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>1. class.forName() 传入的包名有误 2.Class本身不存在</td></tr><tr><td>NoSuchFieldException</td><td>1. Field 名称不正确。2. getDeclaredField 和 getField()方法使用不当。</td></tr><tr><td>NoSuchMethodException</td><td>1. 方法本身不存在。2. 传入的参数的类型不匹配。3. 传入的参数 个数不匹配。</td></tr><tr><td>IllegalAccessException</td><td>1. 访问非 public修饰的对象如Field、Method、Consturctor。2. 操作 final 修饰的 Field.</td></tr><tr><td>IllegalArgumentException</td><td>1. Method.invoke 中参数匹配。2. Field 操作时设置的值不匹配。3. Constructor.newInstance() 传入的参数不匹配。</td></tr><tr><td>InvocationTargetException</td><td>1. Method 运行时产生异常.2.Constructor.newInstance() 作用时产生异常</td></tr><tr><td>InstantiationException</td><td>1. Class.newInstance() 或者Constructor.newInstance()异常。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/briblue/article/details/76223206&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取不存在的对象？&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="https://brokge.github.io/2019/08/30/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>https://brokge.github.io/2019/08/30/Java-反射/</id>
    <published>2019-08-30T12:45:47.000Z</published>
    <updated>2019-08-30T12:53:43.536Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/briblue/article/details/74616922" target="_blank" rel="noopener">参考博客网址</a></p><h2 id="反射入口"><a href="#反射入口" class="headerlink" title="反射入口"></a>反射入口</h2><p><strong>Object.getClass()</strong></p><pre><code>Car car = new Car();Class clazz = car.getClass();</code></pre><p><strong>.class</strong></p><pre><code>Class clazz = Car.class;Class cls1 = int.class;Class cls2 = String.class;</code></pre><p> <strong>Class.forName() 方法</strong></p><pre><code> try {    Class clz = Class.forName(&quot;com.aa.test.Car&quot;);} catch (ClassNotFoundException e) {    // TODO Auto-generated catch block    e.printStackTrace();}</code></pre><p> <strong>Class 的名字</strong></p><pre><code> Class.getName();Class.getSimpleName();Class.getCanonicalName();</code></pre><pre><code> Class clz = new Outter.Inner[][][]{}.getClass();System.out.println(&quot; Inner Class name:&quot;+clz.getName());System.out.println(&quot; Inner Class simple name:&quot;+clz.getSimpleName());System.out.println(&quot; Inner Class canonical name:&quot;+clz.getCanonicalName());//run 是匿名类Runnable run = new Runnable() {    @Override    public void run() {        // TODO Auto-generated method stub    }};System.out.println(&quot; anonymous Class name:&quot;+run.getClass().getName());System.out.println(&quot; anonymous Class simple name:&quot;+run.getClass().getSimpleName());System.out.println(&quot; anonymous Class canonical name:&quot;+run.getClass().getCanonicalName());// local 是局部类class local{};System.out.println(&quot;Local a name:&quot;+local.class.getName());System.out.println(&quot;Local a simplename:&quot;+local.class.getSimpleName());System.out.println(&quot;Local a canonicalname:&quot;+local.class.getCanonicalName());</code></pre><p>输出</p><pre><code>//[[[ 代表三维数组Inner Class name:[[[Lcom.frank.test.Outter$Inner;Inner Class simple name:Inner[][][]Inner Class canonical name:com.frank.test.Outter.Inner[][][]//匿名类:anonymous Class name:com.frank.test.Test$1anonymous Class simple name:anonymous Class canonical name:null//局部类Local a name:com.frank.test.Test$1localLocal a simplename:localLocal a canonicalname:null</code></pre><p>Canonical 是官方、标准的意思，那么 getCanonicalName() 自然就是返回一个 Class 对象的官方名字，这个官方名字 canonicalName 是 Java 语言规范制定的，如果 Class 对象没有 canonicalName 的话就返回 null。</p><p>getCanonicalName() 是 getName() 和 getSimpleName() 的结合。</p><ul><li>getCanonicalName() 返回的也是全限定类名，但是对于内部类，不用 $ 开头，而用 .。</li><li>getCanonicalName() 对于数组类型的 Class，同 simplename 一样直接在后面添加 [] 。</li><li>getCanonicalName() 不同于 simplename 的地方是，不存在 canonicalName 的时候返回 null 而不是空字符串。</li><li>局部类和匿名内部类不存在 canonicalName。</li></ul><p><strong>Class 获取修饰符</strong></p><pre><code>System.out.println(&quot;modifiers value:&quot;+TestModifier.class.getModifiers());System.out.println(&quot;modifiers :&quot;+Modifier.toString(TestModifier.class.getModifiers()));</code></pre><p>输出</p><pre><code>modifiers value:1025modifiers :public abstract</code></pre><p>大家肯定会有疑问，为什么会返回一个整型数值呢？</p><p>这是因为一个类定义的时候可能会被多个修饰符修饰，为了一并获取，所以 Java 工程师考虑到了位运算，用一个 int 数值来记录所有的修饰符，然后不同的位对应不同的修饰符，这些修饰符对应的位都定义在 Modifier 这个类当中。<br>举例：</p><table><thead><tr><th>待比较</th><th>2进制</th></tr></thead><tbody><tr><td>public（0x00000001）</td><td>00000000001</td></tr><tr><td> 1025</td><td>10000000001</td></tr><tr><td>进行&amp;运算结果</td><td>00000000001 </td></tr></tbody></table><pre><code>public static boolean isPublic(int mod) {        return (mod &amp; PUBLIC) != 0;}</code></pre><p>得出结果  00000000001 不等于0 返回true ，类修饰符为 public</p><h2 id="获取Class-的成员"><a href="#获取Class-的成员" class="headerlink" title="获取Class 的成员"></a>获取Class 的成员</h2><p>一个类的成员包括属性（有人翻译为字段或者域）、方法。对应到 Class 中就是 Field、Method、Constructor</p><p><strong>获取Field</strong></p><pre><code>//获取的是 Class 中的属性，不能获取其父类的属性public Field getDeclaredField(String name)                       throws NoSuchFieldException,                              SecurityException;//获取的是 public 属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取public Field getField(String name)               throws NoSuchFieldException,                      SecurityException//获取所有的属性，但不包括从父类继承下来的属性public Field[] getDeclaredFields() throws SecurityException {}//获取自身的所有的 public 属性，包括从父类继承下来的。public Field[] getFields() throws SecurityException {</code></pre><blockquote><p>1.两者的区别就是 getDeclaredField() 获取的是 Class 中的属性,不能获取其父类的属性。 getField() 方法获取的是public属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取。</p><ol start="2"><li>getDeclaredFileds() 方法可以获取 private、protected、public 和 default 属性，但是它获取不到从父类继承下来的属性。getFields() 自身的所有的 public 属性，包括从父类继承下来的。</li></ol></blockquote><table><thead><tr><th>方法</th><th>本 Class</th><th>SupperClass</th></tr></thead><tbody><tr><td>getField</td><td>public</td><td>public</td></tr><tr><td>getDeclaredField</td><td>public、protected、default、private</td><td>x</td></tr><tr><td>getFields</td><td>public</td><td>public</td></tr><tr><td>getDeclaredFields</td><td>public、protected、default、private</td><td>x</td></tr></tbody></table><p><strong>获取 Method</strong></p><table><thead><tr><th>方法</th><th>本 Class</th><th>SupperClass</th></tr></thead><tbody><tr><td>getMethod</td><td>public</td><td>public</td></tr><tr><td>getDeclaredMethod</td><td>public、protected、default、private</td><td>x</td></tr><tr><td>getMethods</td><td>public</td><td>public</td></tr><tr><td>getDeclaredMethods</td><td>public、protected、default、private</td><td>x</td></tr></tbody></table><p>类或者接口中的方法对应到 Class 就是 Method。<br>相应的 API 如下，parameterTypes 是方法对应的参数，获取范围和Field类似。：</p><pre><code>public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)public Method[] getDeclaredMethods() throws SecurityExceptionpublic Method getMethod(String name, Class&lt;?&gt;... parameterTypes) </code></pre><p><strong>获取Contructor</strong><br>Java 反射把构造器从方法中单独拎出来了，用 Constructor 表示。</p><pre><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException public Constructor&lt;?&gt;[] getConstructors() throws SecurityException </code></pre><p>因为，Constructor 不能从父类继承，所以就没有办法通过 getConstructor() 获取到父类的 Constructor。</p><h3 id="Field-的操作"><a href="#Field-的操作" class="headerlink" title="Field 的操作"></a><strong>Field 的操作</strong></h3><p>类中 定义的属性， 它们的类型要么是 8 种基础类型 int、long、float、double、boolean、char、byte 和 short。要么是引用，所有的引用都是 Object 的后代。<br><strong>Field 类型的获取</strong></p><pre><code>public Type getGenericType() {}public Class&lt;?&gt; getType() {}</code></pre><p>注意，两者返回的类型不一样，getGenericType() 方法能够获取到泛型类型，比如 <code>hashMap&lt;String,String&gt;</code>,比getType 更详细。<br><strong>Field 修饰符的获取</strong></p><pre><code>public int getModifiers() {}</code></pre><p>这个与前面 Class 获取修饰符一致。<br><strong>Field 内容的读取与赋值</strong><br>Field 这个类定义了一系列的 get 方法来获取不同类型的值。</p><pre><code>public Object get(Object obj);public int getInt(Object obj);public long getLong(Object obj)        throws IllegalArgumentException, IllegalAccessException;public float getFloat(Object obj)        throws IllegalArgumentException, IllegalAccessException;public short getShort(Object obj)        throws IllegalArgumentException, IllegalAccessException;public double getDouble(Object obj)        throws IllegalArgumentException, IllegalAccessException;public char getChar(Object obj)        throws IllegalArgumentException, IllegalAccessException;public byte getByte(Object obj)        throws IllegalArgumentException, IllegalAccessException;public boolean getBoolean(Object obj)        throws IllegalArgumentException, IllegalAccessException</code></pre><p>Field 又定义了一系列的 set 方法用来对其自身进行赋值。</p><pre><code>public void set(Object obj, Object value);public void setInt(Object obj,int value);public void setLong(Object obj,long value)        throws IllegalArgumentException, IllegalAccessException;public void setFloat(Object obj,float value)        throws IllegalArgumentException, IllegalAccessException;public void setShort(Object obj,short value)        throws IllegalArgumentException, IllegalAccessException;public void setDouble(Object obj,double value)        throws IllegalArgumentException, IllegalAccessException;public void setChar(Object obj,char value)        throws IllegalArgumentException, IllegalAccessException;public void setByte(Object obj,byte b)        throws IllegalArgumentException, IllegalAccessException;public void setBoolean(Object obj,boolean b)        throws IllegalArgumentException, IllegalAccessException</code></pre><p>可能有同学会对方法中出现的 Object 参数有疑问，它其实是类的实例引用，这里涉及一个细节。</p><blockquote><p><strong>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。</strong></p></blockquote><p>在执行 set 属性的时，如果操作 private 修饰的成员，需要加上 </p><pre><code>field.setAccessible(true);</code></pre><h3 id="Method-操作"><a href="#Method-操作" class="headerlink" title="Method 操作"></a>Method 操作</h3><p>Method 对应普通类的方法。<br>我们看看一般普通类的方法的构成。</p><pre><code>public int add(int a,int b);</code></pre><p>方法由下面几个要素构成：</p><ul><li>方法名</li><li>方法参数</li><li>方法返回值</li><li>方法的修饰符</li><li>方法可能会抛出的异常</li></ul><p><strong>Method 获取方法名</strong></p><pre><code>class.getDeleclaredMethods();</code></pre><p><strong>Method 获取方法参数</strong></p><pre><code>//返回的是一个 Parameter 数组public Parameter[] getParameters() {}// 获取所有的参数类型public Class&lt;?&gt;[] getParameterTypes() {}// 获取所有的参数类型，包括泛型public Type[] getGenericParameterTypes() {}</code></pre><p>返回的是一个 Parameter 数组，在反射中 Parameter 对象就是用来映射方法中的参数。经常使用的<br>Parameter.java 类中的方法</p><pre><code>// 获取参数名字public String getName() {}// 获取参数类型public Class&lt;?&gt; getType() {}// 获取参数的修饰符public int getModifiers() {}</code></pre><p><strong>Method 获取返回值类型</strong></p><pre><code>// 获取返回值类型public Class&lt;?&gt; getReturnType() {}// 获取返回值类型包括泛型public Type getGenericReturnType() {}</code></pre><p><strong>Method 获取修饰符</strong></p><pre><code>public int getModifiers() {}</code></pre><p><strong>Method 获取异常类型</strong></p><pre><code>public Class&lt;?&gt;[] getExceptionTypes() {}public Type[] getGenericExceptionTypes() {}</code></pre><p><strong>Method 方法的执行</strong> </p><p>这个应该是整个反射机制的核心内容了，很多时候运用反射目的其实就是为了以常规手段执行 Method。</p><pre><code>public Object invoke(Object obj, Object... args) {}</code></pre><p>Method 调用 invoke() 的时候，存在许多细节：</p><ul><li><p>invoke() 方法中第一个参数 Object 实质上是 Method 所依附的 Class 对应的类的实例，如果这个方法是一个<strong>静态方法</strong>，那么 ojb 为 null，后面的可变参数 Object 对应的自然就是参数。</p></li><li><p>invoke() 返回的对象是 Object，所以实际上执行的时候要进行强制转换。</p></li><li><p>在对 Method 调用 invoke() 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 InvocationTargetException。而通过 InvocationTargetException.getCause() 可以获取真正的异常。</p></li></ul><h3 id="Constructor-的操作"><a href="#Constructor-的操作" class="headerlink" title="Constructor 的操作"></a>Constructor 的操作</h3><p>Constructor 同 Method 差不多，但是它特别的地方在于，它能够创建一个对象。</p><p>在 Java 反射机制中有两种方法可以用来创建类的对象实例：Class.newInstance() 和 Constructor.newInstance()。官方文档建议开发者使用后面这种方法，下面是原因。</p><ul><li>Class.newInstance() 只能调用无参的构造方法，而 Constructor.newInstance() 则可以调用任意的构造方法。</li><li>Class.newInstance() 通过构造方法直接抛出异常，而 Constructor.newInstance() 会把抛出来的异常包装到 InvocationTargetException 里面去，这个和 Method 行为一致。</li><li>Class.newInstance() 要求构造方法能够被访问，而 Constructor.newInstance() 却能够访问 private 修饰的构造器。</li></ul><h3 id="反射中的数组"><a href="#反射中的数组" class="headerlink" title="反射中的数组"></a>反射中的数组</h3><p>数组本质上是一个 Class，而在 Class 中存在一个方法用来识别它是否为一个数组。<br>在 Class.java 中 方法 <code>isArray()</code> 判断是否是数组<br>由于 数组本质上 还是 Class 所以可以通过 </p><pre><code>getName();//获取数组的里面的元素的类型，比如 int[] 数组的 componentType 自然就是 intgetComponentType();</code></pre><p><strong>动态创建数组*</strong><br>反射创建数组通过 Array.newInstance() 这个方法。</p><pre><code>public static Object newInstance(Class&lt;?&gt; componentType, int... dimensions)        throws IllegalArgumentException, NegativeArraySizeException {}</code></pre><p>第一个参数 为数组内原始类型，后面的是可变参数，表示的是相应维度的数组长度限制。<br>比如创建一个 二维数组 <code>Array.newInstance(int.class,2,3);</code></p><p><strong>Array 的读取与赋值</strong></p><ol><li>对Array 整体的赋值和读取<br><code>`</code><br>public void set(Object obj,<pre><code>         Object value)  throws IllegalArgumentException,         IllegalAccessException;</code></pre></li></ol><p>public Object get(Object obj)<br>           throws IllegalArgumentException,<br>                  IllegalAccessException;</p><pre><code>2. 对 Array 指定位置进行赋值和读取,经典的几种方式分别为：</code></pre><p>public static void set(Object array,<br>                       int index,<br>                       Object value)<br>                throws IllegalArgumentException,<br>                       ArrayIndexOutOfBoundsException;</p><p>public static void setBoolean(Object array,<br>                              int index,<br>                              boolean z)<br>                       throws IllegalArgumentException,<br>                              ArrayIndexOutOfBoundsException;</p><p>public static Object get(Object array,<br>                         int index)<br>                  throws IllegalArgumentException,<br>                         ArrayIndexOutOfBoundsException;</p><p>public static short getShort(Object array,<br>                             int index)<br>                      throws IllegalArgumentException,<br>                             ArrayIndexOutOfBoundsException;</p><pre><code>### 反射中的枚举 enum同数组一样本质上还是一个 Class 而已。枚举的表现形式：</code></pre><p>public enum State {<br>    IDLE,<br>    DRIVING,<br>    STOPPING,</p><pre><code>test();int test1() {    return 0;}</code></pre><p>}</p><pre><code>在 java 反射 中，可以把枚举看成一般的Class,但是反射机制提供了3个特别的 API 用于操作枚举。</code></pre><p>//判断是否是枚举类型<br>Class.isEnum()<br>//获取枚举所有的常量<br>Class.getEnumConstants()<br>//判断一个 Field 是不是枚举常量<br>java.lang.reflect.Field.isEnumConstant()</p><p><code>`</code></p><p><strong>枚举的获取与设置</strong><br>因为等同于 Class， 所以 枚举的获取与设置，可以 通过 Field 中的get() 和 set() 方法。</p><p>需要注意的是，如果要获取枚举里面的Field、Method、Constructor  可以调用 Class 的通用 API.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Java 中的反射是非常规编码方式。</li><li>Java 反射机制的操作入口是获取 Class 文件。 有 Class.forName()、 .class 和 Object.getClass() 3 种。</li><li>获取 Class 对象后还不够，需要获取它的 Members，包含 Field、Method、Constructor。</li><li>Field 操作主要涉及到类别的获取，及数值的读取与赋值。</li><li>Method 算是反射机制最核心的内容，通常的反射都是为了调用某个 Method 的 invoke() 方法。</li><li>通过 Class.newInstance() 和 Constructor.newInstance() 都可以创建类的对象实例，但推荐后者。因为它适应于任何构造方法，而前者只会调用可见的无参数的构造方法。</li><li>数组和枚举可以被看成普通的 Class 对待。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/briblue/article/details/74616922&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考博客网址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;反射入口&quot;&gt;&lt;a href=&quot;#反射
      
    
    </summary>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java  注解</title>
    <link href="https://brokge.github.io/2019/08/30/Java-%E6%B3%A8%E8%A7%A3/"/>
    <id>https://brokge.github.io/2019/08/30/Java-注解/</id>
    <published>2019-08-30T12:44:41.000Z</published>
    <updated>2019-08-30T12:53:01.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。</p><h3 id="一-、注解分类"><a href="#一-、注解分类" class="headerlink" title="一 、注解分类"></a>一 、注解分类</h3><ol><li><p><strong>java 内置注解</strong> </p><p>@Override、 @Deprecated、@SuppressWarnings、@SafeVarargs(jdk 7 新增)</p></li><li><p><strong>标注注解的元注解</strong></p></li></ol><p>它是用来修饰注解的注解，从而创建新的注解。</p><ul><li>@Target, 说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目的。</li><li>@Retention, 定义了该Annotation被保留的时间长短，SOURCE、CLASS、RUNTIME（可通过反射获取内部属性）。</li><li>@Documented, 标记注解，可以工具文档化。</li><li>@Inherited 当前注解是否可以继承。</li><li>@Repeatable: JDK 8 新增，允许一个注解在同一声明类型（类、属性或方法）上多次使用。</li></ul><p><strong>@Targe</strong> 注解取值是一个 ElementType 类型的数组。</p><table><thead><tr><th>ElementType</th><th>说明</th></tr></thead><tbody><tr><td>- ElementType.TYPE</td><td>修饰类、接口或枚举类型。</td></tr><tr><td>- ElementType.FIELD</td><td>修饰成员变量。</td></tr><tr><td>- ElementType.METHOD</td><td>修饰方法。</td></tr><tr><td>- ElementType.PARAMETER</td><td>修饰参数。</td></tr><tr><td>- ElementType.CONSTRUCTOR</td><td>修饰构造方法。</td></tr><tr><td>- ElementType.LOCAL_VARIABLE</td><td>修饰局部变量。</td></tr><tr><td>- ElementType.ANNOTATION_TYPE</td><td>修饰注解。</td></tr><tr><td>- ElementType.PACKAGE</td><td>修饰包。</td></tr><tr><td>- ElementType.TYPE_PARAMETER</td><td>修饰参数声明。</td></tr><tr><td>- ElementType.TYOPE_USR</td><td>使用类型。</td></tr></tbody></table><p><strong>@Retention</strong> 3种类型，分别表示不同的保留周期</p><ul><li><strong>RetentionPolicy.SOURCE</strong>:源码级注解。<blockquote><p>注解信息只会保留在.java 源码中，源码在编译后，注解信息会被丢弃，不会保留到.class 中。</p></blockquote></li><li><strong>RetentionPolicy.CLASS</strong>:编译时注解。<blockquote><p>注解信息会保留在.java 源码以及.class 中。当运行java 程序时，JVM 会丢弃该注解信息，不会保留到 JVM 中。</p></blockquote></li><li><strong>RetentionPolicy.RUNTIME</strong>:运行时注解。<blockquote><p>当运行 java 程序时，JVM 也会保留该注解信息，可以通过反射获取该注解信息。</p></blockquote></li></ul><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p><strong>1. 基本定义</strong></p><p>定义新的注解类型使用 @interface 关键字。</p><pre><code>public @interface Cup{}</code></pre><p>程序中使用该注解：</p><pre><code>@Cuppublic class AnnotationTest{}</code></pre><p><strong>2. 定义成员变量(注解的属性)</strong></p><p>注解 只有成员变量，没有方法。注解的成员变量在注解定义中以“无形参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型；</p><pre><code>public @interface Cup{    String name();    int price();}</code></pre><p>上面两个成员变量以方法的形式来定义。使用该注解时候就应该为该成员变量赋值</p><pre><code>pubilc class AnnotationTest(){    @Cup(name=&quot;马克杯&quot;,price=100)    public void drink(){    }}</code></pre><p>也可以在定义注解的时候通过 default 来指定默认值：</p><pre><code>public @interface Cup{   String name() default &quot;马克杯&quot;;   int price() default 100;}</code></pre><p><strong>3. 定义运行时注解</strong></p><p>使用@Retention 来设定注解的保留策略 ，这三哥策略的生命周期长度为：SOURCE&lt;CLASS&lt;RUNTIME.</p><pre><code>@Retention(RetentionPolicy.RUNTIME)public @interface Cup{    String name() default &quot;马克杯&quot;;    int price() default 100;}</code></pre><p><strong>4. 定义编译时注解</strong></p><pre><code>@Retention(RetentionPolicy.CLASS)public @interface Cup{    String name() default &quot;马克杯&quot;;    int price() default 100;}</code></pre><p><strong>5. Repeatable 定义可重复注解</strong></p><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><pre><code>@interface Persons {    Person[]  value();}@Repeatable(Persons.class)@interface Person{    String role default &quot;&quot;;}@Person(role=&quot;artist&quot;)@Person(role=&quot;coder&quot;)@Person(role=&quot;PM&quot;)public class SuperMan{}</code></pre><p>注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>以下代码中就是相关容器注解。</p><pre><code>@interface Persons {    Person[]  value();}</code></pre><h3 id="二、注解的提取"><a href="#二、注解的提取" class="headerlink" title="二、注解的提取"></a>二、注解的提取</h3><p>注解通过反射获取。<br>首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p><pre><code>public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {}</code></pre><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p><pre><code>public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {}</code></pre><p>或者是 getAnnotations() 方法。</p><pre><code>public Annotation[] getAnnotations() {}</code></pre><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p><p>在处理的注解的过程中可能会用到以下方法</p><pre><code>Field getDeclaredField(String attrbuteName);Method getDeclaredMethod(String methodName);</code></pre><h3 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h3><p>注解： 使用场景 分为 三类：<br>编译前、<br>编译时生成代码、<br>运行时。</p><p>运行时注解：<br>例如：ButterKnife ，黑科技、低性能</p><p>编译时注解：<br>Dagger2：生成中间代码，所以性能高</p><p>注解处理器：<br>编译时处理器、<br>运行时处理器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h2&gt;&lt;p&gt;注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。&lt;/p&gt;
&lt;h3 id=&quot;一-、注解分类&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://brokge.github.io/2019/01/08/hello-world/"/>
    <id>https://brokge.github.io/2019/01/08/hello-world/</id>
    <published>2019-01-08T03:02:23.000Z</published>
    <updated>2019-01-08T03:02:36.695Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java枚举六问</title>
    <link href="https://brokge.github.io/2019/01/06/Java%E6%9E%9A%E4%B8%BE%E5%85%AD%E9%97%AE/"/>
    <id>https://brokge.github.io/2019/01/06/Java枚举六问/</id>
    <published>2019-01-06T07:26:00.000Z</published>
    <updated>2019-01-08T02:45:21.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一问：Java-枚举是如何保证线程安全的？"><a href="#一问：Java-枚举是如何保证线程安全的？" class="headerlink" title="一问：Java 枚举是如何保证线程安全的？"></a>一问：Java 枚举是如何保证线程安全的？</h3><blockquote><p>答：因为 Java 类加载与初始化是 JVM 保证线程安全，而 Java enum 枚举在编译器编译后的字节码实质是一个 final 类，每个枚举类型是这个 final 类中的一个静态常量属性，其属性初始化是在该 final 类的 static 块中进行，而 static 的常量属性和代码块都是在类加载时初始化完成的，所以自然就是 JVM 保证了并发安全。（不清楚 enum 编译后为啥是静态常量的可以查看历史推送了解更多）</p></blockquote><h3 id="二问：不使用-synchronized-和-lock如何创建一个线程安全的单例？"><a href="#二问：不使用-synchronized-和-lock如何创建一个线程安全的单例？" class="headerlink" title="二问：不使用 synchronized 和 lock如何创建一个线程安全的单例？"></a>二问：不使用 synchronized 和 lock如何创建一个线程安全的单例？</h3><blockquote><p>答：这是一个很 open 的题目，我们平时提到单例并发都是用锁机制，实际抛开锁机制也有几种实现方式可以保证创建单例的并发安全，而且各具特色。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过枚举实现单例模式</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过饿汉模式实现单例</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过静态内部类模式实现单例</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 通过 CAS（AtomicReference）实现单例模式</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> AtomicReference<span class="token operator">&lt;</span>Singleton<span class="token operator">></span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicReference</span><span class="token operator">&lt;</span>Singleton<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Singleton singleton <span class="token operator">=</span> INSTANCE<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> singleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> singleton<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>可以看到，上面四种方式都可以不使用 synchronized 或者 lock 来保证了单例创建的并发安全。前面三种都是借助了 JVM 的 ClassLoader 类加载初始化保证并发安全的机制（至于 JVM 底层其实也是使用了 synchronized 或者 lock 的机制），而对于最后一种通过 CAS 机制保证了并发安全（至于什么是 CAS 我们后面并发相关每日一题会再详细推送讨论的，这里先记住 CAS 就是一种非阻塞乐观锁机制，是一种基于忙等待的算法，依赖底层硬件实现，相对于锁其没有线程切换和阻塞的额外消耗，但是如果忙等待一直执行不成功的死循环会对 CPU 造成较大的开销），最后一种才是真正的无锁实现。</p></blockquote><h3 id="四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？"><a href="#四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？" class="headerlink" title="四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？"></a>四问：为什么有人说在一些场景下通过枚举实现的单例是最好的方式，原因是什么？</h3><blockquote><p>答：其实这个题目算是一箭双雕，既考察了 Java 枚举的实质特性又考察了单例模式的一些弊端问题。除过枚举实现的单例模式以外的其他实现方式都有一个比较大的问题是一旦实现了 Serializable 接口后就不再是单例了，因为每次调用 readObject() 方法返回的都是一个新创建出来的对象（当然可以通过使用 readResolve() 方法来避免，但是终归麻烦），而 Java 规范中保证了每一个枚举类型及其定义的枚举变量在 JVM 中都是唯一的，在枚举类型的序列化和反序列化上 Java 做了特殊处理，序列化时 Java 仅仅是将枚举对象的 name 属性输出到结果中，反序列化时则是通过 java.lang.Enum 的 valueOf 方法来根据名字查找枚举对象，同时禁用了 writeObject、readObject、readObjectNoData、writeReplace 和 readResolve 等方法。<br>这个问题也暴露出另一个新问题，Java 枚举序列化有哪些坑？</p></blockquote><h3 id="五问：Java-枚举序列化有哪些坑？"><a href="#五问：Java-枚举序列化有哪些坑？" class="headerlink" title="五问：Java 枚举序列化有哪些坑？"></a>五问：Java 枚举序列化有哪些坑？</h3><blockquote><p>答：如果我们枚举被序列化本地持久化了，那我们就不能删除原来枚举类型中定义的任何枚举对象，否则程序在运行过程中反序列化时 JVM 就会找不到与某个名字对应的枚举对象了，所以我们要尽量避免多枚举对象序列化的使用（当然了，枚举实现的单例枚举对象一般都不会增删改，所以不存在问题）。</p></blockquote><h3 id="六问：Java-迭代器和枚举器的区别是什么？"><a href="#六问：Java-迭代器和枚举器的区别是什么？" class="headerlink" title="六问：Java 迭代器和枚举器的区别是什么？"></a>六问：Java 迭代器和枚举器的区别是什么？</h3><blockquote><p>答：主要区别如下。<br>Enumeration<e> 枚举器接口是 JDK 1.0 提供的，适用于传统类，而 Iterator<e> 迭代器接口是 JDK 1.2 提供的，适用于 Collections。<br>Enumeration 只有两个方法接口，我们只能读取集合的数据而不能对数据进行修改，而 Iterator 有三个方法接口，除了能读取集合的数据外也能对数据进行删除操作。<br>Enumeration 不支持 fail-fast 机制，而 Iterator 支持 fail-fast 机制（一种错误检测机制，当多线程对集合进行结构上的改变的操作时就有可能会产生 fail-fast 机制，譬如 ConcurrentModificationException 异常）。<br>总归现在尽量使用 Iterator 迭代器而不是 Enumeration 枚举器。</e></e></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一问：Java-枚举是如何保证线程安全的？&quot;&gt;&lt;a href=&quot;#一问：Java-枚举是如何保证线程安全的？&quot; class=&quot;headerlink&quot; title=&quot;一问：Java 枚举是如何保证线程安全的？&quot;&gt;&lt;/a&gt;一问：Java 枚举是如何保证线程安全的？&lt;/
      
    
    </summary>
    
      <category term="知识库" scheme="https://brokge.github.io/categories/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android  线程池</title>
    <link href="https://brokge.github.io/2019/01/06/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://brokge.github.io/2019/01/06/线程池/</id>
    <published>2019-01-06T06:46:00.000Z</published>
    <updated>2019-01-08T03:41:27.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-线程池特点"><a href="#Android-线程池特点" class="headerlink" title="Android  线程池特点"></a>Android  线程池特点</h2><ol><li><code>Thread()</code>,<code>AsyncTask</code>适合处理单个任务的场景，<code>HandlerThread</code>适合串行处理多任务的场景。当需要并行的处理多任务之时，<code>ThreadPoolExecutor</code>是更好的选择。</li><li>线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。</li><li><code>ThreadPool</code>较之<code>HandlerThread</code>在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。</li></ol><ul><li><strong>常用创建线程池的方式 </strong></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">//...</span>                          <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>具体参数代表的信息，可文章底部的说明。</p></blockquote><ul><li><strong>线程池的分配遵循这样的规则</strong></li></ul><blockquote><ol><li>当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；</li><li>如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；</li><li>如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；</li><li>如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且<code>ThreadPoolExecutor</code>会调用<code>RejectedtionHandler</code>的<code>rejectedExecution</code>方法来通知调用者。</li></ol></blockquote><h2 id="实践场景"><a href="#实践场景" class="headerlink" title="实践场景"></a>实践场景</h2><p>从我们现实的业务种，所用到的场景是大同小异。所以官方准备了几个不同类型的线程池。通过工厂方法创建以下类型：</p><h5 id="1-newFixThreadPool"><a href="#1-newFixThreadPool" class="headerlink" title="1. newFixThreadPool"></a>1. newFixThreadPool</h5><p>通过<code>Executors</code>的<code>newFixedThreadPool()</code>方法创建，它是个线程数量固定的线程池，该线程池的线程全部为核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//todo somthing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-newCachedThreadPool"><a href="#2-newCachedThreadPool" class="headerlink" title="2. newCachedThreadPool"></a>2. newCachedThreadPool</h5><p>通过<code>Executors</code>的<code>newCachedThreadPool()</code>方法来创建，它是一个数量无限多的线程池，它所有的线程都是非核心线程，当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以此线程池适合执行大量耗时小的任务。由于设置了超时时间为60s，所以当线程空闲一定时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token keyword">new</span> <span class="token class-name">CachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>        <span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码：</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">CachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//todo somthing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-newScheduledThreadPool"><a href="#3-newScheduledThreadPool" class="headerlink" title="3. newScheduledThreadPool"></a>3. newScheduledThreadPool</h5><p>通过<code>Executors</code>的<code>newScheduledThreadPool()</code>方法来创建，<code>ScheduledThreadPool</code>线程池像是上两种的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ScheduledThreadPool <span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">,</span>          <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码：</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//todo somthing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-newSingleThreadExecutor"><a href="#4-newSingleThreadExecutor" class="headerlink" title="4. newSingleThreadExecutor"></a>4. newSingleThreadExecutor</h5><p>通过<code>Executors</code>的<code>newSingleThreadExecutor()</code>方法来创建，它内部只有一个核心线程，它确保所有任务进来都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让调用者可以忽略线程同步问题。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span><span class="token punctuation">(</span>        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>        <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>         <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码：</p><pre class="line-numbers language-java"><code class="language-java">ExecutorService mExecutor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Runnable runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Override</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//todo somthing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>mExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><code>ExecutorService</code></h3><p>通过以上代码我们可以看出，所返回的皆是 <code>ExecutorService</code>，一个接口且继承于 <code>Executor</code>;</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接口方法：</p><ol><li><code>shutDown()</code>，关闭线程池，需要执行完已提交的任务；</li><li><code>shutDownNow()</code>，关闭线程池，并尝试结束已提交的任务；</li><li><code>allowCoreThreadTimeOut(boolen)</code>，允许核心线程闲置超时回收；</li><li><code>execute()</code>，提交任务无返回值； </li><li><code>submit()</code>，提交任务有返回值；</li></ol><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><blockquote><ol><li><code>corePoolSize</code>：核心线程数，如果运行的线程少于<code>corePoolSize</code>，则创建新线程来执行新任务，即使线程池中的其他线程是空闲的</li><li><code>maximumPoolSize</code>:最大线程数，可允许创建的线程数，<code>corePoolSize</code>和<code>maximumPoolSize</code>设置的边界自动调整池大小：</li><li><code>corePoolSize</code> &lt;运行的线程数&lt; <code>maximumPoolSize</code>:仅当队列满时才创建新线程<br><code>corePoolSize</code>=运行的线程数= <code>maximumPoolSize</code>：创建固定大小的线程池</li><li><code>keepAliveTime</code>:如果线程数多于<code>corePoolSize</code>,则这些多余的线程的空闲时间超过<code>keepAliveTime</code>时将被终止</li><li><code>unit</code>:<code>keepAliveTime</code>参数的时间单位</li><li><code>workQueue</code>:保存任务的阻塞队列，与线程池的大小有关：当运行的线程数少于<code>corePoolSize</code>时，在有新任务时直接创建新线程来执行任务而无需再进队列； 当运行的线程数等于或多于<code>corePoolSize</code>，在有新任务添加时则选加入队列，不直接创建线程； 当队列满时，在有新任务时就创建新线程</li><li><code>threadFactory</code>:使用<code>ThreadFactory</code>创建新线程，默认使用<code>defaultThreadFactory</code>创建线程</li><li><code>handle</code>:定义处理被拒绝任务的策略，默认使用<code>ThreadPoolExecutor.AbortPolicy</code>,任务被拒绝时将抛出<code>RejectExecutorException</code></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android-线程池特点&quot;&gt;&lt;a href=&quot;#Android-线程池特点&quot; class=&quot;headerlink&quot; title=&quot;Android  线程池特点&quot;&gt;&lt;/a&gt;Android  线程池特点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Thread()&lt;/co
      
    
    </summary>
    
      <category term="Android" scheme="https://brokge.github.io/categories/Android/"/>
    
    
      <category term="并发编程" scheme="https://brokge.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>正则</title>
    <link href="https://brokge.github.io/2019/01/05/%E6%AD%A3%E5%88%99/"/>
    <id>https://brokge.github.io/2019/01/05/正则/</id>
    <published>2019-01-05T11:37:00.000Z</published>
    <updated>2019-08-30T12:52:48.403Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式在几乎所有语言中都可以使用，无论是前端的 JavaScript、还是后端的 Java、c#。他们都提供相应的接口函数支持正则表达式。</p><p>但很神奇的是：无论你大学选择哪一门计算机语言，都没有关于正则表达式的课程给你修，在你学会正则之前，你只能看着那些正则大师们，写了一串外星文似的字符串，替代了你用一大篇幅的 if else代码来做一些数据校验。</p><p>既然喜欢，那就动手学呗，可当你百度出一一堆相关资料时，你发现无一不例外的枯燥至极，难以学习（实话说，当年不理君也是这样的心态😂😂）。</p><p>下面，不理君尝试用一种比较通俗点的方式讲一下正则，让你能在读完之后，能自己写出一些简单的正则，再不济，能看懂别人写的正则，那也不错了。</p><h1 id="一、元字符"><a href="#一、元字符" class="headerlink" title="一、元字符"></a>一、元字符</h1><p>万物皆有缘，正则也是如此，元字符是构造正则表达式的一种基本元素。<br>我们先来记几个常用的元字符：</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串结束</td></tr></tbody></table><p>有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，</p><p>比如：</p><ol><li>匹配有abc开头的字符串：<pre class="line-numbers language-bash"><code class="language-bash">\babc或者^abc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>匹配8位数字的QQ号码：<pre class="line-numbers language-bash"><code class="language-bash">^\d\d\d\d\d\d\d\d$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>匹配1开头11位数字的手机号码：<pre class="line-numbers language-bash"><code class="language-bash">^1\d\d\d\d\d\d\d\d\d\d$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="二、重复限定符"><a href="#二、重复限定符" class="headerlink" title="二、重复限定符"></a>二、重复限定符</h1><p>有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？</p><p>答案是有的！</p><p>为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：</p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><p>有了这些限定符之后，我们就可以对之前的正则表达式进行改造了。</p><p>比如：</p><ol><li>匹配8位数字的QQ号码：<pre class="line-numbers language-bash"><code class="language-bash">^\d<span class="token punctuation">{</span>8<span class="token punctuation">}</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>匹配1开头11位数字的手机号码：<pre class="line-numbers language-bash"><code class="language-bash">^1\d<span class="token punctuation">{</span>10<span class="token punctuation">}</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>匹配银行卡号是14~18位的数字：<pre class="line-numbers language-bash"><code class="language-bash">^\d<span class="token punctuation">{</span>14,18<span class="token punctuation">}</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>匹配以a开头的，0个或多个b结尾的字符串<pre class="line-numbers language-bash"><code class="language-bash">^ab*$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="三、-分组"><a href="#三、-分组" class="headerlink" title="三、 分组"></a>三、 分组</h1><p>从上面的例子（4）中看到，限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要 ab 同时被限定那怎么办呢？</p><p><strong>正则表达式中用小括号 <code>()</code> 来做分组，也就是括号中的内容作为一个整体。</strong></p><p>因此当我们要匹配多个 ab 时，我们可以这样。<br>如：</p><ol><li>匹配字符串中包含 0 到多个 ab 开头：<pre class="line-numbers language-bash"><code class="language-bash">^<span class="token punctuation">(</span>ab<span class="token punctuation">)</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="四、-转义"><a href="#四、-转义" class="headerlink" title="四、 转义"></a>四、 转义</h1><p>我们看到正则表达式用小括号来做分组。</p><p>那么问题来了：<br>如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？</p><p>针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。<br>如：</p><ol><li>要匹配以 (ab) 开头：<pre class="line-numbers language-bash"><code class="language-bash">1 ^<span class="token punctuation">(</span>\<span class="token punctuation">(</span>ab\<span class="token punctuation">))</span>*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="五、-条件或"><a href="#五、-条件或" class="headerlink" title="五、 条件或"></a>五、 条件或</h1><p>回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有 130/131/132/155/156/185/186/145/176 等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？</p><p><strong>正则用符号 | 来表示或，也叫做分支条件</strong>，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。<br>那么我们就可以用或条件来处理这个问题：</p><pre class="line-numbers language-bash"><code class="language-bash">^<span class="token punctuation">(</span>130<span class="token operator">|</span>131<span class="token operator">|</span>132<span class="token operator">|</span>155<span class="token operator">|</span>156<span class="token operator">|</span>185<span class="token operator">|</span>186<span class="token operator">|</span>145<span class="token operator">|</span>176<span class="token punctuation">)</span>\d<span class="token punctuation">{</span>8<span class="token punctuation">}</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="六、区间"><a href="#六、区间" class="headerlink" title="六、区间"></a>六、区间</h1><p>看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？</p><p>实际是有的。</p><p><strong>正则提供一个元字符中括号 [] 来表示区间条件。</strong></p><p>限定 0 到 9 可以写成 <code>[0-9]</code></p><p>限定 A-Z 写成 <code>[A-Z]</code></p><p>限定某些数字 <code>[165]</code></p><p>那上面的正则我们还改成这样：</p><pre class="line-numbers language-bash"><code class="language-bash"> ^<span class="token punctuation">((</span>13<span class="token punctuation">[</span>0-2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>15<span class="token punctuation">[</span>56<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>18<span class="token punctuation">[</span>5-6<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span>145<span class="token operator">|</span>176<span class="token punctuation">)</span>\d<span class="token punctuation">{</span>8<span class="token punctuation">}</span>$<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="七、零宽断言"><a href="#七、零宽断言" class="headerlink" title="七、零宽断言"></a>七、零宽断言</h1><p>无论是零宽还是断言，听起来都古古怪怪的，那先解释一下这两个词。</p><p><strong>断言</strong>：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”, 正则可以用断言找出 aa2 前面有 bb3，也可以找出 aa2 后面有 ss1.</p><p><strong>零宽</strong>：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</p><p>意思是讲明白了，那他有什么用呢？<br>我们来举个栗子：<br>假设我们要用爬虫抓取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构。</p><pre class="line-numbers language-html"><code class="language-html">"<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read-count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>阅读数：641<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中只有‘<strong>641</strong>’这个是一个变量，也就是不同文章有不同的值，当我们拿到这个字符串时，需要获得这里边的‘<strong>641</strong>’有很多种办法，但如果使用正则应该怎么匹配呢？</p><p>下面先讲一下几种类型的断言：</p><h3 id="1-正向先行断言（正前瞻）"><a href="#1-正向先行断言（正前瞻）" class="headerlink" title="1. 正向先行断言（正前瞻）"></a>1. 正向先行断言（正前瞻）</h3><p><strong>语法</strong>：<code>（?=pattern）</code></p><p><strong>作用</strong>：++匹配 pattern 表达式的前面内容，不返回本身。++<br>这样子说，还是一脸懵逼，好吧，回归刚才那个栗子，要取到阅读量，在正则表达式中就意味着要能匹配到<code>&lt;/span&gt;</code>前面的数字内容按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是:<code>(?=&lt;/span&gt;)</code> 就可以匹配到前面的内容了。匹配什么内容呢？如果要所有内容那就是：</p><pre class="line-numbers language-java"><code class="language-java"> String reg<span class="token operator">=</span><span class="token string">".+(?=&lt;/span>)"</span><span class="token punctuation">;</span> String test <span class="token operator">=</span> <span class="token string">"&lt;span class=\"read-count\">阅读数：641&lt;/span>"</span><span class="token punctuation">;</span> Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span> Matcher mc<span class="token operator">=</span>    pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token punctuation">)</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-html"><code class="language-html"># 匹配结果：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>read-count<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>阅读数：641<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可是老哥我们要的只是前面的数字呀，那也简单咯，匹配数字 <code>\d</code>, 那可以改成：</p><pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"\\d+(?=&lt;/span>)"</span><span class="token punctuation">;</span>String test <span class="token operator">=</span> <span class="token string">"&lt;span class=\"read-count\">阅读数：641&lt;/span>"</span><span class="token punctuation">;</span>Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher mc<span class="token operator">=</span>    pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre><code>//匹配结果：641</code></pre><p>大功告成！</p><h3 id="2-正向后行断言（正后顾）"><a href="#2-正向后行断言（正后顾）" class="headerlink" title="2. 正向后行断言（正后顾）"></a>2. 正向后行断言（正后顾）</h3><p><strong>语法</strong>：<code>（?&lt;=pattern）</code></p><p><strong>作用</strong>：匹配 pattern表达式的后面的内容，不返回本身。</p><p>有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容啦。</p><p>上面的栗子，我们也可以用后行断言来处理：</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token punctuation">(</span>?<span class="token operator">&lt;=</span><span class="token operator">&lt;</span>span class<span class="token operator">=</span><span class="token string">"read-count"</span><span class="token operator">></span>阅读数：<span class="token punctuation">)</span>\d+ String reg<span class="token operator">=</span><span class="token string">"(?&lt;=&lt;span class=\"read-count\">阅读数：)\\d+"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"> String test <span class="token operator">=</span> <span class="token string">"&lt;span class=\"read-count\">阅读数：641&lt;/span>"</span><span class="token punctuation">;</span> Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span> Matcher mc<span class="token operator">=</span>    pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 输出</p><pre><code># 匹配结果：641</code></pre><p>就这么简单。</p><h3 id="3-负向先行断言（负前瞻）"><a href="#3-负向先行断言（负前瞻）" class="headerlink" title="3. 负向先行断言（负前瞻）"></a>3. 负向先行断言（负前瞻）</h3><p><strong>语法</strong>：<code>(?!pattern)</code></p><p><strong>作用</strong>：匹配非 pattern 表达式的前面内容，不返回本身。</p><p>有正向也有负向，负向在这里其实就是非的意思。</p><blockquote><p>举个栗子：比如有一句 “我爱祖国，我是祖国的花朵”<br>现在要找到不是’的花朵’前面的祖国</p></blockquote><p>用正则就可以这样写：</p><pre class="line-numbers language-bash"><code class="language-bash">祖国<span class="token punctuation">(</span>?<span class="token operator">!</span>的花朵<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-负向后行断言（负后顾）"><a href="#4-负向后行断言（负后顾）" class="headerlink" title="4. 负向后行断言（负后顾）"></a>4. 负向后行断言（负后顾）</h3><p><strong>语法</strong>：<code>(?&lt;!pattern)</code></p><p><strong>作用</strong>：匹配非 pattern</p><p>表达式的后面内容，不返回本身。</p><h1 id="八、捕获和非捕获"><a href="#八、捕获和非捕获" class="headerlink" title="八、捕获和非捕获"></a>八、捕获和非捕获</h1><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”。</p><p><strong>捕获组</strong>：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p><p>而根据命名方式的不同，又可以分为两种组：</p><h3 id="1-数字编号捕获组："><a href="#1-数字编号捕获组：" class="headerlink" title="1. 数字编号捕获组："></a>1. 数字编号捕获组：</h3><p><strong>语法</strong>：<code>(exp)</code></p><p><strong>解释</strong>：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第 0 组为整个表达式，第一组开始为分组。<br>比如固定电话的：020-85653333<br>他的正则表达式为：(0\d{2})-(\d{8})<br>按照左括号的顺序，这个表达式有如下分组：</p><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>1</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>2</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><p>我们用Java来验证一下：</p><pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"020-85653333"</span><span class="token punctuation">;</span>String reg<span class="token operator">=</span><span class="token string">"(0\\d{2})-(\\d{8})"</span><span class="token punctuation">;</span>Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分组的个数有："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"个分组为："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>分组的个数有：2第0个分组为：020-85653333第1个分组为：020第2个分组为：85653333</code></pre><p>可见，分组个数是2，但是因为第0个为整个表达式本身，因此也一起输出了。</p><h3 id="2-命名编号捕获组"><a href="#2-命名编号捕获组" class="headerlink" title="2. 命名编号捕获组"></a>2. 命名编号捕获组</h3><p><strong>语法</strong>：<code>(?&lt;name&gt;exp)</code></p><p><strong>解释</strong>：分组的命名由表达式中的 name 指定<br>比如区号也可以这样写:<code>(?&lt;quhao&gt;\0\d{2})-(?&lt;haoma&gt;\d{8})</code>，按照左括号的顺序，这个表达式有如下分组：</p><table><thead><tr><th>序号</th><th>名称</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>quhao</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>haoma</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table><p>用代码来验证一下：</p><pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"020-85653333"</span><span class="token punctuation">;</span>String reg<span class="token operator">=</span><span class="token string">"(?&lt;quhao>0\\d{2})-(?&lt;haoma>\\d{8})"</span><span class="token punctuation">;</span>Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分组的个数有："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">"quhao"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token string">"haoma"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>分组的个数有：2分组名称为:quhao,匹配内容为：020分组名称为:haoma,匹配内容为：85653333</code></pre><h3 id="3-非捕获组"><a href="#3-非捕获组" class="headerlink" title="3. 非捕获组"></a>3. 非捕获组</h3><p><strong>语法</strong>：<code>(?:exp)</code></p><p><strong>解释</strong>：和捕获组刚好相反，它用来标识那些不需要捕获的分组，说的通俗一点，就是你可以根据需要去保存你的分组。</p><p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：</p><pre><code>(?:\0\d{2})-(\d{8})</code></pre><p>序号    |编号    |分组    |内容<br>0    |0    |(0\d{2})-(\d{8})    |020-85653333<br>1    |1    |(\d{8})    |85653333<br>验证一下：</p><pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"020-85653333"</span><span class="token punctuation">;</span>String reg<span class="token operator">=</span><span class="token string">"(?:0\\d{2})-(\\d{8})"</span><span class="token punctuation">;</span>Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"分组的个数有："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> fi<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mc<span class="token punctuation">.</span><span class="token function">groupCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第"</span><span class="token operator">+</span>i<span class="token operator">+</span><span class="token string">"个分组为："</span><span class="token operator">+</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>分组的个数有：1第0个分组为：020-85653333第1个分组为：85653333</code></pre><h1 id="九、-反向引用"><a href="#九、-反向引用" class="headerlink" title="九、 反向引用"></a>九、 反向引用</h1><p>上面讲到捕获，我们知道：捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。</p><p>根据捕获组的命名规则，反向引用可分为：</p><ol><li>数字编号组反向引用：\k 或\number</li><li>命名编号组反向引用：\k 或者\’name’</li></ol><p>好了 讲完了，懂吗？不懂！！！</p><p>可能连前面讲的捕获有什么用都还不懂吧？</p><p>其实只是看完捕获不懂不会用是很正常的！</p><p>因为捕获组通常是和反向引用一起使用的</p><p>上面说到捕获组是匹配子表达式的内容按序号或者命名保存起来以便使用。</p><p>注意两个字眼：“内容” 和 “使用”。<br>这里所说的“内容”，是匹配结果，而不是子表达式本身，强调这个有什么用？嗯，先记住。</p><p>那这里所说的“使用”是怎样使用呢？</p><p>因为它的作用主要是用来查找一些重复的内容或者做替换指定字符。</p><p>还是举栗子吧：</p><p>比如要查找一串字母”aabbbbgbddesddfiid”里成对的字母。</p><p>如果按照我们之前学到的正则，什么区间啊限定啊断言啊可能是办不到的，现在我们先用程序思维理一下思路：</p><blockquote><ol><li>匹配到一个字母</li><li>匹配第下一个字母，检查是否和上一个字母是否一样</li><li>如果一样，则匹配成功，否则失败</li></ol></blockquote><p>这里的思路 2 中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？？？</p><p>这下子捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件。</p><p>好了，有思路就要实践</p><p>首先匹配一个字母：<code>\w</code>，我们需要做成分组才能捕获，因此写成这样：<code>(\w)</code><br>那这个表达式就有一个捕获组：<code>（\w）</code><br>然后我们要用这个捕获组作为条件，那就可以：<code>(\w)\1</code>这样就大功告成了</p><p>可能有人不明白了，<code>\1</code> 是什么意思呢？</p><p>还记得捕获组有两种命名方式吗，一种是是根据捕获分组顺序命名，一种是自定义命名来作为捕获组的命名在默认情况下都是以数字来命名，而且数字命名的顺序是从 1 开始的。</p><p>因此要引用第一个捕获组，根据反向引用的数字命名规则 就需要 <code>\k&lt;1&gt;</code>或者<code>\1</code>，当然，通常都是是后者。</p><p>我们来测试一下：</p><pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"aabbbbgbddesddfiid"</span><span class="token punctuation">;</span>Pattern pattern <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"(\\w)\\1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher mc<span class="token operator">=</span> pattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>mc<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>1aa2bb3bb4dd5dd6ii</code></pre><p>嗯，这就是我们想要的了。</p><p>在举个替换的例子，假如想要把字符串中abc换成a。</p><pre class="line-numbers language-java"><code class="language-java">String test <span class="token operator">=</span> <span class="token string">"abcbbabcbcgbddesddfiid"</span><span class="token punctuation">;</span>String reg<span class="token operator">=</span><span class="token string">"(a)(b)c"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">"$1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>abbabcgbddesddfiid</code></pre><h1 id="十、贪婪和非贪婪"><a href="#十、贪婪和非贪婪" class="headerlink" title="十、贪婪和非贪婪"></a>十、贪婪和非贪婪</h1><h3 id="1-贪婪"><a href="#1-贪婪" class="headerlink" title="1. 贪婪"></a>1. 贪婪</h3><p>我们都知道，贪婪就是不满足，尽可能多的要。在正则中，贪婪也是差不多的意思:</p><p><strong>贪婪匹配</strong>：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。</p><p><strong>特性</strong>：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配 - 舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</p><p>前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：</p><pre><code>\d{3,6}</code></pre><p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p><p>如:</p><pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"\\d{3,6}"</span><span class="token punctuation">;</span>        String test<span class="token operator">=</span><span class="token string">"61762828 176 2991 871"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文本："</span><span class="token operator">+</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"贪婪模式："</span><span class="token operator">+</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Pattern p1 <span class="token operator">=</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher m1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token operator">+</span>m1<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>文本：61762828 176 2991 44 871贪婪模式：\d{3,6}匹配结果：617628匹配结果：176匹配结果：2991匹配结果：871</code></pre><p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个<code>（617）</code>就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。</p><p>一个量词就如此贪婪了，那有人会问，如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p><p>是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p><pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"(\\d{1,2})(\\d{3,4})"</span><span class="token punctuation">;</span>        String test<span class="token operator">=</span><span class="token string">"61762828 176 2991 87321"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文本："</span><span class="token operator">+</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"贪婪模式："</span><span class="token operator">+</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Pattern p1 <span class="token operator">=</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher m1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token operator">+</span>m1<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>文本：61762828 176 2991 87321贪婪模式：(\d{1,2})(\d{3,4})匹配结果：617628匹配结果：2991匹配结果：87321</code></pre><blockquote><p>“617628” 是前面的\d{1,2}匹配出了 61，后面的匹配出了 7628<br>“2991” 是前面的\d{1,2}匹配出了 29 ，后面的匹配出了 91<br>“87321”是前面的\d{1,2}匹配出了 87，后面的匹配出了 321</p></blockquote><h3 id="2-懒惰（非贪婪）"><a href="#2-懒惰（非贪婪）" class="headerlink" title="2. 懒惰（非贪婪）"></a>2. 懒惰（非贪婪）</h3><p><strong>懒惰匹配</strong>：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。</p><p><strong>特性</strong>: 从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。<br>懒惰量词是在贪婪量词后面加个“？”</p><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><pre class="line-numbers language-java"><code class="language-java">String reg<span class="token operator">=</span><span class="token string">"(\\d{1,2}?)(\\d{3,4})"</span><span class="token punctuation">;</span>        String test<span class="token operator">=</span><span class="token string">"61762828 176 2991 87321"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文本："</span><span class="token operator">+</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"贪婪模式："</span><span class="token operator">+</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Pattern p1 <span class="token operator">=</span>Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>Matcher m1 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"匹配结果："</span><span class="token operator">+</span>m1<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre><code>文本：61762828 176 2991 87321贪婪模式：(\d{1,2}?)(\d{3,4})匹配结果：61762匹配结果：2991匹配结果：87321</code></pre><p>解答：</p><blockquote><p>“61762” 是左边的懒惰匹配出 6，右边的贪婪匹配出 1762 </p><p>“2991” 是左边的懒惰匹配出 2，右边的贪婪匹配出 991</p><p>“87321” 左边的懒惰匹配出 8，右边的贪婪匹配出 7321</p></blockquote><h1 id="十一、-反义"><a href="#十一、-反义" class="headerlink" title="十一、 反义"></a>十一、 反义</h1><p>前面说到元字符的都是要匹配什么什么，当然如果你想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：</p><table><thead><tr><th>元字符</th><th>解释</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><p>正则知识就讲到这里，正则是一门博大精深的语言，其实学会它的一些语法和知识点还算不太难，但想要做到真正学以致用能写出非常 6的正则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式在几乎所有语言中都可以使用，无论是前端的 JavaScript、还是后端的 Java、c#。他们都提供相应的接口函数支持正则表达式。&lt;/p&gt;
&lt;p&gt;但很神奇的是：无论你大学选择哪一门计算机语言，都没有关于正则表达式的课程给你修，在你学会正则之前，你只能看着那些正则
      
    
    </summary>
    
      <category term="知识库" scheme="https://brokge.github.io/categories/%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    
    
      <category term="正则" scheme="https://brokge.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>大学</title>
    <link href="https://brokge.github.io/2018/11/01/%E5%A4%A7%E5%AD%A6/"/>
    <id>https://brokge.github.io/2018/11/01/大学/</id>
    <published>2018-11-01T11:20:40.000Z</published>
    <updated>2018-11-01T11:26:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始，知所先后，则近道矣。古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先脩其身；欲脩其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知，致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身脩，身脩而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，壹是皆以脩身为本。其本乱而末治者否矣，其所厚者薄，而其所薄者厚，未之有也！此谓知本，此谓知之至也。</p><p>所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也！小人闲居为不善，无所不至，见君子而后厌然，揜其不善，而著其善。人之视己，如见其肺肝然，则何益矣！此谓诚于中，形于外，故君子必慎其独也。曾子曰：「十目所视，十手所指，其严乎！」富润屋，德润身，心广体胖，故君子必诚其意。</p><p>《诗》云：「瞻彼淇澳，菉竹猗猗。有斐君子，如切如磋，如琢如磨。瑟兮僩兮，赫兮喧兮。有斐君子，终不可喧兮！」「如切如磋」者，道学也；「如琢如磨」者，自脩也；「瑟兮僩兮」者，恂慄也；「赫兮喧兮」者，威仪也；「有斐君子，终不可喧兮」者，道盛德至善，民之不能忘也。《诗》云：「於戏，前王不忘！」君子贤其贤而亲其亲，小人乐其乐而利其利，此以没世不忘也。</p><p>《康诰》曰：「克明德。」《太甲》曰：「顾諟天之明命。」《帝典》曰：「克明峻德。」皆自明也。</p><p>汤之《盘铭》曰：「茍日新，日日新，又日新。」《康诰》曰：「作新民。」《诗》曰：「周虽旧邦，其命维新。」是故君子无所不用其极。<br>《诗》云：「邦畿千里，维民所止。」《诗》云：「缗蛮黄鸟，止于丘隅。」子曰：「於止，知其所止，可以人而不如鸟乎？」《诗》云：「穆穆文王，於缉熙敬止！」为人君，止于仁；为人臣止于敬；为人子，止于孝；为人父，止于慈；与国人交，止于信。</p><p>子曰：「听讼，吾犹人也，必也使无讼乎！」无情者不得尽其辞，大畏民志。此谓知本。</p><p>所谓脩身在正其心者，身有所忿懥，则不得其正；有所恐惧，则不得其正；有所好乐，则不得其正；有所忧患，则不得其正。心不在焉，视而不见，听而不闻，食而不知其味。此谓脩身在正其心。</p><p>所谓齐其家在脩其身者，人之其所亲爱而辟焉，之其所贱恶而辟焉，之其所畏敬而辟焉，之其所哀矜而辟焉，之其所敖惰而辟焉。故好而知其恶，恶而知其美者，天下鲜矣！故谚有之曰：「人莫知其子之恶，莫知其苗之硕。」此谓身不脩，不可以齐其家。</p><p>所谓治国必先齐其家者，其家不可教而能教人者，无之。故君子不出家而成教于国：孝者，所以事君也；弟者，所以事长也；慈者，所以使众也。《康诰》曰：「如保赤子」，心诚求之，虽不中，不远矣。未有学养子而后嫁者也！一家仁，一国兴仁；一家让，一国兴让；一人贪戾，一国作乱。其机如此。此谓一言偾事，一人定国。尧、舜率天下以仁，而民从之；桀、纣率天下以暴，而民从之。其所令反其所好，而民不从。是故君子有诸己而后求诸人，无诸己而后非诸人。所藏乎身不恕，而能喻诸人者，未之有也。故治国在齐其家。《诗》云：「桃之夭夭，其叶蓁蓁；之子于归，宜其家人。」宜其家人，而后可以教国人。《诗》云：「宜兄宜弟。」宜兄宜弟，而后可以教国人。《诗》云：「其仪不忒，正是四国。」其为父子兄弟足法，而后民法之也。此谓治国在齐其家。</p><p>所谓平天下在治其国者，上老老而民兴孝，上长长而民兴弟，上恤孤而民不倍，是以君子有絜矩之道也。所恶于上，毋以使下；所恶于下，毋以事上；所恶于前，毋以先后；所恶于后，毋以从前；所恶于右，毋以交于左；所恶于左，毋以交于右。此之谓絜矩之道。</p><p>《诗》云：「乐只君子，民之父母。」民之所好好之，民之所恶恶之，此之谓民之父母。《诗》云：「节彼南山，维石岩岩。赫赫师尹，民具尔瞻。」有国者不可以不慎，辟，则为天下戮矣。《诗》云：「殷之未丧师，克配上帝。仪监于殷，峻命不易。」道得众则得国，失众则失国。是故君子先慎乎德。有德此有人，有人此有土，有土此有财，有财此有用。德者本也，财者末也。外本内末，争民施夺。是故财聚则民散，财散则民聚。是故言悖而出者，亦悖而入；货悖而入者，亦悖而出。《康诰》曰：「惟命不于常！」道善则得之，不善则失之矣。《楚书》曰：「楚国无以为宝，惟善以为宝。」舅犯曰：「亡人无以为宝，仁亲以为宝。」《秦誓》曰：「若有一介臣，断断兮无他技，其心休休焉，其如有容焉。人之有技，若己有之；人之彦圣，其心好之，不啻若自其口出。实能容之，以能保我子孙黎民，尚亦有利哉！人之有技，媢嫉以恶之；人之彦圣，而违之俾不通。实不能容，以不能保我子孙黎民，亦曰殆哉！」唯仁人放流之，迸诸四夷，不与同中国，此谓唯仁人为能爱人，能恶人。见贤而不能举，举而不能先，命也；见不善而不能退，退而不能远，过也。</p><p>好人之所恶，恶人之所好，是谓拂人之性，菑必逮夫身。是故君子有大道，必忠信以得之，骄泰以失之。</p><p>生财有大道，生之者众，食之者寡，为之者疾，用之者舒，则财恒足矣。仁者以财发身，不仁者以身发财。未有上好仁而下不好义者也，未有好义其事不终者也，未有府库财非其财者也。孟献子曰：「畜马乘，不察于鸡豚；伐冰之家，不畜牛羊；百乘之家，不畜聚敛之臣。与其有聚敛之臣，宁有盗臣。」此谓国不以利为利，以义为利也。长国家而务财用者，必自小人矣。彼为善之，小人之使为国家，菑害并至。虽有善者，亦无如之何矣！此谓国不以利为利，以义为利也。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始，知所先后，则近道矣。古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先脩其身；欲脩其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，
      
    
    </summary>
    
    
  </entry>
  
</feed>
