<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾與爾</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://brokge.github.io/"/>
  <updated>2020-01-08T04:49:54.111Z</updated>
  <id>https://brokge.github.io/</id>
  
  <author>
    <name>brokge</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>批量添加Java文件头部注释</title>
    <link href="https://brokge.github.io/2020/01/08/%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0Java%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E6%B3%A8%E9%87%8A/"/>
    <id>https://brokge.github.io/2020/01/08/批量添加Java文件头部注释/</id>
    <published>2020-01-08T03:45:00.000Z</published>
    <updated>2020-01-08T04:49:54.111Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="背景">背景</span></h2><p>在一般情况下，作为 Java 开发，如果事先在 Idea 或者 Eclipse中配置模版。在创建一个新类时，会自动生成 头部注释信息，比如下面这种。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * * @author name * @since xxxx-xx-xx */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有在 Idea 或 Eclipse 配置模版，需要手动插入。文件少还好，文件多的话那就mmp了。特别是历史遗留问题，有很多类文件没有加头部注释且编译时又做了代码检查，领导又让你加的时候。<br>事实上本人就碰到了这个问题，大概两三百个文件。</p><p>如果你属于上面的情况，那恭喜你。</p><h2><span id="环境要求">环境要求</span></h2><blockquote><p>python3</p></blockquote><h2><span id="使用方法">使用方法</span></h2><ol><li><p>拷贝py脚本到对应文件</p></li><li><p>执行以下命令</p></li></ol><pre class="line-numbers language-bash"><code class="language-bash"> python3 addAnnotation.py <span class="token variable">${authornName}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如：<code>python3 addAnnotation.py brokge</code><br>${authornName}  默认值为 <code>yusuzi</code> </p></blockquote><h2><span id="说明">说明</span></h2><blockquote><p>只处理脚本所在目录以下目录和文件 且后缀为 <code>.java</code> 文件 文件<br>如果存在 <code>@author</code> 或 <code>Created by xxx</code> 不处理</p></blockquote><h2><span id="支持的注释残缺类型">支持的注释残缺类型</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aa</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@xxxx</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aa</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 这是个测试类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">aa</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="addannotationpy-代码">addAnnotation.py 代码</span></h2><pre class="line-numbers language-py"><code class="language-py">#!usr/bin/python3# -*- coding:UTF-8 -*-import pickleimport pprintimport reimport timeimport os,sys#from dateutil.parser import parse'''使用方法：  python3 addAnnotation.py ${authornName}  ${authornName}  有默认值'''def eachFile(path, _authorName):    #print(path)    #authorName = _authorName    print("authorName:"+ authorName)    files = os.listdir(path)    for _file in files:        #判断是否为文件夹        if (not os.path.isdir(path+'/'+_file) and _file.endswith('.java')):            matchAndReplace(path+'/'+_file)            print(_file)        elif  os.path.isdir(path+'/'+_file):            eachFile(path+'/'+_file, authorName)def matchAndReplace(file):    fo = open(file,"r+")    #content = fo.read()    print("#正在处理文件名:",fo.name)    lines = fo.readlines()    if checkIsExist(lines):        print(" 已经存在注释",fo.name)        return    isOnlyAuthor = checkInsertPosition(lines)    position = getInsertPosition(lines)    if position == 0:        return    print('插入行:%d'%position)    templateStr = getTemplate('',isOnlyAuthor)    lines.insert(position-1,templateStr)    #content = content[:position+1]+ templateStr + content[position+1:]    #content = templateStr    content = ''.join(lines)    fo.close()    writeFile(content,file)def writeFile(content,file):    fo = open(file,"w")    fo.writelines(content)    fo.close()def checkInsertPosition(lines):    isOnlyAuthor = False    #lines = fo.readlines()    for line in lines:        if line.startswith(' */'):            isOnlyAuthor = True            break     return isOnlyAuthordef getInsertPosition(lines):    positionTemp = 0    #lines = fo.readlines()    for line in lines:        positionTemp = positionTemp+1        if line.startswith(' */'):            break         elif line.startswith('@'):            break         elif line.startswith('public class') or line.startswith('public interface') or line.startswith('public enum'):            break    return positionTempdef getInsertPosition1(content):    class_method = re.search(r'(?<=public class=")\w+(?=)'," content) classposition="class_method.start()" atposition="re.search()" position="0" if> atPosition:        position = atPosition    return position def checkIsExist(lines):    isExist = False    for line in lines:        result = re.search(r'^\s+\* @author \w+|^\s+\* Created by \w+',line)        if result is not None:            isExist = True            break    return isExist''' /** * * @author yusuzi * @since  */'''def getTemplate(defValue, isOnlyAuthor):    templateStr = ''    if not isOnlyAuthor:        templateStr = ('/**'+        '\n *'+ defValue+        '\n * @author '+authorName+        '\n * @since '+ getCurrentDateTime()+        '\n */\n'        )     else :        templateStr = (            ' * @author '+authorName+            '\n'+            ' * @since '+ getCurrentDateTime()+            '\n'            )    return templateStr    def getCurrentDateTime():    #print(parse('2018-04-29T17:45:25Z'))    print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())if __name__ == '__main__':    path = sys.path[0]    authorName = 'yusuzi'    if len(sys.argv)>1:        authorName = sys.argv[1]    eachFile(path, authorName)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></=public></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;背景&quot;&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在一般情况下，作为 Java 开发，如果事先在 Idea 或者 Eclipse中配置模版。在创建一个新类时，会自动生成 头部注释信息，比如下面这种。&lt;/p&gt;
&lt;pre class=&quot;line-numbers l
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://brokge.github.io/2019/09/23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://brokge.github.io/2019/09/23/责任链模式/</id>
    <published>2019-09-23T07:37:35.000Z</published>
    <updated>2019-10-09T02:49:24.389Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%9B%BE">结构图</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a></li><li><a href="#%E5%B0%8F%E7%BB%93">小结</a><ul><li><a href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%E5%A6%82%E4%B8%8B">职责链模式的主要优点如下：</a></li><li><a href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9%E5%A6%82%E4%B8%8B">职责链模式的主要缺点如下：</a></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="概念">概念</span></h2><p>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p><h2><span id="结构图">结构图</span></h2><p>责任链模式实现方式，有两种：集合形式、链表形式</p><p><img src="https://raw.githubusercontent.com/brokge/drawio/master/img/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="责任链模式-2019-9-23-14-53-40.png"></p><p><strong>Handler（抽象处理者）：</strong>  它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的 nextHandler），作为其对下家的引用。通过该引用，处理者可以连成一条链。</p><p><strong>ConcreteHandler（具体处理者）：</strong><br>它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p><h2><span id="示例代码">示例代码</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//维持对下家的引用</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler<span class="token operator">=</span>successor<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 具体处理者是抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>请求满足条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//处理请求</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//转发请求</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">HandlerProcessor</span><span class="token punctuation">{</span>    protect List<span class="token operator">&lt;</span>Handler<span class="token operator">></span> handlerList<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addHandler</span><span class="token punctuation">(</span>Handler handler<span class="token punctuation">)</span><span class="token punctuation">{</span>        handlerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Handler handler<span class="token operator">:</span>handlerList<span class="token punctuation">)</span><span class="token punctuation">{</span>            handler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。 </p><p>链表形式执行：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Handler a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>集合形式执行：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    Handler a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HandlerProcessor handleProcessor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HandlerProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    handleProcessor<span class="token punctuation">.</span><span class="token function">processHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="小结">小结</span></h2><h3><span id="职责链模式的主要优点如下">职责链模式的主要优点如下：</span></h3><p>(1) 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。</p><p>(2) 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</p><p>(3) 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</p><p>(4) 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。</p><h3><span id="职责链模式的主要缺点如下">职责链模式的主要缺点如下：</span></h3><p>(1) 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。</p><p>(2) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</p><p>(3) 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</p><h3><span id="适用场景">适用场景</span></h3><p>在以下情况下可以考虑使用职责链模式：</p><p>(1) 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</p><p>(2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p><p>(3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>冰山模型</title>
    <link href="https://brokge.github.io/2019/09/17/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B/"/>
    <id>https://brokge.github.io/2019/09/17/冰山模型/</id>
    <published>2019-09-17T08:23:06.000Z</published>
    <updated>2019-10-09T02:39:50.422Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B">一、冰山模型</a><ul><li><a href="#%E7%9F%A5%E8%AF%86%E5%92%8C%E6%8A%80%E8%83%BD">知识和技能</a></li><li><a href="#%E8%83%BD%E5%8A%9B">能力</a></li><li><a href="#%E4%BB%B7%E5%80%BC%E8%A7%82%E6%80%A7%E6%A0%BC%E5%8A%A8%E6%9C%BA">价值观、性格、动机</a></li></ul></li><li><a href="#%E4%BA%8C%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B%E7%A1%AE%E5%AE%9A%E8%81%8C%E4%BD%8D">二、如何根据冰山模型确定职位</a></li><li><a href="#%E4%B8%89%E6%8A%95%E5%85%A5%E5%9B%A0%E7%B4%A0%E7%9A%84%E4%B8%8D%E5%90%8C">三、投入因素的不同</a></li><li><a href="#%E5%9B%9B%E5%A4%A9%E8%B5%8B%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%A1%A8%E7%8E%B0-sign">四、天赋的四个表现 SIGN</a></li><li><a href="#%E4%BA%94%E4%B8%89%E4%B8%AA%E7%9F%A5%E8%AF%86%E5%86%85%E5%8C%96%E6%88%90%E8%83%BD%E5%8A%9B%E7%9A%84%E6%96%B9%E6%B3%95">五、三个知识内化成能力的方法</a></li><li><a href="#%E5%85%AD%E4%B8%89%E5%A4%A7%E7%B3%BB%E7%BB%9F-%E8%AE%A9%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%8D%E4%BE%9D%E9%9D%A0%E6%84%8F%E5%BF%97%E5%8A%9B">六、三大系统 让系统化学习不依靠意志力</a></li><li><a href="#%E4%B8%83%E5%AD%A6%E4%B9%A0%E4%B8%8D%E9%9D%A0%E6%84%8F%E5%BF%97%E5%8A%9B%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0">七、学习不靠意志力三个关键因素</a></li><li><a href="#%E5%85%AB%E4%B8%89%E4%B8%AA%E5%BB%BA%E8%AE%AE%E8%AE%A9%E4%BD%A0%E4%B8%8D%E5%81%9A%E5%AE%9A%E5%88%B6%E5%8C%96%E4%BA%BA%E6%89%8D">八、三个建议让你不做「定制化人才」</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>[toc]</p><h2><span id="一-冰山模型">一、冰山模型</span></h2><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B.png" alt="冰山模型"></p><blockquote><p>动机可能就是天赋本身</p></blockquote><h3><span id="知识和技能">知识和技能</span></h3><p>………</p><h3><span id="能力">能力</span></h3><p>知识技能属于特定领域，能力则是通用可迁移的。如果：沟通能力、学习能力、思考能力、交往能力。</p><h3><span id="价值观-性格-动机">价值观、性格、动机</span></h3><p>受基因、家庭教育、童年经历有关。后续改变相对较难。所以后续选择职业、婚姻或者其他的时候，最重要的是匹配，而不是强制改变。</p><blockquote><p>工作跟伴侣是一样的，「匹配」比「优秀」更重要。</p></blockquote><p>感觉一份工作不喜欢，有可能是：</p><ol><li>缺乏知识技能，导致的慌乱和焦虑。</li><li>缺乏能力导致的挫败和低效。</li><li>价值观不匹配导致的矛盾和纠结。</li><li>动机不匹配导致的没热情。</li><li>性格不匹配导致的心累。</li></ol><h2><span id="二-如何根据冰山模型确定职位">二、如何根据冰山模型确定职位</span></h2><p>一. 确定要分析的岗位。</p><p>二. 根据招聘网站搜索这个岗位的招聘要求。</p><p>三. 按照冰山模型，综合分析招聘要求。</p><p>四. 按照岗位需求模型与自己进行对比。</p><blockquote><p>搞明白 「我应该选择什么养的工作」比「我应该如何在别人认为的好工作里面成功」更重要的多。</p><p>想要让自己获得成就感，就不应该把它绑在别人的记分牌上。</p><p>查理芒格在「穷查理宝典」中提到：掌握一定量的思维模型，能解决这世上90%的问题。</p></blockquote><h2><span id="三-投入因素的不同">三、投入因素的不同</span></h2><p>整个冰山模型越往下的要素，越难培养。越难发现。投入不同要素上，会有什么结果。</p><ol><li><p>首先知识<br>单纯的知识储备，如果不能结合思维能力解决一些问题，很难有市场价值提升。</p></li><li><p>技能<br>门槛高，不代表天花板也高，毕竟没人想要一直拿一个工作的门槛工资。</p></li><li><p>能力<br>门槛不高，不代表天花板也不高。能力提升可以跨行业、职业。一旦积累到一定高度。哪怕行业不行，换个行业一样可以值钱。</p></li><li><p>自我发现<br>人们总是倾向于做容易的事，而不是正确的事。</p></li></ol><blockquote><p>你选的不是一份工作，而是天花板。<br>任何工作都是在解决问题，一家公司也是在解决某类用户的问题。</p></blockquote><blockquote><p><strong>我们的时间永远应该花在正确的事情上，而不是容易的事情上。</strong></p></blockquote><blockquote><p>虽然 成功的道路有千万条，但成功人士基本上都遵循了一个原则，就是将自身天赋发挥到极致。</p><p>天赋并不是少数人的专属，每个人都有自己的天赋。</p><p>天赋不是达到一定成绩后，才发挥作用的东西，而是一个在起点就发挥作用的因素。</p></blockquote><h2><span id="四-天赋的四个表现-sign">四、天赋的四个表现 SIGN</span></h2><ol><li>自我效能 （self-efficacy）-对某件事特别有信心，觉得自己可以成功。</li><li>本能（Insict）- 让你迫不及待、跃跃欲试的事情。可能意味着天赋所在。</li><li>成长（Growth）- 在某一领域，你一接触就比别人进步更快一些。</li><li>满足（Needs）- 做完这件事后，就算感到疲倦，依然会有满足感。</li></ol><h2><span id="五-三个知识内化成能力的方法">五、三个知识内化成能力的方法</span></h2><ol><li>掌握 20% 核心- 一个领域 20% 核心内容，能解决80% 的问题。</li><li>知识和问题相互靠- 学一门知识的时候，要知道能解决什么问题。</li><li>做系统化训练-行为和思维的改变至少需要1个月。</li></ol><blockquote><p>我们习惯高估几天的变化，而低估几个月的变化。</p><p>大脑不单单是用来记忆的，还是用来思考的。</p></blockquote><p>20% 核心举例子：</p><blockquote><p>结构化思维：主题鲜明、归类分组、逻辑递进。<br>ppt逼格：填充色半透明、边框细、行间距1.5。 </p></blockquote><h2><span id="六-三大系统-让系统化学习不依靠意志力">六、三大系统 让系统化学习不依靠意志力</span></h2><blockquote><p>人的意志力是有限的额，任何让自己坚持的事情，都会消耗它。</p><p>当你坚持学习的时候，不是「学些」这件事拖累了你，而是「坚持」这件事累着你了。</p><p>人们醒着的时候，大约 1/4 的时间用来抵制欲望。</p><p>如果可以用环境，就不要用你的意志力来抵制欲望。</p></blockquote><h2><span id="七-学习不靠意志力三个关键因素">七、学习不靠意志力三个关键因素</span></h2><ol><li><p>理性上知道要学习</p></li><li><p>情感上愿意去学习啊。</p></li><li><p>情景上制造适合学习的场景。</p></li></ol><p>发挥理性作用：树立明确目标。</p><p>发挥感性作用：利用情绪冲动。</p><p>发挥情景作用：创造学习环境</p><h2><span id="八-三个建议让你不做定制化人才">八、三个建议让你不做「定制化人才」</span></h2><ol><li>调整主题，给自己定好发展空间。</li><li>提升能力，让自己成为横向可迁移的人才。</li><li>提升认知高度，让自己成为纵向可深挖的人才。</li></ol><blockquote><p>社会发展到今天，你所遇到的几乎每个问题，这个世界上都有人曾经解决过它。我们要做的就是学习和发现这个答案。</p><p>教育是让一个人成为最好版本的自己—-马斯洛</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="人文" scheme="https://brokge.github.io/categories/%E4%BA%BA%E6%96%87/"/>
    
    
      <category term="思维模型" scheme="https://brokge.github.io/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂</title>
    <link href="https://brokge.github.io/2019/09/06/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
    <id>https://brokge.github.io/2019/09/06/简单工厂/</id>
    <published>2019-09-06T08:23:55.000Z</published>
    <updated>2019-10-09T02:46:12.168Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82">简单工厂</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E7%89%B9%E7%82%B9">特点</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码：</a></li><li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">简单工厂模式总结</a><ul><li><a href="#%E4%BC%98%E7%82%B9"><strong>优点</strong></a></li><li><a href="#%E7%BC%BA%E7%82%B9"><strong>缺点</strong></a></li></ul></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>适用场景</strong></a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>[toc]</p><h1><span id="简单工厂">简单工厂</span></h1><h2><span id="概念">概念</span></h2><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p><h2><span id="特点">特点</span></h2><p>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。<br>达到 <strong>创建和使用分离</strong>。</p><h2><span id="示例代码">示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象图表接口：抽象产品类</span><span class="token keyword">interface</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//柱状图类：具体产品类</span><span class="token keyword">class</span> <span class="token class-name">HistogramChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">HistogramChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//饼状图类：具体产品类</span><span class="token keyword">class</span> <span class="token class-name">PieChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">PieChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//折线图类：具体产品类</span><span class="token keyword">class</span> <span class="token class-name">LineChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">LineChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//图表工厂类：工厂类</span><span class="token keyword">class</span> <span class="token class-name">ChartFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//静态工厂方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Chart <span class="token function">getChart</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Chart chart <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"histogram"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HistogramChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PieChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"line"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LineChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token keyword">return</span> chart<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="简单工厂模式总结">简单工厂模式总结</span></h2><p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。</p><h3><span id="优点"><strong>优点</strong></span></h3><p> 简单工厂模式的主要优点如下：</p><blockquote><p>(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p><p>(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p><p>(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p></blockquote><h3><span id="缺点"><strong>缺点</strong></span></h3><p>简单工厂模式的主要缺点如下：</p><blockquote><p>(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p><p>(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p><p>(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p><p>(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p></blockquote><h2><span id="适用场景"><strong>适用场景</strong></span></h2><p>在以下情况下可以考虑使用简单工厂模式：</p><blockquote><p>(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p><p>(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法</title>
    <link href="https://brokge.github.io/2019/09/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>https://brokge.github.io/2019/09/06/工厂方法/</id>
    <published>2019-09-06T08:22:07.000Z</published>
    <updated>2019-10-09T02:45:04.348Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E7%89%B9%E7%82%B9">特点</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码：</a></li><li><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">工厂方法模式总结</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="背景">背景</span></h2><p>简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：</p><blockquote><p>(1) 工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大；</p><p>(2) 系统扩展不灵活，当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”</p></blockquote><p>如何实现增加新产品而不影响已有代码？</p><h2><span id="概念">概念</span></h2><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)</p><h2><span id="特点">特点</span></h2><p>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p><h2><span id="示例代码">示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//日志记录器接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数据库日志记录器：具体产品</span><span class="token keyword">class</span> <span class="token class-name">DatabaseLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据库日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//文件日志记录器：具体产品</span><span class="token keyword">class</span> <span class="token class-name">FileLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//日志记录器工厂接口：抽象工厂</span><span class="token keyword">interface</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数据库日志记录器工厂类：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">DatabaseLoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//连接数据库，代码省略</span>            <span class="token comment" spellcheck="true">//创建数据库日志记录器对象</span>            Logger logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//初始化数据库日志记录器，代码省略</span>            <span class="token keyword">return</span> logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//文件日志记录器工厂类：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">FileLoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//创建文件日志记录器对象</span>            Logger logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//创建文件，代码省略</span>            <span class="token keyword">return</span> logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//调用</span><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LoggerFactory factory<span class="token punctuation">;</span>        Logger logger<span class="token punctuation">;</span>        factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLoggerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可引入配置文件实现</span>        logger <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="工厂方法模式总结">工厂方法模式总结</span></h2><p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p><ol><li>主要优点</li></ol><p>工厂方法模式的主要优点如下：</p><blockquote><p>(1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p><p>(2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p><p>(3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p></blockquote><ol start="2"><li>主要缺点</li></ol><p>工厂方法模式的主要缺点如下：</p><blockquote><p>(1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p><p>(2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p></blockquote><ol start="3"><li>适用场景</li></ol><p>在以下情况下可以考虑使用工厂方法模式：</p><blockquote><p>(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</p><p>(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法</title>
    <link href="https://brokge.github.io/2019/09/06/%E6%B3%A8%E8%A7%A3/"/>
    <id>https://brokge.github.io/2019/09/06/注解/</id>
    <published>2019-09-06T08:22:07.000Z</published>
    <updated>2019-10-09T02:45:58.153Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80-%E6%B3%A8%E8%A7%A3%E5%88%86%E7%B1%BB">一 、注解分类</a><ul><li><a href="#1--java-%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3">1.  <strong>Java 内置注解</strong></a></li><li><a href="#2-%E6%A0%87%E6%B3%A8%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3">2. <strong>标注注解的元注解</strong></a></li></ul></li><li><a href="#%E4%BA%8C-%E6%B3%A8%E8%A7%A3%E5%AE%9A%E4%B9%89">二、 注解定义</a></li><li><a href="#%E4%B8%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8F%90%E5%8F%96">三、注解的提取</a></li><li><a href="#%E5%9B%9B%E5%85%B6%E4%BB%96">四、其他</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。</p><h2><span id="一-注解分类">一 、注解分类</span></h2><h4><span id="1-java-内置注解">1.  <strong>Java 内置注解</strong></span></h4><p> @Override、 @Deprecated、@SuppressWarnings、@SafeVarargs(jdk 7 新增)</p><h4><span id="2-标注注解的元注解">2. <strong>标注注解的元注解</strong></span></h4><p>元注解是用来修饰注解的注解，从而创建新的注解。</p><p><strong>@Targe</strong> </p><p>注解取值是一个 ElementType 类型的数组。<br>说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目的。</p><table><thead><tr><th>ElementType</th><th>说明</th></tr></thead><tbody><tr><td>- ElementType.TYPE</td><td>修饰类、接口或枚举类型。</td></tr><tr><td>- ElementType.FIELD</td><td>修饰成员变量。</td></tr><tr><td>- ElementType.METHOD</td><td>修饰方法。</td></tr><tr><td>- ElementType.PARAMETER</td><td>修饰参数。</td></tr><tr><td>- ElementType.CONSTRUCTOR</td><td>修饰构造方法。</td></tr><tr><td>- ElementType.LOCAL_VARIABLE</td><td>修饰局部变量。</td></tr><tr><td>- ElementType.ANNOTATION_TYPE</td><td>修饰注解。</td></tr><tr><td>- ElementType.PACKAGE</td><td>修饰包。</td></tr><tr><td>- ElementType.TYPE_PARAMETER</td><td>修饰参数声明。</td></tr><tr><td>- ElementType.TYPE_USR</td><td>使用类型。</td></tr></tbody></table><p><strong>@Retention</strong> </p><p>3种类型，分别表示不同的保留周期<br>定义了该Annotation被保留的时间长短，SOURCE、CLASS、RUNTIME（可通过反射获取内部属性）。</p><ol><li><strong>RetentionPolicy.SOURCE</strong>:源码级注解。<blockquote><p>注解信息只会保留在.java 源码中，源码在编译后，注解信息会被丢弃，不会保留到.class 中。</p></blockquote></li><li><strong>RetentionPolicy.CLASS</strong>:编译时注解。<blockquote><p>注解信息会保留在.java 源码以及.class 中。当运行java 程序时，JVM 会丢弃该注解信息，不会保留到 JVM 中。</p></blockquote></li><li><strong>RetentionPolicy.RUNTIME</strong>:运行时注解。<blockquote><p>当运行 java 程序时，JVM 也会保留该注解信息，可以通过反射获取该注解信息。</p></blockquote></li></ol><p><strong>@Documented</strong> </p><p>标记注解，可以工具文档化。</p><p><strong>@Inherited</strong> </p><p>当前注解是否可以继承。</p><p><strong>@Repeatable</strong></p><p>JDK 8 新增，允许一个注解在同一声明类型（类、属性或方法）上多次使用。</p><h2><span id="二-注解定义">二、 注解定义</span></h2><ol><li>基本定义</li></ol><p>定义新的注解类型使用 @interface 关键字。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>程序中使用该注解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Cup</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>定义成员变量(注解的属性)</li></ol><p>注解 只有成员变量，没有方法。注解的成员变量在注解定义中以“无形参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型；</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个成员变量以方法的形式来定义。使用该注解时候就应该为该成员变量赋值</p><pre class="line-numbers language-java"><code class="language-java">pubilc <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Cup</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"马克杯"</span><span class="token punctuation">,</span>price<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以在定义注解的时候通过 default 来指定默认值：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>   String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>定义运行时注解</li></ol><p>使用@Retention 来设定注解的保留策略 ，这三哥策略的生命周期长度为：SOURCE&lt;CLASS&lt;RUNTIME.</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 定义编译时注解</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>CLASS<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. Repeatable 定义可重复注解</strong></p><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Persons<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    String role <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"artist"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"coder"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"PM"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>以下代码中就是相关容器注解。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>基于容器的注解适用方式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Persons</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"artist"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"coder"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="三-注解的提取">三、注解的提取</span></h2><p>注解通过反射获取。<br>首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后通过 getAnnotation() / getAnnotationsByType()（since 1.8） 方法来获取 Annotation 对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> A <span class="token function">getAnnotation</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>A<span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> A<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>A<span class="token operator">></span> annotationClass <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者是 getAnnotations() 方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p><p>在处理的注解的过程中可能会用到以下方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Field <span class="token function">getDeclaredField</span><span class="token punctuation">(</span>String attrbuteName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> Field<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> Method <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>String methodName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="四-其他">四、其他</span></h2><p>注解： 使用场景 分为 三类：<br>编译前、<br>编译时生成代码、<br>运行时。</p><p>运行时注解：<br>例如：ButterKnife ，黑科技、低性能</p><p>编译时注解：<br>Dagger2：生成中间代码，所以性能高</p><p>注解处理器：<br>编译时处理器、<br>运行时处理器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂</title>
    <link href="https://brokge.github.io/2019/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://brokge.github.io/2019/09/05/抽象工厂/</id>
    <published>2019-09-05T11:55:06.000Z</published>
    <updated>2019-10-09T02:50:08.847Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">抽象工厂</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C">和工厂方法的不同</a></li><li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li><li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">抽象工厂 示例代码：</a></li><li><a href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-%E7%9A%84%E5%80%BE%E6%96%9C%E6%80%A7">开闭原则 的倾斜性</a></li><li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><!--toc--><h1><span id="抽象工厂">抽象工厂</span></h1><h2><span id="概念">概念</span></h2><p><strong>产品类型</strong>：单个产品类型。</p><p><strong>产品族</strong>：包含多个产品类型。</p><p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，</p><h2><span id="和工厂方法的不同">和工厂方法的不同</span></h2><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。</p><p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是<strong>单个产品类型</strong>，而抽象工厂模式针对的是<strong>多个产品类型</strong>，一个工厂类型可以负责多个不同产品类型中的产品对象的创建。当一个工厂类型可以创建出分属于不同产品类型的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率</p><h2><span id="案例">案例</span></h2><p>软件 换肤 功能。</p><pre class="mermaid">graph LR;    A[皮肤库]-->B[SPRING];    A[皮肤库]-->C[SUMMER];    B[SPRING]-->绿色按钮;    B[SPRING]-->绿色文本框;    B[SPRING]-->绿色边框组合框;    C[SUMMER]-->蓝色按钮;    C[SUMMER]-->蓝色文本框;    C[SUMMER]-->蓝色边框组合框;</pre><p>采用工厂方法模式设计的问题：</p><p>(1) 当需要增加新的皮肤时，虽然不要修改现有代码，但是需要增加大量类，针对每一个新增具体组件都需要增加一个具体工厂，类的个数成对增加，这无疑会导致系统越来越庞大，增加系统的维护成本和运行开销；</p><p>(2) 由于同一种风格的具体界面组件通常要一起显示，因此需要为每个组件都选择一个具体工厂，用户在使用时必须逐个进行设置，如果某个具体工厂选择失误将会导致界面显示混乱，虽然我们可以适当增加一些约束语句，但客户端代码和配置文件都较为复杂。</p><h2><span id="抽象工厂-示例代码">抽象工厂 示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//按钮接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring按钮类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SpringButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示浅绿色按钮。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer按钮类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SummerButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示浅蓝色按钮。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//文本框接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring文本框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SpringTextField</span> <span class="token keyword">implements</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示绿色边框文本框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer文本框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SummerTextField</span> <span class="token keyword">implements</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示蓝色边框文本框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//组合框接口：抽象产品</span><span class="token keyword">interface</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring组合框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SpringComboBox</span> <span class="token keyword">implements</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示绿色边框组合框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer组合框类：具体产品</span><span class="token keyword">class</span> <span class="token class-name">SummerComboBox</span> <span class="token keyword">implements</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示蓝色边框组合框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//界面皮肤工厂接口：抽象工厂</span><span class="token keyword">interface</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Spring皮肤工厂：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">SpringSkinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Summer皮肤工厂：具体工厂</span><span class="token keyword">class</span> <span class="token class-name">SummerSkinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//客户端调用</span><span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使用抽象层定义</span>        SkinFactory factory<span class="token punctuation">;</span>        Button bt<span class="token punctuation">;</span>        TextField tf<span class="token punctuation">;</span>        ComboBox cb<span class="token punctuation">;</span>        factory <span class="token operator">=</span> <span class="token punctuation">(</span>SkinFactory<span class="token punctuation">)</span>XMLUtil<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bt <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tf <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cb <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bt<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tf<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cb<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="开闭原则-的倾斜性">开闭原则 的倾斜性</span></h2><p>针对以上实现，如果我想添加新的组件（如：添加一个单选按钮），让这个组件也支持换肤功能。需要怎么做呢？</p><p>首先需要修改抽象工厂接口SkinFactory，在其中新增声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的皮肤中创建单选按钮，此外还需要修改客户端。</p><p>这时就发现：原有系统不能够在符合“开闭原则”的前提下增加新的组件。</p><p>在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品类型很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。</p><p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><p>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</p><p>(2) 增加新的产品类型：对于增加新的产品类型，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</p><p>正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品类型提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品类型，也不会删除已有的产品类型，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p><h2><span id="优缺点">优缺点</span></h2><p>缺点：</p><p>增加新的产品类型麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</p><p>优点：</p><p> (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</p><p> (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p><p> (3) 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</p><h2><span id="适用场景">适用场景</span></h2><p>在以下情况下可以考虑使用抽象工厂模式：</p><p>(1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</p><p>(2) 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</p><p>(3) 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</p><p>(4) 产品类型稳定，设计完成之后，不会向系统中增加新的产品类型或者删除已有的产品类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://brokge.github.io/2019/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://brokge.github.io/2019/09/05/设计模式/</id>
    <published>2019-09-05T09:15:15.000Z</published>
    <updated>2019-10-09T02:48:51.459Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">设计模式概述：</a><ul><li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%92%E5%88%86">设计模式划分</a></li><li><a href="#%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99">七大原则</a></li></ul></li><li><a href="#23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%92%E5%88%86">23 种设计模式划分</a><ul><li><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B">创建型</a></li><li><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B">结构型</a></li><li><a href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型模式</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="设计模式概述">设计模式概述：</span></h2><h3><span id="设计模式划分">设计模式划分</span></h3><p>设计模式可分为<strong>创建型</strong>(Creational)，<strong>结构型</strong>(Structural)和<strong>行为型</strong>(Behavioral)三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责</p><h3><span id="七大原则">七大原则</span></h3><ol><li>单一职责<blockquote><p>职责单一，相对独立，不细说。</p></blockquote></li><li>开放封闭原则<blockquote><p>对扩展开放，修改封闭，这个也不细说了。</p></blockquote></li><li><strong>依赖倒转</strong><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程,依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。<strong>实现依赖倒转原则时</strong>，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入</p></blockquote></li><li><strong>里氏替换原则</strong><blockquote><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。<br>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p></blockquote></li><li><strong>组合复用原则</strong><blockquote><p>尽量使用对象组合，而不是继承来达到复用的目的。<br>如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p></blockquote></li><li><strong>接口隔离原则</strong><blockquote><p>使用多个特定的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。<br><strong>接口隔离原则=使用单一职责原则的思想+考虑客户端具体的功能需求+适当切分定义接口文件+编程语言支持可实现多接口的语法特性</strong></p></blockquote></li><li><strong>迪米特原则</strong><blockquote><p>一个软件实体应当尽可能少地与其他实体发生相互作用。<br>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过<strong>第三者</strong>转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 迪米特法则目的是降低系统的耦合度，使类与类之间保持松散的耦合关系</p></blockquote></li></ol><p>在代码的重构中，很多时候以上原则是相铺相成互相结合。</p><p>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。相互补充，目标一致，只是分析问题时所站角度不同而已。</p><h2><span id="23-种设计模式划分">23 种设计模式划分</span></h2><h3><span id="创建型">创建型</span></h3><ol><li><a href="https://blog.dxdoctor.com/2019/09/06/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">简单工厂</a></li><li><a href="https://blog.dxdoctor.com/2019/09/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">工厂方法</a></li><li><a href="https://blog.dxdoctor.com/2019/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" target="_blank" rel="noopener">抽象工厂</a></li><li>单例模式</li><li>原型模式</li><li>建造者模式</li></ol><h3><span id="结构型">结构型</span></h3><ol><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ol><h3><span id="行为型模式">行为型模式</span></h3><ol><li><a href="https://blog.dxdoctor.com/2019/09/23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">职责链模式</a></li><li>命令模式</li><li>解释器模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模版方法模式</li><li>访问者模式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://brokge.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>线程池详解 </title>
    <link href="https://brokge.github.io/2019/09/03/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <id>https://brokge.github.io/2019/09/03/线程池详解/</id>
    <published>2019-09-02T16:31:36.000Z</published>
    <updated>2019-10-09T02:46:44.450Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0">线程池</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%8D%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD">线程是不是越多越好？</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">线程池组成部分：</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-api-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB">线程池 API-接口定义和实现类</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86-%E4%BB%BB%E5%8A%A1-execute-%E8%BF%87%E7%A8%8B">线程池原理-任务 execute 过程</a></li><li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">示例代码分析</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2">线程终止</a></li><li><a href="#%E6%9C%80%E5%90%8E%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E9%80%89%E6%8B%A9">最后线程数量的选择</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h1><span id="线程池">线程池</span></h1><h2><span id="线程是不是越多越好">线程是不是越多越好？</span></h2><ol><li>线程在 Java 中是一个对象，更是操作系统的资源，线程创建、销毁需要时间。如果创建时间+销毁时间 <code>&gt;</code> 执行任务时间，这样就很不合算。</li><li>Java 对象占用堆内存，操作系统线程占用系统内存，根据 JVM 规范，一个线程默认最大栈大小为 1 M，这个栈空间是需要从系统内存中分配的。线程过多，会消耗很多的内存。</li><li>操作系统需要频繁切换线程上下文（大家都想被运行），影响性能。</li></ol><p>线程池的推出，就是为了方便控制线程数量。</p><h2><span id="线程池组成部分">线程池组成部分：</span></h2><ol><li>线程池管理器：用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务。</li><li>工作线程：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务。</li><li>任务接口（Runnable）: 每个任务必须实现接口，以供工作线程调度任务执行，它主要规定了任务的入口、任务执行完后的收尾工作、任务的执行状态等。</li><li>任务队列：用于存放没有处理的任务。提供一种缓冲机制</li></ol><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt></p><h2><span id="线程池-api-接口定义和实现类">线程池 API-接口定义和实现类</span></h2><table><thead><tr><th>类型</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>接口</td><td>Executor</td><td>最上层的接口，定义了执行任务的方法 execute()</td></tr><tr><td>接口</td><td>ExecutorService</td><td>继承Executor 接口，拓展了 Callable、Future、关闭方法</td></tr><tr><td>接口</td><td>ScheduledExecutorService</td><td>继承ExecutorService 接口，增加了定时任务相关的方法</td></tr><tr><td>实现类</td><td>ThreadPoolExecutor</td><td>基础、标准的线程池实现</td></tr><tr><td>实现类</td><td>ScheduledThreadPoolExecutor</td><td>继承了 ThreadPoolExecutor，实现了 ScheduledExecutorService中相关定时任务的方法</td></tr></tbody></table><p><code>ScheduledThreadPoolExecutor</code>是功能最为丰富的类。</p><p><img src="media/15674328999538/15674332671245.jpg" alt></p><p><img src="media/15674328999538/15674335746028.jpg" alt></p><h2><span id="线程池原理-任务-execute-过程">线程池原理-任务 execute 过程</span></h2><ol><li>是否达到核心线程数量？没达到，创建一个工作线程来执行任务。</li><li>工作队列是否已满？没满，则将新提交的任务存储在工作队列里。</li><li>是否达到线程池最大数量？没达到，则创建一个新的工作线程来执行任务。</li><li>最后，执行拒绝策略来处理这个任务。</li></ol><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/%E7%BA%BF%E7%A8%8B%E6%B1%A0Execute%E5%8E%9F%E7%90%86.png" alt></p><h2><span id="示例代码分析">示例代码分析</span></h2><p>测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCommon</span><span class="token punctuation">(</span>ThreadPoolExecutor threadPoolExecutor<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 查看线程数量，查看队列等待数量</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>500L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>15000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>场景一：</li></ul><blockquote><p>线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略。</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行</p></blockquote><ul><li>场景二：</li></ul><blockquote><p> 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略.</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 预计结果：</p><ol><li>5个任务直接分配线程开始执行</li><li>3个任务进入等待队列</li><li>队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)</li><li>队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。</li><li>任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程</li></ol></blockquote><ul><li>场景三：</li></ul><blockquote><p>线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒 *  * @throws Exception */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newFixedThreadPool(int nThreads)一样的</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// </span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行</p></blockquote><ul><li>场景四：</li></ul><blockquote><p>线程池信息：核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>60000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"60秒后，再看线程池中的数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：</p><ol><li>线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行</li><li>所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0</li></ol></blockquote><blockquote><p>SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。<br>在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，<br>而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，<br>那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。<br>此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。<br>和Executors.newCachedThreadPool()一样的</p></blockquote><ul><li>场景五：</li></ul><blockquote><p>定时执行线程池信息：3秒后执行，一次性任务，到点就执行<br>核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newScheduledThreadPool()一样的</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                <span class="token string">"定时任务，提交成功，时间是："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 当前线程池中线程数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>预计结果：任务在3秒后被执行一次</p></blockquote><ul><li>场景六：</li></ul><blockquote><p>定时执行线程池信息：线程固定数量5 , 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-1 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-2 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>周期性执行某一个任务，线程池提供了两种调度方式</p><p>测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别<br>效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。<br> 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）</p><p>效果2： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）</p></blockquote><h2><span id="线程终止">线程终止</span></h2><p>线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略.</p><ul><li>shutdown()</li></ul><p>创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。<br>默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 结果分析</p><ol><li>10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</li><li>调用shutdown后，不接收新的任务，等待13任务执行结束</li><li>追加的任务在线程池关闭后，无法再提交，会被拒绝执行</li></ol></blockquote><ul><li>shutdownNow()</li></ul><p>创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> shutdownNow <span class="token operator">=</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未结束的任务有："</span> <span class="token operator">+</span> shutdownNow<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>结果分析</p><ol><li>10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</li><li>调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止</li><li>追加的任务在线程池关闭后，无法再提交，会被拒绝执行</li></ol></blockquote><h2><span id="最后线程数量的选择">最后线程数量的选择</span></h2><ul><li><strong>计算型任务</strong>： cpu 数量的 1-2 倍。</li><li><strong>IO型任务</strong>：相对比计算型任务，需多一些线程，要根据具体的 IO阻塞时长进行考量决定。<br>如 tomcat 中默认的最大线程数为：200</li></ul><p>也可考虑根据需要在一个最小数量和最大数量间自动增减线程数。</p><p>以上测试完整代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>study<span class="token punctuation">.</span>hc<span class="token punctuation">.</span>thread<span class="token punctuation">.</span>chapter1<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collections<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RejectedExecutionHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ScheduledThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>SynchronousQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 线程池的使用 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo9</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 测试： 提交15个执行时间需要3秒的任务,看线程池的状况     *      * @param threadPoolExecutor 传入不同的线程池，看不同的结果     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCommon</span><span class="token punctuation">(</span>ThreadPoolExecutor threadPoolExecutor<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 查看线程数量，查看队列等待数量</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>500L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 等待15秒，查看线程数量和队列数量（理论上，会被超出核心线程数量的线程自动销毁）</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>15000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池线程数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程池等待的数量为："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 2、 线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：</span>        <span class="token comment" spellcheck="true">// 1、 5个任务直接分配线程开始执行</span>        <span class="token comment" spellcheck="true">// 2、 3个任务进入等待队列</span>        <span class="token comment" spellcheck="true">// 3、 队列不够用，临时加开5个线程来执行任务(5秒没活干就销毁)</span>        <span class="token comment" spellcheck="true">// 4、 队列和线程池都满了，剩下2个任务，没资源了，被拒绝执行。</span>        <span class="token comment" spellcheck="true">// 5、 任务执行，5秒后，如果无任务可执行，销毁临时创建的5个线程</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 3、 线程池信息： 核心线程数量5，最大数量5，无界队列，超出核心线程数量的线程存活时间：5秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newFixedThreadPool(int nThreads)一样的</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结：线程池线程数量为：5，超出数量的任务，其他的进入队列中等待被执行</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 4、 线程池信息：     * 核心线程数量0，最大数量Integer.MAX_VALUE，SynchronousQueue队列，超出核心线程数量的线程存活时间：60秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。</span>        <span class="token comment" spellcheck="true">// 在使用SynchronousQueue作为工作队列的前提下，客户端代码向线程池提交任务时，</span>        <span class="token comment" spellcheck="true">// 而线程池中又没有空闲的线程能够从SynchronousQueue队列实例中取一个任务，</span>        <span class="token comment" spellcheck="true">// 那么相应的offer方法调用就会失败（即任务没有被存入工作队列）。</span>        <span class="token comment" spellcheck="true">// 此时，ThreadPoolExecutor会新建一个新的工作者线程用于对这个入队列失败的任务进行处理（假设此时线程池的大小还未达到其最大线程池大小maximumPoolSize）。</span>        <span class="token comment" spellcheck="true">// 和Executors.newCachedThreadPool()一样的</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> 60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testCommon</span><span class="token punctuation">(</span>threadPoolExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：</span>        <span class="token comment" spellcheck="true">// 1、 线程池线程数量为：15，超出数量的任务，其他的进入队列中等待被执行</span>        <span class="token comment" spellcheck="true">// 2、 所有任务执行结束，60秒后，如果无任务可执行，所有线程全部被销毁，池的大小恢复为0</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>60000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"60秒后，再看线程池中的数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 5、 定时执行线程池信息：3秒后执行，一次性任务，到点就执行 &lt;br/>     * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 和Executors.newScheduledThreadPool()一样的</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>                <span class="token string">"定时任务，提交成功，时间是："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 当前线程池中线程数量："</span> <span class="token operator">+</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 预计结果：任务在3秒后被执行一次</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 6、 定时执行线程池信息：线程固定数量5 ，&lt;br/>     * 核心线程数量5，最大数量Integer.MAX_VALUE，DelayedWorkQueue延时队列，超出核心线程数量的线程存活时间：0秒     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest6</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ScheduledThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 周期性执行某一个任务，线程池提供了两种调度方式，这里单独演示一下。测试场景一样。</span>        <span class="token comment" spellcheck="true">// 测试场景：提交的任务需要3秒才能执行完毕。看两种不同调度方式的区别</span>        <span class="token comment" spellcheck="true">// 效果1： 提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，完毕后立刻执行)。</span>        <span class="token comment" spellcheck="true">// 也就是说这个代码中是，3秒钟执行一次（计算方式：每次执行三秒，间隔时间1秒，执行结束后马上开始下一次执行，无需等待）</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-1 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 效果2：提交后，2秒后开始第一次执行，之后每间隔1秒，固定执行一次(如果发现上次执行还未完毕，则等待完毕，等上一次执行完毕后再开始计时，等待1秒)。</span>        <span class="token comment" spellcheck="true">// 也就是说这个代码钟的效果看到的是：4秒执行一次。 （计算方式：每次执行3秒，间隔时间1秒，执行完以后再等待1秒，所以是 3+1）</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务-2 被执行，现在时间："</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 7、 终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 结果分析</span>        <span class="token comment" spellcheck="true">// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</span>        <span class="token comment" spellcheck="true">// 2、调用shutdown后，不接收新的任务，等待13任务执行结束</span>        <span class="token comment" spellcheck="true">// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 8、 立刻终止线程：线程池信息： 核心线程数量5，最大数量10，队列大小3，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的     *      * @throws Exception     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">threadPoolExecutorTest8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建一个 核心线程数量为5，最大数量为10,等待队列最大是3 的线程池，也就是最大容纳13个任务。</span>        <span class="token comment" spellcheck="true">// 默认的策略是抛出RejectedExecutionException异常，java.util.concurrent.ThreadPoolExecutor.AbortPolicy</span>        ThreadPoolExecutor threadPoolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> ThreadPoolExecutor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有任务被拒绝执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 测试： 提交15个执行时间需要3秒的任务，看超过大小的2个，对应的处理情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">15</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> i<span class="token punctuation">;</span>            threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始执行："</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>3000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行结束:"</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异常："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务提交成功 :"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 1秒后终止线程池</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> shutdownNow <span class="token operator">=</span> threadPoolExecutor<span class="token punctuation">.</span><span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 再次提交提示失败</span>        threadPoolExecutor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"追加一个任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"未结束的任务有："</span> <span class="token operator">+</span> shutdownNow<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 结果分析</span>        <span class="token comment" spellcheck="true">// 1、 10个任务被执行，3个任务进入队列等待，2个任务被拒绝执行</span>        <span class="token comment" spellcheck="true">// 2、调用shutdownnow后，队列中的3个线程不再执行，10个线程被终止</span>        <span class="token comment" spellcheck="true">// 3、 追加的任务在线程池关闭后，无法再提交，会被拒绝执行</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest1();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest2();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest3();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest4();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest5();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest6();</span><span class="token comment" spellcheck="true">//        new Demo9().threadPoolExecutorTest7();</span>        <span class="token keyword">new</span> <span class="token class-name">Demo9</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">threadPoolExecutorTest8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="Java" scheme="https://brokge.github.io/categories/Java/"/>
    
      <category term="并发编程" scheme="https://brokge.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="https://brokge.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java  注解</title>
    <link href="https://brokge.github.io/2019/08/30/Java-%E6%B3%A8%E8%A7%A3/"/>
    <id>https://brokge.github.io/2019/08/30/Java-注解/</id>
    <published>2019-08-30T12:44:41.000Z</published>
    <updated>2019-10-09T02:44:09.736Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E6%B3%A8%E8%A7%A3">注解</a><ul><li><a href="#%E4%B8%80-%E6%B3%A8%E8%A7%A3%E5%88%86%E7%B1%BB">一 、注解分类</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">定义注解</a></li><li><a href="#%E4%BA%8C%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8F%90%E5%8F%96">二、注解的提取</a></li><li><a href="#%E4%B8%89%E5%85%B6%E4%BB%96">三、其他</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="注解">注解</span></h2><p>注解是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取。并执行相应的处理。</p><h3><span id="一-注解分类">一 、注解分类</span></h3><ol><li><p><strong>java 内置注解</strong> </p><p>@Override、 @Deprecated、@SuppressWarnings、@SafeVarargs(jdk 7 新增)</p></li><li><p><strong>标注注解的元注解</strong></p></li></ol><p>它是用来修饰注解的注解，从而创建新的注解。</p><ul><li>@Target, 说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目的。</li><li>@Retention, 定义了该Annotation被保留的时间长短，SOURCE、CLASS、RUNTIME（可通过反射获取内部属性）。</li><li>@Documented, 标记注解，可以工具文档化。</li><li>@Inherited 当前注解是否可以继承。</li><li>@Repeatable: JDK 8 新增，允许一个注解在同一声明类型（类、属性或方法）上多次使用。</li></ul><p><strong>@Targe</strong> 注解取值是一个 ElementType 类型的数组。</p><table><thead><tr><th>ElementType</th><th>说明</th></tr></thead><tbody><tr><td>- ElementType.TYPE</td><td>修饰类、接口或枚举类型。</td></tr><tr><td>- ElementType.FIELD</td><td>修饰成员变量。</td></tr><tr><td>- ElementType.METHOD</td><td>修饰方法。</td></tr><tr><td>- ElementType.PARAMETER</td><td>修饰参数。</td></tr><tr><td>- ElementType.CONSTRUCTOR</td><td>修饰构造方法。</td></tr><tr><td>- ElementType.LOCAL_VARIABLE</td><td>修饰局部变量。</td></tr><tr><td>- ElementType.ANNOTATION_TYPE</td><td>修饰注解。</td></tr><tr><td>- ElementType.PACKAGE</td><td>修饰包。</td></tr><tr><td>- ElementType.TYPE_PARAMETER</td><td>修饰参数声明。</td></tr><tr><td>- ElementType.TYOPE_USR</td><td>使用类型。</td></tr></tbody></table><p><strong>@Retention</strong> 3种类型，分别表示不同的保留周期</p><ul><li><strong>RetentionPolicy.SOURCE</strong>:源码级注解。<blockquote><p>注解信息只会保留在.java 源码中，源码在编译后，注解信息会被丢弃，不会保留到.class 中。</p></blockquote></li><li><strong>RetentionPolicy.CLASS</strong>:编译时注解。<blockquote><p>注解信息会保留在.java 源码以及.class 中。当运行java 程序时，JVM 会丢弃该注解信息，不会保留到 JVM 中。</p></blockquote></li><li><strong>RetentionPolicy.RUNTIME</strong>:运行时注解。<blockquote><p>当运行 java 程序时，JVM 也会保留该注解信息，可以通过反射获取该注解信息。</p></blockquote></li></ul><h3><span id="定义注解">定义注解</span></h3><p><strong>1. 基本定义</strong></p><p>定义新的注解类型使用 @interface 关键字。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>程序中使用该注解：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Cup</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 定义成员变量(注解的属性)</strong></p><p>注解 只有成员变量，没有方法。注解的成员变量在注解定义中以“无形参的方法”形式来声明，其“方法名”定义了该成员变量的名字，其返回值定义了该成员变量的类型；</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面两个成员变量以方法的形式来定义。使用该注解时候就应该为该成员变量赋值</p><pre class="line-numbers language-java"><code class="language-java">pubilc <span class="token keyword">class</span> <span class="token class-name">AnnotationTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Cup</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"马克杯"</span><span class="token punctuation">,</span>price<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以在定义注解的时候通过 default 来指定默认值：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>   String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 定义运行时注解</strong></p><p>使用@Retention 来设定注解的保留策略 ，这三哥策略的生命周期长度为：SOURCE&lt;CLASS&lt;RUNTIME.</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 定义编译时注解</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>CLASS<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cup</span><span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"马克杯"</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5. Repeatable 定义可重复注解</strong></p><p>Repeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><p>什么样的注解会多次应用呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员又是产品经理,同时他还是个画家。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Persons<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>@<span class="token keyword">interface</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>    String role <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"artist"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"coder"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Person</span><span class="token punctuation">(</span>role<span class="token operator">=</span><span class="token string">"PM"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SuperMan</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意上面的代码，@Repeatable 注解了 Person。而 @Repeatable 后面括号中的类相当于一个容器注解。</p><p>什么是容器注解呢？就是用来存放其它注解的地方。它本身也是一个注解。</p><p>以下代码中就是相关容器注解。</p><pre class="line-numbers language-java"><code class="language-java">@<span class="token keyword">interface</span> <span class="token class-name">Persons</span> <span class="token punctuation">{</span>    Person<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3><span id="二-注解的提取">二、注解的提取</span></h3><p>注解通过反射获取。<br>首先可以通过 Class 对象的 isAnnotationPresent() 方法判断它是否应用了某个注解</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后通过 getAnnotation() 方法来获取 Annotation 对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>A <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> A <span class="token function">getAnnotation</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>A<span class="token operator">></span> annotationClass<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者是 getAnnotations() 方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。</p><p>在处理的注解的过程中可能会用到以下方法</p><pre class="line-numbers language-java"><code class="language-java">Field <span class="token function">getDeclaredField</span><span class="token punctuation">(</span>String attrbuteName<span class="token punctuation">)</span><span class="token punctuation">;</span>Method <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>String methodName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3><span id="三-其他">三、其他</span></h3><p>注解： 使用场景 分为 三类：<br>编译前、<br>编译时生成代码、<br>运行时。</p><p>运行时注解：<br>例如：ButterKnife ，黑科技、低性能</p><p>编译时注解：<br>Dagger2：生成中间代码，所以性能高</p><p>注解处理器：<br>编译时处理器、<br>运行时处理器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="注解" scheme="https://brokge.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>JVM 类加载和初始化</title>
    <link href="https://brokge.github.io/2019/07/30/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://brokge.github.io/2019/07/30/JVM-类加载和初始化/</id>
    <published>2019-07-30T12:50:24.000Z</published>
    <updated>2019-10-09T02:44:37.095Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#%E7%B1%BB%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8A%A0%E8%BD%BD">类什么时候加载？</a></li><li><a href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F">类初始化的方式</a></li><li><a href="#%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99">类初始化规则：</a><ul><li><a href="#%E5%90%8D%E8%AF%8D%E8%AF%B4%E6%98%8E">名词说明</a></li><li><a href="#%E5%8F%82%E8%80%83">参考：</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>我们知道 当要实例化一个类时，JVM会首先加载该类，并且在加载过程中检查这个类是否有静态属性以及静态代码块，如果有，就按顺序分配内存并初始化他们，并且只在类加载的过程中初始化一次。</p><p>对于构造代码块，以及普通属性，是在类实例化时进行的，并且每次实例化都会调用，并且普通属性先于构造代码块，构造代码块先于构造方法执行。</p><p><img src="https://raw.githubusercontent.com/brokge/drawio/master/java-load-class.png" alt="流程图"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span> <span class="token string">"第一步 main 静态属性"</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3</span>    <span class="token keyword">private</span> String value <span class="token operator">=</span> <span class="token string">"第三步 main 普通属性"</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>staticValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第二步 main 静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//4</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第四步 main 构造代码块 "</span><span class="token operator">+</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过查看时间戳，常规属性是在 构造代码块之前就初始化。</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//5</span>    <span class="token keyword">private</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第五步 main 构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getString()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Main main <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制台输出：</p><pre class="line-numbers language-bash"><code class="language-bash">1565683686844第一步 main 静态属性15656836868441565683687848第二步 main 静态代码块1565683687849第四步 main 构造代码块 1565683688852第三步 main 普通属性1565683687849第五步 main 构造方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现第三步和第四步顺序是掉换的，但是根据时间戳知道，第三步是发生在第四部之前，也就是说第三步的普通属性的初始化在构造代码块之前执行。</p><h3><span id="类什么时候加载">类什么时候加载？</span></h3><p>加载时机：</p><blockquote><ol><li>其他类引用时候。</li><li>类初始化。</li></ol></blockquote><p>加载工具： Classloader(类加载器)</p><h3><span id="类初始化的方式">类初始化的方式</span></h3><ol><li>实例通过使用new()关键字创建或者使用class.forName()反射，但它有可能导致ClassNotFoundException。</li><li>类的静态方法被调用。</li><li>类的静态域（静态变量）被赋值。</li><li>静态域被访问，而且不是常量（final）。</li><li>顶层类中执行 assert 语句。</li></ol><h3><span id="类初始化规则">类初始化规则：</span></h3><ol><li>类从顶至底部顺序初始化，所以声明在顶部的字段的早于底部的字段初始化</li><li>超类早于子类和衍生类的初始化</li><li>如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的初始化即使静态域被子类或子接口或者它的实现类所引用。</li><li>接口初始化不会导致父接口的初始化。</li><li>静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。</li><li>非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类。</li></ol><h2><span id="名词说明">名词说明</span></h2><p><strong>类的初始化和类的实例化是不同的</strong>:<br>类的初始化发生在类实例化之前。</p><ul><li>静态域=静态变量</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span><span class="token string">"静态域"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>静态域：如果将类中的域定义为static，则这个域属于这个类，而不属于这个类的某个对象，每个类中只有 一个这样的域，而每一个类对象对于所有的实例域(即没有定义为static的域)都有自己的一份拷贝。例如：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span> 　　<span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span> 　　<span class="token keyword">private</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span><span class="token string">"静态域"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果有1000个Employee对象，则有1000个实例域 id，但是只有一个静态域 staticValue；即使没有一个Employee对象，静态域nextId也存在，它属于类，不属于任何对象。</p></blockquote><ul><li>实例域=非静态变量</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span>  String staticValue <span class="token operator">=</span><span class="token string">"实例域"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>静态常量=final</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String staticValue <span class="token operator">=</span><span class="token string">"静态常量"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>静态方法</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getString()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>静态代码块</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>构造代码块</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构造方法</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">main</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="参考">参考：</span></h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html" target="_blank" rel="noopener">类加载器</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="Java" scheme="https://brokge.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://brokge.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Android 数据结构之 LinkedHashMap</title>
    <link href="https://brokge.github.io/2019/07/24/Android-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-LinkedHashMap/"/>
    <id>https://brokge.github.io/2019/07/24/Android-数据结构之-LinkedHashMap/</id>
    <published>2019-07-24T13:07:42.000Z</published>
    <updated>2019-10-09T02:42:42.122Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">原理分析：</a></li><li><a href="#%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8">场景使用</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="原理分析">原理分析：</span></h2><p> LinkedHashMap 是 HashMap 的子类，其在 HashMap 的基础上只添加了一个双向链表和一个顺序模式属性，其每次 put 元素都会往这个双向链表上添加节点，其构造方法比 HashMap 多了一个 boolean 类型的 accessOrder 参数，当该参数为 true 时则按照元素最后访问时间在双向链表中排序，为 false 则按照插入顺序排序，默认为 false。<br> 具体源码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The head of the doubly linked list.     */</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> header<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LinkedHashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span>                         <span class="token keyword">float</span> loadFactor<span class="token punctuation">,</span>                         <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>accessOrder <span class="token operator">=</span> accessOrder<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LinkedHashMap 继承自 HashMap，所以其 put 和 get 操作重写了父类的实现</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * This override differs from addEntry in that it doesn't resize the     * table or remove the eldest entry.     */</span>    <span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> old <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMapEntry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> old<span class="token punctuation">)</span><span class="token punctuation">;</span>        table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">addBefore</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span><span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashMapEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMapEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>    <span class="token function">LinkedHashMapEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> HashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Removes this entry from the linked list.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            before<span class="token punctuation">.</span>after <span class="token operator">=</span> after<span class="token punctuation">;</span>            after<span class="token punctuation">.</span>before <span class="token operator">=</span> before<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Inserts this entry before the specified existing entry in the list.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addBefore</span><span class="token punctuation">(</span>LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> existingEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            after  <span class="token operator">=</span> existingEntry<span class="token punctuation">;</span>            before <span class="token operator">=</span> existingEntry<span class="token punctuation">.</span>before<span class="token punctuation">;</span>            before<span class="token punctuation">.</span>after <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            after<span class="token punctuation">.</span>before <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * This method is invoked by the superclass whenever the value     * of a pre-existing entry is read by Map.get or modified by Map.set.     * If the enclosing Map is access-ordered, it moves the entry     * to the end of the list; otherwise, it does nothing.     */</span>    <span class="token keyword">void</span> <span class="token function">recordAccess</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LinkedHashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lm <span class="token operator">=</span> <span class="token punctuation">(</span>LinkedHashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>m<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lm<span class="token punctuation">.</span>accessOrder<span class="token punctuation">)</span> <span class="token punctuation">{</span>                lm<span class="token punctuation">.</span>modCount<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">addBefore</span><span class="token punctuation">(</span>lm<span class="token punctuation">.</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">recordRemoval</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 LinkedHashMapMap 中所有 put 进来的 Entry 最终除过按照 HashMap 的 put 操作进行哈希表存储后又额外添加进了一个以 head 为头结点的双向循环链表尾部。==所以说 KinkedHashMap 完全具备 HashMap 的所有特性，也允许 key 和 value 为 null 值，此外自己比 HashMap 厉害的地方在于保证了访问的有序性==。</p><p>接着在进行迭代器访问时与 HashMap 的区别在于 LinkedHashMap 是直接迭代遍历操作其自己维护的双向有序链表，以此来保证顺序性，如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LinkedHashIterator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> nextEntry    <span class="token operator">=</span> header<span class="token punctuation">.</span>after<span class="token punctuation">;</span>        LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastReturned <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * The modCount value that the iterator believes that the backing         * List should have.  If this expectation is violated, the iterator         * has detected concurrent modification.         */</span>        <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> nextEntry <span class="token operator">!=</span> header<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LinkedHashMap<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastReturned <span class="token operator">=</span> null<span class="token punctuation">;</span>            expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">nextEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nextEntry <span class="token operator">==</span> header<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LinkedHashMapEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> lastReturned <span class="token operator">=</span> nextEntry<span class="token punctuation">;</span>            nextEntry <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以 <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，除过具备 <code>HashMap</code> 的一切优缺点外自身具备插入有序性或者访问有序性，其实现依赖 <code>HashMap</code> 自身的存储结构不变外在 put、get 操作处添加了一个对自己内部维护的双向有序链表的操作。</p><h2><span id="场景使用">场景使用</span></h2><ol><li>LRU 的结合：</li></ol><blockquote><p>LRU 是一种流行的替换算法，它的全称是 <code>Least Recently Used</code>，最近最少使用，常常在缓存设计的场景中充当一种策略，它的核心思路是最近刚被使用的很快再次被用的可能性最高，而最久没被访问的很快再次被用的可能性最低，所以被优先清理。</p></blockquote><ol start="2"><li>LRU 容器的实现</li></ol><blockquote><p>在添加元素到<code>LinkedHashMap</code> 后会调用 <code>removeEldesEntry</code>方法，传递的参数是最久没被访问的键值对，如果这个方法返回<code>true</code> 则这个最久的键值对就会被删除，<code>LinkedHashMap</code>的实现总是返回<code>false</code>，所有容量没有限制。</p></blockquote><ul><li>LinkedHashMap 的实现<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>重写后的实现</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span><span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> extents LinkedHashMap<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxEntries<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxEntries<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">0.75</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maxEntries<span class="token operator">=</span>maxEntries<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@override</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldesEntry</span><span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span> eldest<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>maxentries<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://brokge.github.io/tags/Android/"/>
    
      <category term="数据结构" scheme="https://brokge.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android 性能优化总结</title>
    <link href="https://brokge.github.io/2019/07/16/Android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>https://brokge.github.io/2019/07/16/Android-性能优化总结/</id>
    <published>2019-07-16T13:09:53.000Z</published>
    <updated>2019-10-09T02:42:20.580Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E7%94%A8%E6%88%B7%E6%89%8B%E4%B8%AD%E5%A5%BD%E7%9A%84%E5%BA%94%E7%94%A8%E6%8C%87%E6%A0%87">用户手中好的应用指标：</a></li><li><a href="#android-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93">Android 性能优化总结</a><ul><li><a href="#%E7%9B%AE%E6%A0%87">目标:</a></li><li><a href="#%E5%BB%BA%E8%AE%AE">建议：</a><ul><li><a href="#1-%E6%B5%81%E7%95%85">1. 流畅</a></li><li><a href="#2-%E7%A8%B3%E5%AE%9A">2. 稳定</a></li><li><a href="#21%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96">2.1.内存优化</a></li><li><a href="#22-%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F">2.2. 提高代码质量</a></li><li><a href="#3-%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96">3. 电量优化</a></li><li><a href="#4-%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F">4. 安装包大小</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h2><span id="用户手中好的应用指标">用户手中好的应用指标：</span></h2><ol><li>满足需求</li><li>合理的交互</li><li>高性能</li></ol><h2><span id="android-性能优化总结">Android 性能优化总结</span></h2><h4><span id="目标">目标:</span></h4><ol><li>流畅</li><li>稳定</li><li>省电、省流量</li><li>安装包小</li></ol><p>简称： 快、稳、省、小</p><h4><span id="建议">建议：</span></h4><h5><span id="1-流畅">1. 流畅</span></h5><p>卡顿场景：<br>UI 绘制、应用启动、页面跳转、事件响应</p><p>卡顿原因：</p><ol><li>界面绘制。<blockquote><p>主要原因是绘制的层级深、页面复杂、刷新不合理，由于这些原因导致卡顿的场景更多出现在 UI 和启动后的初始界面以及跳转到页面的绘制上。</p></blockquote></li><li>数据处理。<blockquote><p>导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，一是数据在处理 UI 线程，二是数据处理占用 CPU 高，导致主线程拿不到时间片，三是内存增加导致 GC 频繁，从而引起卡顿。</p></blockquote></li></ol><p>UI 绘制:</p><p>原理： Android 应用程序把经过Measure、Layout、Draw后的 surface 缓存数据，通过 SurfaceFlinger 服务把数据渲染到显示屏幕上， 通过 Android 的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕上。</p><p>卡顿根本原因：</p><ol><li>绘制任务太重，绘制一帧内容耗时太长。</li><li>主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧。</li></ol><p>常用工具：<br>通过性能分析工具 Profile GPU Rendering、TraceView、Systrace UI 性能分析<br>找出出现问题的点，然后解决。</p><p>优化建议：</p><ol><li>布局优化</li><li>避免过度绘制</li><li>启动优化</li><li>合理的刷新机制</li><li>在实现动画效果时，需要根据不同场景选择合适的动画框架来实现。有些情况下，可以用硬件加速方式来提供流畅度。</li></ol><h5><span id="2-稳定">2. 稳定</span></h5><blockquote><p>Android 应用的稳定性定义很宽泛，影响稳定性的原因很多，比如内存使用不合理、代码异常场景考虑不周全、代码逻辑不合理等，都会对应用的稳定性造成影响。其中最常见的两个场景是：Crash 和 ANR，这两个错误将会使得程序无法使用，比较常用的解决方式如下：</p></blockquote><h5><span id="21内存优化">2.1.内存优化</span></h5><p>虚拟机有两种运行模式：Dalvik 和 ART。</p><p>Android 内存控制权 Generational Heap Memory 。</p><ul><li>对象的生命周期：</li></ul><p>创建阶段-&gt;应用阶段-&gt;不可见阶段-&gt;不可达阶段-&gt;收集阶段-&gt;终结阶段-&gt;对象空间重新分配阶段</p><p>Zygote 进程是所有的应用程序进程之父。</p><p>每个应用 都有 Dalvik Heap Size 最大阈值。有 RAM 大小不同会有所差异。</p><ul><li>内存回收<br>young Generation(年轻代)、Old Generation(年老代)、Permanent Generation(持久代)</li></ul><p>根据对象的生命周期、所处的代区域、不同的内存数据类型，执行不同的GC 操作。</p><blockquote><p>分配的对象会存放在 Young Generation 区域。对象在某个时机触发 GC 回收垃圾，而没有回收的就根据不同规则，有可能被移动到 Old Generation，最后累积一定时间在移动到 Permanent Generation 区域。系统会根据内存中不同的内存数据类型分别执行不同的 GC 操作。GC 通过确定对象是否被活动对象引用来确定是否收集对象，进而动态回收无任何引用的对象占据的内存空间。但需要注意的是频繁的 GC 会增加应用的卡顿情况，影响应用的流畅性，因此需要尽量减少系统 GC 行为，以便提高应用的流畅度，减小卡顿发生的概率。</p></blockquote><p>分析工具：</p><ol><li>Memory Monitor</li><li>Heap Viewer</li><li>Allocation Tracker</li><li>Memory Analyzer Tool(MAT)</li><li>LeakCanary 第三方库.</li></ol><p>常见内存泄漏场景:</p><ol><li>资源性对象未关闭。比如Cursor、File文件等，往往都用了一些缓冲，在不使用时，应该及时关闭它们。</li><li>注册对象未注销。比如事件注册后未注销，会导致观察者列表中维持着对象的引用。</li><li>类的静态变量持有大数据对象。</li><li>非静态内部类的静态实例.</li><li>Handler临时性内存泄漏。如果Handler是非静态的，容易导致 Activity 或 Service 不会被回收。</li><li>容器中的对象没清理造成的内存泄漏。</li><li>WebView。WebView 存在着内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。</li></ol><p>优化内存空间：</p><ol><li>对象引用。强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。</li><li>减少不必要的内存开销。注意自动装箱，增加内存复用，比如有效利用系统自带的资源、视图复用、对象池、Bitmap对象的复用。</li><li>使用最优的数据类型。比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，使用缓存Lrucache等等。</li><li>图片内存优化。可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等等。</li></ol><h5><span id="22-提高代码质量">2.2. 提高代码质量</span></h5><blockquote><p>提高代码质量。比如开发期间的代码审核，看些代码设计逻辑，业务合理性等。<br>代码静态扫描工具。常见工具有Android Lint、Findbugs、Checkstyle、PMD等等。<br>Crash监控。把一些崩溃的信息，异常信息及时地记录下来，以便后续分析解决。<br>Crash上传机制。在Crash后，尽量先保存日志到本地，然后等下一次网络正常时再上传日志信息。</p></blockquote><h5><span id="3-电量优化">3. 电量优化</span></h5><ol><li>优化耗时的计算。</li></ol><h5><span id="4-安装包大小">4. 安装包大小</span></h5><ol><li>代码混淆。</li><li>资源优化。比如使用 Android Lint 删除冗余资源。</li><li>图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数、使用 WebP图片格式等。</li><li>避免重复功能的库。</li><li>插件化。</li></ol><h3><span id="参考">参考</span></h3><ul><li><a href="https://blog.dxdoctor.com/2019/06/30/Android-%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Android 应用内存分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://brokge.github.io/tags/Android/"/>
    
      <category term="性能优化" scheme="https://brokge.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android Bundle 详解 </title>
    <link href="https://brokge.github.io/2019/07/10/Android-Bundle/"/>
    <id>https://brokge.github.io/2019/07/10/Android-Bundle/</id>
    <published>2019-07-10T13:20:58.000Z</published>
    <updated>2019-10-09T02:40:48.077Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li>实现</li><li>源码分析</li><li><a href="#parcelable">Parcelable</a><ul><li><a href="#parcel-%E6%98%AF%E4%BB%80%E4%B9%88">Parcel 是什么？</a></li><li><a href="#parcelable-%E5%9C%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E7%94%A8%E6%B3%95">Parcelable 在数据传递的用法</a></li></ul></li><li><a href="#serializable">Serializable</a><ul><li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3%E5%8D%B3%E5%8F%AF%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%86%E5%91%A2">为什么定义标记接口即可实现序列化了呢？</a></li></ul></li><li><a href="#%E6%9C%80%E5%90%8E">最后</a><ul><li><a href="#%E4%B8%A4%E8%80%85%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%A1%B7">两者的设计初衷：</a></li><li><a href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">两者的区别：</a></li><li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景：</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>我们都知道，在 Android 应用开发中，需要数据和状态的传递，其中还包括在 跨进程 之间的传递 （比如 IPC/Binder）。关于数据传递有多种方式，其中最常见的就是通过 Bundle 。Bundle 中文意思：捆; 一批，顾名思义就很直观了。</p><p>Bundle 相当于传输过程的邮包，里面包裹的是具体的数据。</p><h5><span id="实现">实现</span></h5><p>Activity 之间可以通过 创建 intent 并传递参数 的方式来传递，</p><pre class="line-numbers language-java"><code class="language-java">Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> MyActivity<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span><span class="token string">"media_id"</span><span class="token punctuation">,</span> <span class="token string">"a1b2c3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在当前 Activity 打包数据，在 目标 Activity 解包数据。</p><blockquote><p>通过查看 Api ,我们可以知道 一些常规数据类型，如：int、string、boolean 等经过简单的设置，都没什么问题。但是我们如果想通过一定机制，传递一些复杂的复合对象呢？<br>这就需要 Parcelables 了。<br>传递复杂数据 可以查看相应的文章。</p></blockquote><ul><li>通过 Bundle 进行数据，要注意以下问题</li></ul><ol><li>复杂对象 通过  Parcelables 或者 seriable。</li><li>对象最大 不能超过 1 mb,否则会出现 <code>TransactionTooLargeException</code> 错误。7.0 (API level 24) 或更高系统上会报出，其他系统会有警告log。</li><li><code>savedInstanceState</code> 保存数据状态，系统运行中这些保存的数据会一直存在，所以尽可能小于 50kb，否则会照成资源的浪费。</li></ol><p>以上是bundle 如何使用以及需要注意的事项。</p><blockquote><p>Parcel不是通用的序列化机制（Serializable是通用的序列化机制） 所以不能把 Parcel数据存储在磁盘上或通过网络发送出去。</p></blockquote><h5><span id="源码分析">源码分析</span></h5><p>通过源码查看，Bundle 继承 BaseBundle 且实现了 Parcelable 接口。BaseBundle 内部 维护一个 ArrayMap&lt;String, Object&gt; mMap 常量来承载我们需要操作的对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Bundle</span> <span class="token keyword">extends</span> <span class="token class-name">BaseBundle</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> Parcelable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>BaseBundle 声明常量 mMap：</p><pre class="line-numbers language-java"><code class="language-java"> ArrayMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> mMap <span class="token operator">=</span> null<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 </p><pre class="line-numbers language-java"><code class="language-java">Bundle bundle<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Bundle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bundle<span class="token punctuation">.</span><span class="token function">putXX</span><span class="token punctuation">(</span>Object object<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>实际上内部执行的是对 ArrayMap 的操作</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">putXXX</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unparcel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="parcelable">Parcelable</span></h2><p>假设我们需要将<code>String  str = &quot;Hanmeimei&quot;;</code>，从 Activity  A 传递到 Activity B 时，我们可以使用  intent.putExtra(“name”,str ); 这样在 Activity B 中就能获取到由 Activity A 传递过来的字符串 str  .那么如果我想将一个对象由 Activity  A 传递到  Activity B 该怎么办，比如 User 对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> String age<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> password<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPassword</span><span class="token punctuation">(</span>String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>String age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String password<span class="token punctuation">,</span> String age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Android 并没有提供在两个 activity之间传递任意对象或者引用的方法，但是就是需要传递对象该怎么办呢，这个时候就需要  让该对象实现 Android 提供的 parcelable接口，说到 parcelable 就得说Parcel。</p><h3><span id="parcel-是什么">Parcel 是什么？</span></h3><p>简单说Parcel就是一个存放读取数据的容器， Android系统中的binder进程间通信(IPC)就使用了Parcel类来进行客户端与服务端数据的交互，而且AIDL的数据也是通过Parcel来交互的。在Java空间和C++都实现了Parcel，由于它在C/C++中，直接使用了内存来读取数据，因此，它更有效率。Parcel不是通用的序列化机制（Serialize 是通用的序列化机制） 所以不能把 Parcel数据存储在磁盘上或通过网络传输。</p><p>Parcel 的标记接口 是 Parcelable，如果该对象实现了parcelable接口，且实现了对应的方法，就拥有了 Parcel 的特性。</p><h3><span id="parcelable-在数据传递的用法">Parcelable 在数据传递的用法</span></h3><p>在Android 对象传递需求中，那么就可以利用下图红框中的方法进行传递了，putExtra(String name,Parcelable user);可以看出，我们可以传递一个实现 Parcelable接口的对象了</p><h2><span id="serializable">Serializable</span></h2><h3><span id="概念">概念</span></h3><ol><li>序列化就是将对象转化为字节流。</li><li>反序列化就是将字节流转化为对象。</li><li>默认的序列化是深度系列化（即类中嵌套其他对象引用的对象也会被序列化）。</li><li>静态成员不会被默认序列化，要让一个类支持序列化只要让这个类实现接口 java.io.Serializable 即可</li></ol><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> java<span class="token punctuation">.</span>io<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上是 <code>Serializable</code> 的接口定义，且 <code>Serializable</code> 只是一个没有定义任何方法的标记接口。</p><h3><span id="为什么定义标记接口即可实现序列化了呢">为什么定义标记接口即可实现序列化了呢？</span></h3><p>声明实现 <code>Serializable</code> 接口后保存读取对象就可以使用 <code>ObjectOutputStream</code>、<code>ObjectInputStream</code> 流了，<code>ObjectOutputStream</code> 是 <code>OutputStream</code> 的子类，但实现了 <code>ObjectOutput</code> 接口，<code>ObjectOutput</code> 是 <code>DataOutput</code> 的子接口，增加了一个 <code>writeObject(Object obj)</code> 方法将对象转化为字节写到流中，<code>ObjectInputStream</code> 是 <code>InputStream</code> 的子类，实现了<code>ObjectInput</code> 接口，<code>ObjectInput</code> 是 <code>DataInput</code> 的子接口，增加了一个 <code>readObject()</code> 方法从流中读取字节转为对象。</p><blockquote><p>序列化和反序列化的实质在于 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 和 <code>ObjectInputStream</code> 的 <code>readObject</code> 方法实现，常见的 <code>String</code>、<code>Date</code>、<code>Double</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>TreeMap</code> 等都默认实现了 <code>Serializable</code>,.</p></blockquote><p>有时候我们对象有些字段的值可能与内存位置（<code>hashcode</code>）、当前时间等有关，所以我们不想序列化他（因为反序列化后的值是没有意义的）。或者有时候如果类中的字段，表示的是类的实现细节，而非逻辑信息则默认序列化，也是不适合的。</p><p><strong>由于以上原因</strong>：所以我们需要定制序列化，Java 提供的定制主要有<code>transient</code> 关键字方式 和 实现 <code>writeObject</code>、<code>readObject</code> 方式 及 <code>Externalizable</code> 接口 <code>readExternal</code>、<code>writeExternal</code> 方式。还可以将字段声明为 <code>transient</code> 后通过 <code>writeObject</code>、<code>readObject</code> 方法来自己保存该字段。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Transient</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Externalizable.java</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Externalizable</span> <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">writeExternal</span><span class="token punctuation">(</span>ObjectOutput out<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">readExternal</span><span class="token punctuation">(</span>ObjectInput in<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下 Java 会根据类中一系列信息自动生成一个版本号，在反序列化时如果类的定义发生了变化版本号就会变化，也就与反序列化流中的版本号不匹配导致会抛出异常，所以我们为了更好的控制和性能问题会自定义 <code>serialVersionUID</code> 版本号来避免类定义发生变化后反序列化版本号不匹配异常问题，如果版本号一样时流中有该字段而类定义中没有则该字段会被忽略，如果类定义中有而流中没有则该字段会被设为默认值，如果对于同名的字段类型变了则会抛出 <code>InvalidClassException</code>。</p><p>虚拟机是否允许反序列化不仅取决于类路径和功能代码是否一致，还取决于另一个非常重要的点是两个类的序列化 ID 是否一致（就是 <code>private static final long serialVersionUID = 1L</code>）。</p><p>因为声明实现 <code>Serializable</code> 接口后保存读取对象就可以使用 <code>ObjectOutputStream</code>、<code>ObjectInputStream</code> 流了，<code>ObjectOutputStream</code> 的 <code>writeObject(Object obj)</code>方法将对象转化为字节写到流中，<code>ObjectInputStream</code> 的 <code>readObject()</code> 方法从流中读取字节转为对象，<code>Serializable</code> 虽然是一个空接口，但是在调用 <code>writeObject</code> 方法时却充当了一种健全的校验作用，如果对象没有实现 <code>Serializable</code> 则在调用 <code>writeObject</code> 时就会抛出异常，所以说 <code>Serializable</code> 算是一种接口标识机制。</p><p>如下为 <code>ObjectOutputStream</code> 中 <code>writeObject(Object obj)</code> 的核心标记判断：</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject0</span> <span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> <span class="token keyword">boolean</span> unshared<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeClass</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">ObjectStreamClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeClassDesc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ObjectStreamClass<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeString</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Enum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeEnum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span> obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Serializable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">writeOrdinaryObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> desc<span class="token punctuation">,</span> unshared<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>extendedDebugInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n"</span> <span class="token operator">+</span> debugInfoStack<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NotSerializableException</span><span class="token punctuation">(</span>cl<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="最后">最后</span></h2><p>通过以上我们了解 Serializable 和 Parcelable都可以实现复杂数据结构的封装传输，两者的区别是什么？</p><h3><span id="两者的设计初衷">两者的设计初衷：</span></h3><ol><li><strong>Serializable</strong> 的作用是为了保存对象的属性到本地文件、数据库、网络流等以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。</li><li><strong>Parcelable</strong> 的设计初衷是因为Serializable 效率过慢，为了在程序内不同组件间以及不同 Android 程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，而且 Parcelable 是通过 IBinder 通信的消息的载体。</li></ol><h3><span id="两者的区别">两者的区别：</span></h3><ol><li>在使用内存的时候，Parcelable 类比 Serializable 性能高。</li><li>Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。</li><li>Parcelable不能适用在要将数据存储在磁盘上的情况，因为Parcelable 在外界有变化的情况下，不能很好的保证数据的持续性。</li></ol><h3><span id="适用场景">适用场景：</span></h3><ol><li>只在内存中操作数据时，比如两个 Activity 之间 传输数据。</li><li>需要持久化数据时，比如需要将数据保存的本地文件、数据库，所以尽管 Serializable 效率低点， 也不提倡用，但在这种情况下，还是建议你用 Serializable 。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://brokge.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 应用内存分析</title>
    <link href="https://brokge.github.io/2019/06/30/Android-%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/"/>
    <id>https://brokge.github.io/2019/06/30/Android-应用内存分析/</id>
    <published>2019-06-30T02:56:51.000Z</published>
    <updated>2019-10-09T02:41:54.800Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E6%89%80%E9%9C%80%E5%B7%A5%E5%85%B7">所需工具</a><ul><li><a href="#1-mta">1. MTA</a></li><li><a href="#2-androidstudio">2. AndroidStudio</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li><li><a href="#%E5%88%86%E6%9E%90%E5%B0%8F%E6%8A%80%E5%B7%A7">分析小技巧</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>Android 开发场景中，分析内存泄漏情况</p><h2><span id="所需工具">所需工具</span></h2><h3><span id="1-mta">1. MTA</span></h3><p>Eclipse Memory Analysis Tools (MAT) 是一个分析 Java堆数据的专业工具，用它可以定位内存泄漏的原因。</p><p>工具地址 : <a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">https://www.eclipse.org/mat/</a></p><h3><span id="2-androidstudio">2. AndroidStudio</span></h3><ul><li>monitor</li></ul><p>存在 sdk/toools/ 下的 monitor</p><p>Dalvik Debug Monitor Server (DDMS) 是 ADT插件的一部分，其中有两项功能可用于内存检查 :</p><blockquote><ol><li>heap 查看堆的分配情况</li><li>allocation tracker跟踪内存分配情况</li></ol></blockquote><p>DDMS 这两项功能有助于找到内存泄漏的操作行为。</p><ul><li>profiler </li></ul><p>AndroidStudio 内置的 内存检测工具，可以回收内存和下载dump。</p><h2><span id="使用">使用</span></h2><ol><li>通过 AndroidStudio 内置工具 profiler 进行分析并获取到.hprof 文件。</li></ol><blockquote><p>操作步骤</p><ol><li>打开 profiler 窗口。</li><li>切换到 memory .</li><li>针对需要检测的页面，点击 <code>回收箱</code> 按钮，进行强制 GC.然后 点击 <code>下载图标</code> 按钮  获取堆栈信息.</li><li>排序方式 Arrange by package ，查看待检测的泄漏对象。</li><li>导出 .hprof 文件。</li></ol></blockquote><ol start="2"><li>通过 sdk 目录 platform-tools/hprof-conv 工具进行转换</li></ol><pre class="line-numbers language-bash"><code class="language-bash">hrpof-conv -z <span class="token punctuation">[</span>待转换.hprof<span class="token punctuation">]</span>  <span class="token punctuation">[</span>转换后.hprof<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>以上转换后的 .hprof文件，通过 mat 打开，然后点击  histogram 。</li></ol><blockquote><p>进入Histogram<br>可以点击表头进行排序,在表的第一行可以输入正则表达式来匹配结果,找到我们想要找的类，然后右键选择<code>merge shortest paths to Gc roots</code> 然后在选择<code>exclude all phantom/weak/soft etc.references</code>选项.</p></blockquote><h2><span id="分析小技巧">分析小技巧</span></h2><ol><li><code>Histogram</code> 对比</li></ol><p>为查找内存泄漏，通常需要两个 Dump结果作对比，打开 <code>Navigator History</code>面板，将两个表的 <code>Histogram</code>结果都添加到 <code>Compare Basket</code>中去 :<br>添加好后，打开 Compare Basket面板，得到结果。</p><ol start="2"><li>使用 <code>android:largeHeap=&quot;true&quot;</code>标记 (API Level &gt;= 11) </li></ol><p>在 <code>AndroidManifest.xml</code>中的 Application节点中声明即可分配到更大的堆内存, <code>android:largeHeap</code>标记在 Android系统应用中也有广泛的应用 ,比如 Launcher, Browser这些内存大户上均有使用.</p><ol start="3"><li>mat 打开工具栏 <code>QQL</code>图标，可以使用 类sql 语句筛查<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">select</span> * from instanceof android.app.Activity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>mat 中 Actions 中的概念</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Histogram</span>列出内存中的对象，对象的个数以及大小。<span class="token comment" spellcheck="true"># Dominator Tree</span>列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）。<span class="token comment" spellcheck="true"># Top Consumers</span>通过图形列出最大的object。<span class="token comment" spellcheck="true"># Shallow heap</span>Shallow size就是对象本身占用内存的大小，不包含其引用的对象。针对非数组类型的对象，它的大小就是对象与它所有的成员变量大小的总和。当然这里面还会包括一些java语言特性的数据存储单元。针对数组类型的对象，它的大小是数组元素对象的大小总和。<span class="token comment" spellcheck="true">#Retained Heap</span>它表示如果一个对象被释放掉，那会因为该对象的释放而减少引用进而被释放的所有的对象（包括被递归释放的）所占用的heap大小。<span class="token punctuation">(</span>间接引用的含义：A-<span class="token operator">></span>B-<span class="token operator">></span>C, C就是间接引用。不过，释放的时候还要排除被GC Roots直接或间接引用的对象。他们暂时不会被被当做Garbage）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://brokge.github.io/tags/Android/"/>
    
      <category term="性能优化" scheme="https://brokge.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android 多线程开发实践</title>
    <link href="https://brokge.github.io/2019/05/20/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    <id>https://brokge.github.io/2019/05/20/Android-多线程开发实践/</id>
    <published>2019-05-20T13:04:23.000Z</published>
    <updated>2019-10-09T02:41:37.109Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E7%89%B9%E7%82%B9">特点：</a></li><li><a href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7">线程优先级</a></li><li><a href="#%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E9%9C%80%E8%A6%81%E6%96%B0%E7%BA%BF%E7%A8%8B">是否真的需要新线程？</a></li><li><a href="#asynctask">AsyncTask</a></li><li><a href="#handlerthread">HandlerThread</a></li><li><a href="#threadpoolexecutor">ThreadPoolExecutor</a></li><li><a href="#intentservice">IntentService</a></li><li><a href="#%E7%BB%93%E6%9D%9F%E8%AF%AD">结束语</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><h3><span id="特点">特点：</span></h3><ol><li>并行处理任务。</li><li>存在 线程数据安全、死锁、内存消耗、对象的生命周期管理、ui 的卡顿 等等。</li><li>存在优先级。</li></ol><h3><span id="线程优先级">线程优先级</span></h3><p>线程寄宿在进程当中，线程的生命周期直接被进程所影响，而进程的存活又和其优先级直接相关。在处理进程优先级的时候，大部分人靠直觉都能知道前台进程（<code>Foreground Process</code>）优先级要高于后台进程（<code>Background Process</code>）。但这种粗糙的划分无法满足操作系统高精度调度的需求。无论 Android 还是 iOS，系统对于 Foreground，Background 进程有进一步的细化。</p><ol><li>Foreground Process</li></ol><p>Foreground一般意味着用户双眼可见，可见却不一定是active。在Android的世界里，一个Activity处于前台之时，如果能采集用户的input事件，就可以判定为active，如果中途弹出一个Dialog，Dialog变成新的active实体，直接面对用户的操作。被部分遮挡的activity尽管依然可见，但状态却变为inactive。不能正确的区分visible和active</p><ol start="2"><li>Background Process</li></ol><p>后台进程同样有更细的划分。所谓的Background可以理解为不可见（invisible）。对于不可见的任务，Android也有重要性的区分。重要的后台任务定义为Service，如果一个进程包含Service（称为Service Process），那么在“重要性”上就会被系统区别对待，其优先级自然会高于不包含Service的进程（称为Background Process），最后还剩一类空进程（Empty Process）。Empty Process初看有些费解，一个Process如果什么都不做，还有什么存在的必要。其实Empty Process并不Empty，还存在不少的内存占用。</p><p>在iOS的世界里，Memory被分为Clean Memory和Dirty Memory，Clean Memory是App启动被加载到内存之后原始占用的那一部分内存，一般包括初始的stack, heap, text, data等segment，Dirty Memory是由于用户操作所改变的那部分内存，也就是App的状态值。系统在出现Low Memory Warning的时候会首先清掉Dirty Memory，对于用户来说，操作的进度就全部丢失了，即使再次点击App图标，也是一切从头开始。但由于Clean Memory没有被清除，避免了从磁盘重新读取app数据的io损耗，启动会变快。这也是为什么很多人会感觉手机重启后，app打开的速度都比较慢。</p><p>同理Android世界当中的Empty Process还保存有App相关的Clean Memory，这部分Memory对于提升App的启动速度大有帮助。显而易见Empty Process的优先级是最低的。</p><table><thead><tr><th>线程状态</th><th>优先级</th></tr></thead><tbody><tr><td>Active</td><td>Top</td></tr><tr><td>Visible</td><td>High</td></tr><tr><td>Service</td><td>High</td></tr><tr><td>Background</td><td>Low</td></tr><tr><td>Empty</td><td>Low</td></tr></tbody></table><p>Android将线程分为多个group，其中两类group尤其重要。一类是default group，UI线程属于这一类。另一类是background group，工作线程应该归属到这一类。background group当中所有的线程加起来总共也只能分配到5～10%的time slice，剩下的全部分配给default group，这样设计显然能保证UI线程绘制UI的流畅性。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Process<span class="token punctuation">.</span><span class="token function">setThreadPriority</span><span class="token punctuation">(</span>Process<span class="token punctuation">.</span>THREAD_PRIORITY_BACKGROUND<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以在我们决定新启一个线程执行任务的时候，首先要问自己这个任务在完成时间上是否重要到要和UI线程争夺CPU资源。如果不是，降低线程优先级将其归于background group，如果是，则需要进一步的profile看这个线程是否造成UI线程的卡顿。</p><p>虽说Android系统在任务调度上是以线程为基础单位，设置单个thread的优先级也可以改变其所属的control groups，从而影响CPU time slice的分配。但进程的属性变化也会影响到线程的调度，当一个App进入后台的时候，该App所属的整个进程都将进入background group，以确保处于foreground，用户可见的新进程能获取到尽可能多的CPU资源。用adb可以查看不同进程的当前调度策略。</p><pre class="line-numbers language-shell"><code class="language-shell">adb shell ps -P<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当你的App重新被用户切换到前台的时候，进程当中所属的线程又会回归的原来的group。在这些用户频繁切换的过程当中，thread的优先级并不会发生变化，但系统在time slice的分配上却在不停的调整。</p><h3><span id="是否真的需要新线程">是否真的需要新线程？</span></h3><p>开线程并不是提升App性能，解决UI卡顿的万金油。每一个新启的线程会消耗至少64KB的内存，系统在不同的线程之间switch context也会带来额外的开销。如果随意开启新线程，随着业务的膨胀，很容易在App运行的某个时间点发现几十个线程同时在运行。后果是原本想解决UI流畅性，却反而导致了偶现的不可控的卡顿。</p><p>移动端App新启线程一般都是为了保证UI的流畅性，增加App用户操作的响应度。但是否需要将任务放入工作线程需要先了解任务的瓶颈在哪，是i/o，gpu还是cpu？UI出现卡顿并不一定是UI线程出现了费时的计算，有可能是其它原因，比如layout层级太深。</p><p>尽量重用已有的工作线程（使用线程池）可以避免出现大量同时活跃的线程，比如对HTTP请求设置最大并发数。或者将任务放入某个串行的队列（HandlerThread）按顺序执行，工作线程任务队列适合处理大量耗时较短的任务，避免出现单个任务阻塞整个队列的情况。</p><p>用什么姿势开线程？</p><p>常用的方式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式仅仅是起动了一个新的线程，没有任务的概念，不能做状态的管理。start之后，run当中的代码就一定会执行到底，无法中途取消。</p><p>==Runnable作为匿名内部类还持有了外部类的引用，在线程退出之前，该引用会一直存在，阻碍外部类对象被GC回收，在一段时间内造成内存泄漏==。</p><p>没有线程切换的接口，要传递处理结果到UI线程的话，需要写额外的线程切换代码。</p><p>如果从UI线程启动，则该线程优先级默认为Default，归于default cgroup，会平等的和UI线程争夺CPU资源。这一点尤其需要注意，在对UI性能要求高的场景下要记得</p><pre class="line-numbers language-java"><code class="language-java">Process<span class="token punctuation">.</span><span class="token function">setThreadPriority</span><span class="token punctuation">(</span>Process<span class="token punctuation">.</span>THREAD_PRIORITY_BACKGROUND<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽说处于background group的线程总共只能争取到5～10%的CPU资源，但这对绝大部分的后台任务处理都绰绰有余了，1ms和10ms对用户来说，都是快到无法感知，所以我们一般都偏向于在background group当中执行工作线程任务。</p><h3><span id="asynctask">AsyncTask</span></h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAsyncTask</span> <span class="token keyword">extends</span> <span class="token class-name">AsyncTask</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> Object <span class="token function">doInBackground</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onPreExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPreExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onPostExecute</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onPostExecute</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和使用Thread()不同的是，多了几处API回调来严格规范工作线程与UI线程之间的交互。我们大部分的业务场景几乎都符合这种规范，比如去磁盘读取图片，缩放处理需要在工作线程执行，最后绘制到ImageView控件需要切换到UI线程。</p><p>AsyncTask的几处回调都给了我们机会去中断任务，在任务状态的管理上较之Thread()方式更为灵活。值得注意的是AsyncTask的cancel()方法并不会终止任务的执行，开发者需要自己去检查cancel的状态值来决定是否中止任务。</p><p>==AsyncTask也有隐式的持有外部类对象引用的问题，需要特别注意防止出现意外的内存泄漏。==</p><p>AsyncTask由于在不同的系统版本上串行与并行的执行行为不一致，被不少开发者所诟病，这确实是硬伤，绝大部分的多线程场景都需要明确任务是串行还是并行。</p><p>线程优先级为background，对UI线程的执行影响极小。</p><h3><span id="handlerthread">HandlerThread</span></h3><p>在需要对多任务做更精细控制，线程切换更频繁的场景之下，Thread()和AsyncTask都会显得力不从心。HandlerThread却能胜任这些需求甚至更多。</p><p>HandlerThread将Handler，Thread，Looper，MessageQueue几个概念相结合。Handler是线程对外的接口，所有新的message或者runnable都通过handler post到工作线程。Looper在MessageQueue取到新的任务就切换到工作线程去执行。不同的post方法可以让我们对任务做精细的控制，什么时候执行，执行的顺序都可以控制。HandlerThread最大的优势在于引入MessageQueue概念，可以进行多任务队列管理。</p><p>HandlerThread背后只有一个线程，所以任务是==串行==执行的。串行相对于并行来说更安全，各任务之间不会存在多线程安全问题。</p><p>==HandlerThread所产生的线程会一直存活==，Looper会在该线程中持续的检查MessageQueue。这一点和Thread()，AsyncTask都不同，thread实例的重用可以避免线程相关的对象的频繁重建和销毁。</p><p>HandlerThread较之Thread()，AsyncTask需要写更多的代码，但在实用性，灵活度，安全性上都有更好的表现。</p><h3><span id="threadpoolexecutor">ThreadPoolExecutor</span></h3><p>Thread(),AsyncTask适合处理单个任务的场景，HandlerThread适合串行处理多任务的场景。当需要并行的处理多任务之时，ThreadPoolExecutor是更好的选择。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Executor THREAD_POOL_EXECUTOR            <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>CORE_POOL_SIZE<span class="token punctuation">,</span> MAXIMUM_POOL_SIZE<span class="token punctuation">,</span> KEEP_ALIVE<span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> sPoolWorkQueue<span class="token punctuation">,</span> sThreadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>线程池可以避免线程的频繁创建和销毁，显然性能更好，但线程池并发的特性往往也是疑难杂症的源头，是代码降级和失控的开始。多线程并行导致的bug往往是偶现的，不方便调试，一旦出现就会耗掉大量的开发精力。</p><p>ThreadPool较之HandlerThread在处理多任务上有更高的灵活性，但也带来了更大的复杂度和不确定性。</p><h3><span id="intentservice">IntentService</span></h3><p>不得不说Android在API设计上粒度很细，同一样工作可以通过各种不同的类来完成。IntentService又是另一种开工作线程的方式，从名字就可以看出这个工作线程会带有service的属性。和AsyncTask不同，没有和UI线程的交互，也不像HandlerThread的工作线程会一直存活。IntentService背后其实也有一个HandlerThread来串行的处理Message Queue，从IntentService的onCreate方法可以看出：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO: It would be nice to have an option to hold a partial wakelock</span>        <span class="token comment" spellcheck="true">// during processing, and to have a static startService(Context, Intent)</span>        <span class="token comment" spellcheck="true">// method that would launch the service &amp; hand off a wakelock.</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HandlerThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HandlerThread</span><span class="token punctuation">(</span><span class="token string">"IntentService["</span> <span class="token operator">+</span> mName <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mServiceLooper <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mServiceHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceHandler</span><span class="token punctuation">(</span>mServiceLooper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只不过在所有的Message处理完毕之后，工作线程会自动结束。所以可以把IntentService看做是Service和HandlerThread的结合体，适合需要在工作线程处理UI无关任务的场景。</p><h3><span id="结束语">结束语</span></h3><p>Android开线程的方式虽然五花八门，但归根到底最后还是映射到linux下的pthread，业务的设计还是脱不了和线程相关的基础概念范畴：线程的执行顺序，调度策略，生命周期，串行还是并行，同步还是异步等等。摸清楚各类API下线程的行为特点，在设计具体业务的线程模型的时候自然轻车熟路了，线程模型的设计要有整个app视角的广度，切忌各业务模块各玩各的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://brokge.github.io/tags/Android/"/>
    
      <category term="线程" scheme="https://brokge.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android Dagger2分析</title>
    <link href="https://brokge.github.io/2019/04/16/Android-Dagger2%E5%88%86%E6%9E%90/"/>
    <id>https://brokge.github.io/2019/04/16/Android-Dagger2分析/</id>
    <published>2019-04-16T13:01:11.000Z</published>
    <updated>2019-10-09T02:41:08.840Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc" target="_blank" rel="noopener">DocToc</a></em></p><ul><li><a href="#%E6%B3%A8%E8%A7%A3">注解</a></li><li><a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</a></li><li><a href="#%E5%8F%8D%E5%B0%84">反射</a></li><li><a href="#%E5%9F%BA%E4%BA%8E-javaxinject">基于 javax.inject </a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><!--toc--><p><a href="https://google.github.io/dagger/" target="_blank" rel="noopener">官方地址 </a></p><p><a href="https://blog.csdn.net/briblue/article/details/75578459" target="_blank" rel="noopener">参考博客地址</a></p><h3><span id="注解">注解</span></h3><h3><span id="依赖注入">依赖注入</span></h3><p>Dagger2 是一个依赖注入框架，依赖注入的目的就是为了给需求方在合适的时候注入依赖。<br><strong>@Inject</strong><br>@Inject 注解就如同一个标签，或者说它是一个记号，它是给 Dagger2 看的。它运用的地方有两处。</p><ul><li><p>@Inject 给一个类的相应的属性做标记时，说明了它是一个依赖需求方，需要一些依赖。</p></li><li><p>@Inject 给一个类的构造方法进行注解时，表明了它能提供依赖的能力。</p></li></ul><p>就这样，通过 @Inject 注解符号，就很容易标记依赖和它的需求方。但是，单单一个 @Inject 是不能让 Dagger2 正常运行的。还需要另外一个注解配合。这个注解就是 @Component。</p><p><strong>@Component</strong></p><p>而 @Component 相当于联系纽带，将 @inject 标记的需求方和依赖绑定起来，并建立了联系，而 Dagger2 在编译代码时会依靠这种关系来进行对应的依赖注入</p><p><strong>@Provides 和 @Module</strong><br>Dagger2 为了能够对第三方库中的类进行依赖注入，提供了 @Provides 和 @Module 两个注解。</p><p>Provide 本身的字面意思就是提供，显然在 Dagger2 中它的作用就是提供依赖。 </p><p>Module 是模块的意思，Dagger2 中规定，用 @Provides 注解的依赖必须存在一个用 @Module 注解的类中。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7cb82d844f92dfa47016fa2fda60e58d?method=download&amp;shareKey=32e575c6c38ade13609fae051ed17920" alt="image"></p><p><strong>@Inject 和 @Provides 的优先级</strong></p><p>Baozi 这个类就符合我上面给的情景，一方面它确实拥有被 @Inject 注解过的构造方法，另一方面在 Module 中它又通过 @Provides 提供了依赖。那么，最终，Dagger2 采取了哪一种呢？</p><p>答案是 Module，其实现象我们在之前的测试时已经可以观察到了，最终屏幕显示的是豆沙包选项。</p><p>Dagger2 依赖查找的顺序是先查找 Module 内所有的 @Provides 提供的依赖，如果查找不到再去查找 @Inject 提供的依赖。</p><p><strong>Dagger2 中的单例 @Singleton</strong></p><ul><li>用 @Singleton 标注在目标单例上，然后用 @Singleton 标注在 Component 对象上。</li><li><p>如果要以 @Provides 方式提供单例的话，需要用 @Singleton 注解依赖提供的方法</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token annotation punctuation">@Module</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecondActivityModule</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Provides</span>     <span class="token annotation punctuation">@Singleton</span>     <span class="token keyword">public</span> TestSingleton <span class="token function">provideTestSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TestSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>@Singleton 是一个注解，但是它被一个元注解 @Scope 注解了</li><li>为什么要用 @Singleton 同时标注 @Provides 和 @Component ?<blockquote><p>Component 是联系需求与依赖的纽带，所以用 @Singleton 确定的单例作用域应该也是在 Component 的范围内。也就是说 @Scope 的作用范围其实就是单例能力范围，这个范围在单个的 Component 中.</p></blockquote></li></ul><p><strong>@Qualifiers 和 @Name</strong></p><p>@Name 只是被 @Qualifier 注解的一个注解。所以，它能够有效完全是因为 @Qualifier</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Qualifier</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The name. */</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完全可以自定义不同的注解，避免通过 Named 的方式容易拼错的问题。 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Qualifier</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用时</p><pre class="line-numbers language-java"><code class="language-java">   <span class="token annotation punctuation">@Provides</span>    <span class="token annotation punctuation">@Named</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">provideIntA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">111</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Provides</span>    <span class="token annotation punctuation">@B</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">provideIntB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">222</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Inject</span>    <span class="token annotation punctuation">@Named</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span>    <span class="token keyword">int</span> testValueA<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Inject</span>    <span class="token annotation punctuation">@B</span>    <span class="token keyword">int</span> testValueB<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Dagger2 中的延迟加载</strong></p><p>所谓的延迟加载，是当我们使用的时候再去实例化,比如以下方式。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestLazy</span> <span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> name <span class="token operator">==</span> null <span class="token punctuation">)</span> <span class="token punctuation">{</span>            name <span class="token operator">=</span> <span class="token string">"TestLazy"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dagger2 提供了延迟加载能力。只需要通过 Lazy 就好了，Lazy 是泛型类，接受任何类型的参数。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestLazy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Inject</span>    <span class="token annotation punctuation">@Named</span><span class="token punctuation">(</span><span class="token string">"TestLazy"</span><span class="token punctuation">)</span>    Lazy<span class="token operator">&lt;</span>String<span class="token operator">></span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多个component之间的依赖</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> <span class="token punctuation">{</span>ShangjiaAModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> XiaoChiModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>dependencies <span class="token operator">=</span> XiaoChiComponent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>SubComponent</strong><br>Java 软件开发中，我们经常面临的就是“组合”和“继承”的概念。它们都是为了扩展某个类的功能。<br>前面的 Component 的依赖采用 @Component(dependecies=othercomponent.class) 就相当于组合。<br>那么在 Dagger2 中，运用 @SubComponent 标记一个 Component 的行为相当于继承。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Subcomponent</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> FoodModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SubComponent</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThirdActivity activity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Component</span><span class="token punctuation">(</span>modules <span class="token operator">=</span> XiaoChiModule<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ParentComponent</span> <span class="token punctuation">{</span>    SubComponent <span class="token function">provideSubComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>DaggerParentComponent<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">provideSubComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 Subcomponent 时，还是要先构造 ParentComponent 对象，然后通过它提供的 SubComponent 再去进行依赖注入。</p><p>大家可以细细观察下它与 depedency 方法的不同之处。</p><p>但是，SubComponent 同时具备了 ParentComponent 和自身的 @Scope 作用域。所以，这经常会造成混乱的地方。大家需要注意。</p><p>如果你要我比较，SubComponent 和 dependency 形式哪种更好时，我承认各有优点，但我自己倾向于 dependency，因为它更灵活。</p><p>不是说 组合优于继承嘛。</p><h3><span id="反射">反射</span></h3><h3><span id="基于-javaxinject">基于 </span></h3><p>Dagger 2 是一个设计非常巧妙且粗暴的框架。为什么说巧妙呢？</p><ol><li>Dagger 是为Android和Java平台提供的一个完全静态的，在编译时进行依赖注入的框架。</li><li>Dagger 通过生成中间代码，解决了基于反射带来的开发和性能上的问题。</li><li>Dagger 通过编译的时候进行依赖注入的框架。</li><li>Dagger 与其他依赖注入框架不同，它是通过apt插件在编译阶段生成相应的注入代码</li><li>Dagger 的目的为了降低程序耦合。</li></ol><p>总之：他是在编译的时候完成了一切所需要的工作，提供一种使用方便、耦合度低、避免了通过反射带来的性能问题。</p><p>为什么说粗暴呢？使用的时候简单几个注解就可以了，但是 在编译阶段通过 apt 插件生成了全部的注入代码。而且代码量还不小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="https://brokge.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射进阶</title>
    <link href="https://brokge.github.io/2019/02/15/Java-%E5%8F%8D%E5%B0%84%E8%BF%9B%E9%98%B6/"/>
    <id>https://brokge.github.io/2019/02/15/Java-反射进阶/</id>
    <published>2019-02-15T12:46:34.000Z</published>
    <updated>2019-10-09T02:43:52.634Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E4%B8%80%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AF%B9%E8%B1%A1">一、获取不存在的对象？</a><ul><li><a href="#1-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-class-%E5%AF%B9%E8%B1%A1">1. 获取不到 class 对象</a></li><li><a href="#2-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-field">2. 获取不到 Field</a></li><li><a href="#3-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-method">3. 获取不到 Method</a></li><li><a href="#4-%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0-constructor">4. 获取不到 Constructor</a></li><li><a href="#5-getinterfaces-%E7%9A%84%E4%BD%9C%E7%94%A8">5. getInterfaces() 的作用</a></li></ul></li><li><a href="#%E4%BA%8C%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">二、反射中的权限问题</a><ul><li><a href="#1-%E6%93%8D%E7%BA%B5%E9%9D%9E-public-%E4%BF%AE%E9%A5%B0%E7%9A%84-field">1. 操纵非 public 修饰的 Field</a></li><li><a href="#2-%E6%93%8D%E7%BA%B5%E4%B8%80%E4%B8%AA-final-%E7%B1%BB%E5%9E%8B%E7%9A%84-field">2. 操纵一个 final 类型的 Field</a></li><li><a href="#3-%E6%93%8D%E7%BA%B5%E9%9D%9E-public-%E4%BF%AE%E9%A5%B0%E7%9A%84-method">3. 操纵非 public 修饰的 Method</a></li><li><a href="#4-%E6%93%8D%E7%BA%B5%E9%9D%9E-public-%E4%BF%AE%E9%A5%B0%E7%9A%84-constructor">4. 操纵非 public 修饰的 Constructor</a></li></ul></li><li><a href="#%E4%B8%89setaccessible-%E7%9A%84%E7%A7%98%E5%AF%86">三、setAccessible() 的秘密</a></li><li><a href="#%E5%9B%9Bclassnewinstance-%E5%92%8C-constructornewinstance-%E7%9A%84%E5%8C%BA%E5%88%AB">四、Class.newInstance() 和 Constructor.newInstance() 的区别</a></li><li><a href="#%E4%BA%94%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8-methodinvoke-%E6%96%B9%E6%B3%95">五、谨慎使用 Method.invoke() 方法</a></li><li><a href="#%E5%85%AD%E6%80%BB%E7%BB%93">六、总结</a></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p><a href="https://blog.csdn.net/briblue/article/details/76223206" target="_blank" rel="noopener">参考博客</a></p><h2><span id="一-获取不存在的对象">一、获取不存在的对象？</span></h2><h3><span id="1-获取不到-class-对象">1. 获取不到 class 对象</span></h3><ol><li>通过一个对象的 getClass() 方法。</li><li>通过 .class 关键字。</li><li>通过 Class.forName()。</li></ol><p>抛出 ClassNotFoundException 异常。</p><h3><span id="2-获取不到-field">2. 获取不到 Field</span></h3><p>获取不到 Field 的情况分3种：</p><ul><li><p>确实不存在这个 Field </p><p>抛出 NoSuchFieldException</p></li><li><p>由于修饰符导致的权限问题。</p><p>抛出 SecurityException</p></li><li><p>Field 存在，但获取不到</p><p>抛出 NoSuchFieldException </p></li></ul><p>针对 Field 存在，但获取不到情况：<br>由于 getField 和 getDeclaredField 在父类获取的限制。可以先获取 当前类的 父类，即 superClass ，然后 通过 getField或者getDeclaredField的方式获取</p><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">superClass</span> <span class="token operator">=</span> clzBase<span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3><span id="3-获取不到-method">3. 获取不到 Method</span></h3><ul><li><p>获取本身就不存在的 Method</p><p> 抛出 NoSuchMethodException</p></li><li><p>参数类型不匹配而找不到</p><p> 抛出NoSuchMethodException，传递参数的方式：</p></li></ul><pre class="line-numbers language-java"><code class="language-java">Method methodtest <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">float</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Method methodtest <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span><span class="token keyword">float</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3><span id="4-获取不到-constructor">4. 获取不到 Constructor</span></h3><p>与 method 的类似</p><h3><span id="5-getinterfaces-的作用">5. getInterfaces() 的作用</span></h3><p>大家可能都会觉得 getInterfaces() 的作用是获取一个类中定义的接口，但是其实不是的，getInterfaces() 获取的是一个类所有实现的接口。</p><h2><span id="二-反射中的权限问题">二、反射中的权限问题</span></h2><h3><span id="1-操纵非-public-修饰的-field">1. 操纵非 public 修饰的 Field</span></h3><p>抛出 IllegalAccessException 错误</p><pre class="line-numbers language-java"><code class="language-java">field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我这里以 private 为例，其实 protected 和 default 也是一样的，但是它们不同于 private 的地方在于，它们在本 package 范围内是可见的，有兴趣的同学可以测试一下，测试代码在一个 package，而测试的类在另外一个 package。</p><h3><span id="2-操纵一个-final-类型的-field">2. 操纵一个 final 类型的 Field</span></h3><p>抛出 IllegalAccessException 错误</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然被 public 修饰，但是它同样被 final 修饰，这在正常的开发流程说明这个属性不能够再被改变。</p><p>如果要解决这个问题，同样可以使用 setAccessible(true) 方法</p><h3><span id="3-操纵非-public-修饰的-method">3. 操纵非 public 修饰的 Method</span></h3><pre class="line-numbers language-java"><code class="language-java">method<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过 setAccessible(true) 同样可以解决这个问题。</p><h3><span id="4-操纵非-public-修饰的-constructor">4. 操纵非 public 修饰的 Constructor</span></h3><p>同前面两种，同样是通过 setAccessible(true) 来搞定。</p><p>所以，在反射中如果要操作被 private 修饰的对象，那么就必须调用它的 setAccessible(true)。</p><h2><span id="三-setaccessible-的秘密">三、setAccessible() 的秘密</span></h2><p>我们已经知道 Field、Method 和 Constructor 都有 setAccessible() 这个方法，至于是什么呢？这是因为它们有共同的祖先 AccessObject。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AccessibleObject</span> <span class="token keyword">implements</span> <span class="token class-name">AnnotatedElement</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> flag<span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span class="token punctuation">{</span>        SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> sm<span class="token punctuation">.</span><span class="token function">checkPermission</span><span class="token punctuation">(</span>ACCESS_PERMISSION<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setAccessible0</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* Check that you aren't exposing java.lang.Class.&lt;init> or sensitive       fields in java.lang.Class. */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setAccessible0</span><span class="token punctuation">(</span>AccessibleObject obj<span class="token punctuation">,</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">)</span>        <span class="token keyword">throws</span> SecurityException    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Constructor</span> <span class="token operator">&amp;&amp;</span> flag <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token punctuation">(</span>Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>obj<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Class<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span><span class="token punctuation">(</span><span class="token string">"Cannot make a java.lang.Class"</span> <span class="token operator">+</span>                                            <span class="token string">" constructor accessible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        obj<span class="token punctuation">.</span>override <span class="token operator">=</span> flag<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Get the value of the {@code accessible} flag for this object.     *     * @return the value of the object's {@code accessible} flag     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAccessible</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> override<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，主要是设置内部一个 override 变量。</p><p>那么，我们以 Method 的 invoke 方法为例。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span>           InvocationTargetException<span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>override<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Reflection<span class="token punctuation">.</span><span class="token function">quickCheckMemberAccess</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller <span class="token operator">=</span> Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">checkAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    MethodAccessor ma <span class="token operator">=</span> methodAccessor<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// read volatile</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ma <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ma <span class="token operator">=</span> <span class="token function">acquireMethodAccessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ma<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果一个 Method 的 overide 为 false 的话，它就会根据 Modifiers 判断是否具有访问权限。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">quickCheckMemberAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> memberClass<span class="token punctuation">,</span><span class="token keyword">int</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> Modifier<span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span><span class="token function">getClassAccessFlags</span><span class="token punctuation">(</span>memberClass<span class="token punctuation">)</span> <span class="token operator">&amp;</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法主要是简单地判断 modifiers 是不是 public，如果不是的话就返回 false。所以 protected、private、default 修饰符都会返回 false,只有 public 都会返回 true。</p><p>而不是 public 修饰的话会执行下面的代码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">checkAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">,</span> Object obj<span class="token punctuation">,</span> <span class="token keyword">int</span> modifiers<span class="token punctuation">)</span><span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>caller <span class="token operator">==</span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// quick check</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// ACCESS IS OK</span>    <span class="token punctuation">}</span>    Object cache <span class="token operator">=</span> securityCheckCache<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// read volatile</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> clazz<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">!=</span> null        <span class="token operator">&amp;&amp;</span> Modifier<span class="token punctuation">.</span><span class="token function">isProtected</span><span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span>        <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>targetClass <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Must match a 2-list of { caller, targetClass }.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token keyword">instanceof</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> cache2 <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> cache<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cache2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> targetClass <span class="token operator">&amp;&amp;</span>                cache2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> caller<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// ACCESS IS OK</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// (Test cache[1] first since range check for [1]</span>            <span class="token comment" spellcheck="true">// subsumes range check for [0].)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">==</span> caller<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Non-protected case (or obj.class == this.clazz).</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// ACCESS IS OK</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// If no return, fall through to the slow path.</span>    <span class="token function">slowCheckMemberAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Keep all this slow stuff out of line:</span><span class="token keyword">void</span> <span class="token function">slowCheckMemberAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz<span class="token punctuation">,</span> Object obj<span class="token punctuation">,</span> <span class="token keyword">int</span> modifiers<span class="token punctuation">,</span>                           Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass<span class="token punctuation">)</span>    <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">{</span>    Reflection<span class="token punctuation">.</span><span class="token function">ensureMemberAccess</span><span class="token punctuation">(</span>caller<span class="token punctuation">,</span> clazz<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Success: Update the cache.</span>    Object cache <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>targetClass <span class="token operator">==</span> clazz<span class="token punctuation">)</span>                    <span class="token operator">?</span> caller                    <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> caller<span class="token punctuation">,</span> targetClass <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Note:  The two cache elements are not volatile,</span>    <span class="token comment" spellcheck="true">// but they are effectively final.  The Java memory model</span>    <span class="token comment" spellcheck="true">// guarantees that the initializing stores for the cache</span>    <span class="token comment" spellcheck="true">// elements will occur before the volatile write.</span>    securityCheckCache <span class="token operator">=</span> cache<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// write volatile</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最终通过 Reflection 这个类的静态方法 ensureMemberAccess() 确认。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ensureMemberAccess</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> currentClass<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> memberClass<span class="token punctuation">,</span>Object target<span class="token punctuation">,</span><span class="token keyword">int</span> modifiers<span class="token punctuation">)</span><span class="token keyword">throws</span> IllegalAccessException    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentClass <span class="token operator">==</span> null <span class="token operator">||</span> memberClass <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">verifyMemberAccess</span><span class="token punctuation">(</span>currentClass<span class="token punctuation">,</span> memberClass<span class="token punctuation">,</span> target<span class="token punctuation">,</span> modifiers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">(</span><span class="token string">"Class "</span> <span class="token operator">+</span> currentClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                                             <span class="token string">" can not access a member of class "</span> <span class="token operator">+</span>                                             memberClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                                             <span class="token string">" with modifiers \""</span> <span class="token operator">+</span>                                             Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>modifiers<span class="token punctuation">)</span> <span class="token operator">+</span>                                             <span class="token string">"\""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有访问权限，程序将会在此抛出一个 IllegalAccessException 的异常。</p><p>所以，如果通过反射方式去操作一个 Field、Method 或者是 Constructor，最好先调用它的 setAccessible(true) 以防止程序运行异常。</p><h2><span id="四-classnewinstance-和-constructornewinstance-的区别">四、Class.newInstance() 和 Constructor.newInstance() 的区别</span></h2><p>Class.newInstance() 的使用有严格的限制，那就是一个 Class 对象中，必须存在一个无参数的 Constructor，并且这个 Constructor 必须要有访问的权限。</p><p>通过 Constructor.newInstance() 却没有这种限制。Constructor.newInstance() 适应任何类型的 Constructor,无论它们有参数还是无参数，只要通过 setAccessible() 控制好访问权限就可以了。</p><h2><span id="五-谨慎使用-methodinvoke-方法">五、谨慎使用 Method.invoke() 方法</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span>           InvocationTargetException<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一个 Object 参数代表的是对应的 Class 对象实例，这在上面一节已经见识到了。而后面的参数就是可变形参了，它接受多个参数。我们考虑一种特殊情况。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestT</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个泛型类，T 表示接受任意类型的参数。</p><pre class="line-numbers language-java"><code class="language-java"> Method tMethod <span class="token operator">=</span> clzT<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tMethod<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> tMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestT</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>报错 ：<br>NoSuchMethodException，提示找不到这个方法。原因是类型擦除。<br>当一个方法有泛型参数时，编译器会自动向上转型，T 向上转型是 Object。所以实际上是 void test(Object t); 上面的代码试图去找 test(Integer t) 这个方法，自然是找不到。</p><pre class="line-numbers language-java"><code class="language-java">Method tMethod <span class="token operator">=</span> clzT<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tMethod<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tMethod<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestT</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在 Java 反射中，一个 Method 执行时遭遇的异常会被包装在一个特定的异常中，这个异常就是 InvocationTargetException。</p><h2><span id="六-总结">六、总结</span></h2><table><thead><tr><th>异常名称</th><th>原因</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>1. class.forName() 传入的包名有误 2.Class本身不存在</td></tr><tr><td>NoSuchFieldException</td><td>1. Field 名称不正确。2. getDeclaredField 和 getField()方法使用不当。</td></tr><tr><td>NoSuchMethodException</td><td>1. 方法本身不存在。2. 传入的参数的类型不匹配。3. 传入的参数 个数不匹配。</td></tr><tr><td>IllegalAccessException</td><td>1. 访问非 public修饰的对象如Field、Method、Consturctor。2. 操作 final 修饰的 Field.</td></tr><tr><td>IllegalArgumentException</td><td>1. Method.invoke 中参数匹配。2. Field 操作时设置的值不匹配。3. Constructor.newInstance() 传入的参数不匹配。</td></tr><tr><td>InvocationTargetException</td><td>1. Method 运行时产生异常.2.Constructor.newInstance() 作用时产生异常</td></tr><tr><td>InstantiationException</td><td>1. Class.newInstance() 或者Constructor.newInstance()异常。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="反射" scheme="https://brokge.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="https://brokge.github.io/2019/02/10/Java-%E5%8F%8D%E5%B0%84/"/>
    <id>https://brokge.github.io/2019/02/10/Java-反射/</id>
    <published>2019-02-10T11:40:00.000Z</published>
    <updated>2019-10-09T02:43:23.686Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#%E5%8F%8D%E5%B0%84%E5%85%A5%E5%8F%A3">反射入口</a></li><li><a href="#%E8%8E%B7%E5%8F%96class-%E7%9A%84%E6%88%90%E5%91%98">获取Class 的成员</a><ul><li><a href="#field-%E7%9A%84%E6%93%8D%E4%BD%9C"><strong>Field 的操作</strong></a></li><li><a href="#method-%E6%93%8D%E4%BD%9C">Method 操作</a></li><li><a href="#constructor-%E7%9A%84%E6%93%8D%E4%BD%9C">Constructor 的操作</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84">反射中的数组</a></li><li><a href="#%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE-enum">反射中的枚举 enum</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p><a href="https://blog.csdn.net/briblue/article/details/74616922" target="_blank" rel="noopener">参考博客网址</a></p><h2><span id="反射入口">反射入口</span></h2><p><strong>Object.getClass()</strong></p><pre class="line-numbers language-java"><code class="language-java">Car car <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Class <span class="token class-name">clazz</span> <span class="token operator">=</span> car<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>.class</strong></p><pre class="line-numbers language-java"><code class="language-java">Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>Class <span class="token class-name">cls1</span> <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>Class <span class="token class-name">cls2</span> <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <strong>Class.forName() 方法</strong></p><pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">try</span> <span class="token punctuation">{</span>    Class <span class="token class-name">clz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.aa.test.Car"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>Class 的名字</strong></p><pre class="line-numbers language-java"><code class="language-java"> Class<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Class<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Class<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"> Class <span class="token class-name">clz</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outter<span class="token punctuation">.</span>Inner</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" Inner Class name:"</span><span class="token operator">+</span>clz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" Inner Class simple name:"</span><span class="token operator">+</span>clz<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" Inner Class canonical name:"</span><span class="token operator">+</span>clz<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//run 是匿名类</span>Runnable run <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" anonymous Class name:"</span><span class="token operator">+</span>run<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" anonymous Class simple name:"</span><span class="token operator">+</span>run<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" anonymous Class canonical name:"</span><span class="token operator">+</span>run<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// local 是局部类</span><span class="token keyword">class</span> <span class="token class-name">local</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local a name:"</span><span class="token operator">+</span>local<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local a simplename:"</span><span class="token operator">+</span>local<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local a canonicalname:"</span><span class="token operator">+</span>local<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//[[[ 代表三维数组</span>Inner Class <span class="token class-name">name</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Lcom<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Outter$Inner<span class="token punctuation">;</span>Inner Class <span class="token class-name">simple</span> name<span class="token operator">:</span>Inner<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Inner Class <span class="token class-name">canonical</span> name<span class="token operator">:</span>com<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Outter<span class="token punctuation">.</span>Inner<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//匿名类:</span>anonymous Class <span class="token class-name">name</span><span class="token operator">:</span>com<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Test$<span class="token number">1</span>anonymous Class <span class="token class-name">simple</span> name<span class="token operator">:</span>anonymous Class <span class="token class-name">canonical</span> name<span class="token operator">:</span>null<span class="token comment" spellcheck="true">//局部类</span>Local a name<span class="token operator">:</span>com<span class="token punctuation">.</span>frank<span class="token punctuation">.</span>test<span class="token punctuation">.</span>Test$1localLocal a simplename<span class="token operator">:</span>localLocal a canonicalname<span class="token operator">:</span>null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Canonical 是官方、标准的意思，那么 getCanonicalName() 自然就是返回一个 Class 对象的官方名字，这个官方名字 canonicalName 是 Java 语言规范制定的，如果 Class 对象没有 canonicalName 的话就返回 null。</p><p>getCanonicalName() 是 getName() 和 getSimpleName() 的结合。</p><ul><li>getCanonicalName() 返回的也是全限定类名，但是对于内部类，不用 $ 开头，而用 .。</li><li>getCanonicalName() 对于数组类型的 Class，同 simplename 一样直接在后面添加 [] 。</li><li>getCanonicalName() 不同于 simplename 的地方是，不存在 canonicalName 的时候返回 null 而不是空字符串。</li><li>局部类和匿名内部类不存在 canonicalName。</li></ul><p><strong>Class 获取修饰符</strong></p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"modifiers value:"</span><span class="token operator">+</span>TestModifier<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"modifiers :"</span><span class="token operator">+</span>Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>TestModifier<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-bash"><code class="language-bash">modifiers value:1025modifiers :public abstract<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>大家肯定会有疑问，为什么会返回一个整型数值呢？</p><p>这是因为一个类定义的时候可能会被多个修饰符修饰，为了一并获取，所以 Java 工程师考虑到了位运算，用一个 int 数值来记录所有的修饰符，然后不同的位对应不同的修饰符，这些修饰符对应的位都定义在 Modifier 这个类当中。<br>举例：</p><table><thead><tr><th>待比较</th><th>2进制</th></tr></thead><tbody><tr><td>public（0x00000001）</td><td>00000000001</td></tr><tr><td> 1025</td><td>10000000001</td></tr><tr><td>进行&amp;运算结果</td><td>00000000001 </td></tr></tbody></table><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPublic</span><span class="token punctuation">(</span><span class="token keyword">int</span> mod<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>mod <span class="token operator">&amp;</span> PUBLIC<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>得出结果  00000000001 不等于0 返回true ，类修饰符为 public</p><h2><span id="获取class-的成员">获取Class 的成员</span></h2><p>一个类的成员包括属性（有人翻译为字段或者域）、方法。对应到 Class 中就是 Field、Method、Constructor</p><p><strong>获取Field</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取的是 Class 中的属性，不能获取其父类的属性</span><span class="token keyword">public</span> Field <span class="token function">getDeclaredField</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span>                       <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span>                              SecurityException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取的是 public 属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取</span><span class="token keyword">public</span> Field <span class="token function">getField</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span>               <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span>                      SecurityException<span class="token comment" spellcheck="true">//获取所有的属性，但不包括从父类继承下来的属性</span><span class="token keyword">public</span> Field<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//获取自身的所有的 public 属性，包括从父类继承下来的。</span><span class="token keyword">public</span> Field<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>1.两者的区别就是 getDeclaredField() 获取的是 Class 中的属性,不能获取其父类的属性。 getField() 方法获取的是public属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取。</p><ol start="2"><li>getDeclaredFileds() 方法可以获取 private、protected、public 和 default 属性，但是它获取不到从父类继承下来的属性。getFields() 自身的所有的 public 属性，包括从父类继承下来的。</li></ol></blockquote><table><thead><tr><th>方法</th><th>本 Class</th><th>SupperClass</th></tr></thead><tbody><tr><td>getField</td><td>public</td><td>public</td></tr><tr><td>getDeclaredField</td><td>public、protected、default、private</td><td>x</td></tr><tr><td>getFields</td><td>public</td><td>public</td></tr><tr><td>getDeclaredFields</td><td>public、protected、default、private</td><td>x</td></tr></tbody></table><p><strong>获取 Method</strong></p><table><thead><tr><th>方法</th><th>本 Class</th><th>SupperClass</th></tr></thead><tbody><tr><td>getMethod</td><td>public</td><td>public</td></tr><tr><td>getDeclaredMethod</td><td>public、protected、default、private</td><td>x</td></tr><tr><td>getMethods</td><td>public</td><td>public</td></tr><tr><td>getDeclaredMethods</td><td>public、protected、default、private</td><td>x</td></tr></tbody></table><p>类或者接口中的方法对应到 Class 就是 Method。<br>相应的 API 如下，parameterTypes 是方法对应的参数，获取范围和Field类似。：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Method <span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException<span class="token keyword">public</span> Method <span class="token function">getMethod</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获取Contructor</strong><br>Java 反射把构造器从方法中单独拎出来了，用 Constructor 表示。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getConstructor</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> parameterTypes<span class="token punctuation">)</span><span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDeclaredConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span class="token keyword">public</span> Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getConstructors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SecurityException <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为，Constructor 不能从父类继承，所以就没有办法通过 getConstructor() 获取到父类的 Constructor。</p><h3><span id="field-的操作"><strong>Field 的操作</strong></span></h3><p>类中 定义的属性， 它们的类型要么是 8 种基础类型 int、long、float、double、boolean、char、byte 和 short。要么是引用，所有的引用都是 Object 的后代。<br><strong>Field 类型的获取</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Type <span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，两者返回的类型不一样，getGenericType() 方法能够获取到泛型类型，比如 <code>hashMap&lt;String,String&gt;</code>,比getType 更详细。<br><strong>Field 修饰符的获取</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个与前面 Class 获取修饰符一致。<br><strong>Field 内容的读取与赋值</strong><br>Field 这个类定义了一系列的 get 方法来获取不同类型的值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getLong</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getFloat</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">short</span> <span class="token function">getShort</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getDouble</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">getChar</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">getByte</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">getBoolean</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Field 又定义了一系列的 set 方法用来对其自身进行赋值。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setInt</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLong</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">long</span> value<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFloat</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">float</span> value<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setShort</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">short</span> value<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDouble</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">double</span> value<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setChar</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">char</span> value<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setByte</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">byte</span> b<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBoolean</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> IllegalAccessException<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可能有同学会对方法中出现的 Object 参数有疑问，它其实是类的实例引用，这里涉及一个细节。</p><blockquote><p><strong>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。</strong></p></blockquote><p>在执行 set 属性的时，如果操作 private 修饰的成员，需要加上 </p><pre class="line-numbers language-java"><code class="language-java">field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3><span id="method-操作">Method 操作</span></h3><p>Method 对应普通类的方法。<br>我们看看一般普通类的方法的构成。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>方法由下面几个要素构成：</p><ul><li>方法名</li><li>方法参数</li><li>方法返回值</li><li>方法的修饰符</li><li>方法可能会抛出的异常</li></ul><p><strong>Method 获取方法名</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeleclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Method 获取方法参数</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//返回的是一个 Parameter 数组</span><span class="token keyword">public</span> Parameter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取所有的参数类型</span><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取所有的参数类型，包括泛型</span><span class="token keyword">public</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回的是一个 Parameter 数组，在反射中 Parameter 对象就是用来映射方法中的参数。经常使用的<br>Parameter.java 类中的方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取参数名字</span><span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取参数类型</span><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取参数的修饰符</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Method 获取返回值类型</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取返回值类型</span><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 获取返回值类型包括泛型</span><span class="token keyword">public</span> Type <span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Method 获取修饰符</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Method 获取异常类型</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getExceptionTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> Type<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getGenericExceptionTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Method 方法的执行</strong> </p><p>这个应该是整个反射机制的核心内容了，很多时候运用反射目的其实就是为了以常规手段执行 Method。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Method 调用 invoke() 的时候，存在许多细节：</p><ul><li><p>invoke() 方法中第一个参数 Object 实质上是 Method 所依附的 Class 对应的类的实例，如果这个方法是一个<strong>静态方法</strong>，那么 ojb 为 null，后面的可变参数 Object 对应的自然就是参数。</p></li><li><p>invoke() 返回的对象是 Object，所以实际上执行的时候要进行强制转换。</p></li><li><p>在对 Method 调用 invoke() 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 InvocationTargetException。而通过 InvocationTargetException.getCause() 可以获取真正的异常。</p></li></ul><h3><span id="constructor-的操作">Constructor 的操作</span></h3><p>Constructor 同 Method 差不多，但是它特别的地方在于，它能够创建一个对象。</p><p>在 Java 反射机制中有两种方法可以用来创建类的对象实例：Class.newInstance() 和 Constructor.newInstance()。官方文档建议开发者使用后面这种方法，下面是原因。</p><ul><li>Class.newInstance() 只能调用无参的构造方法，而 Constructor.newInstance() 则可以调用任意的构造方法。</li><li>Class.newInstance() 通过构造方法直接抛出异常，而 Constructor.newInstance() 会把抛出来的异常包装到 InvocationTargetException 里面去，这个和 Method 行为一致。</li><li>Class.newInstance() 要求构造方法能够被访问，而 Constructor.newInstance() 却能够访问 private 修饰的构造器。</li></ul><h3><span id="反射中的数组">反射中的数组</span></h3><p>数组本质上是一个 Class，而在 Class 中存在一个方法用来识别它是否为一个数组。<br>在 Class.java 中 方法 <code>isArray()</code> 判断是否是数组<br>由于 数组本质上 还是 Class 所以可以通过 </p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取数组的里面的元素的类型，比如 int[] 数组的 componentType 自然就是 int</span><span class="token function">getComponentType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>动态创建数组*</strong><br>反射创建数组通过 Array.newInstance() 这个方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newInstance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> componentType<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> dimensions<span class="token punctuation">)</span>        <span class="token keyword">throws</span> IllegalArgumentException<span class="token punctuation">,</span> NegativeArraySizeException <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一个参数 为数组内原始类型，后面的是可变参数，表示的是相应维度的数组长度限制。<br>比如创建一个 二维数组 <code>Array.newInstance(int.class,2,3);</code></p><p><strong>Array 的读取与赋值</strong></p><ol><li>对Array 整体的赋值和读取<br><code>`</code>java<br>public void set(Object obj,<pre><code>         Object value)  throws IllegalArgumentException,         IllegalAccessException;</code></pre></li></ol><p>public Object get(Object obj)<br>           throws IllegalArgumentException,<br>                  IllegalAccessException;</p><pre><code>2. 对 Array 指定位置进行赋值和读取,经典的几种方式分别为：```javapublic static void set(Object array,                       int index,                       Object value)                throws IllegalArgumentException,                       ArrayIndexOutOfBoundsException;public static void setBoolean(Object array,                              int index,                              boolean z)                       throws IllegalArgumentException,                              ArrayIndexOutOfBoundsException;public static Object get(Object array,                         int index)                  throws IllegalArgumentException,                         ArrayIndexOutOfBoundsException;public static short getShort(Object array,                             int index)                      throws IllegalArgumentException,                             ArrayIndexOutOfBoundsException;</code></pre><h3><span id="反射中的枚举-enum">反射中的枚举 enum</span></h3><p>同数组一样本质上还是一个 Class 而已。</p><p>枚举的表现形式：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> State <span class="token punctuation">{</span>    IDLE<span class="token punctuation">,</span>    DRIVING<span class="token punctuation">,</span>    STOPPING<span class="token punctuation">,</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 java 反射 中，可以把枚举看成一般的Class,但是反射机制提供了3个特别的 API 用于操作枚举。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//判断是否是枚举类型</span>Class<span class="token punctuation">.</span><span class="token function">isEnum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//获取枚举所有的常量</span>Class<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断一个 Field 是不是枚举常量</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">.</span><span class="token function">isEnumConstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>枚举的获取与设置</strong><br>因为等同于 Class， 所以 枚举的获取与设置，可以 通过 Field 中的get() 和 set() 方法。</p><p>需要注意的是，如果要获取枚举里面的Field、Method、Constructor  可以调用 Class 的通用 API.</p><h3><span id="总结">总结</span></h3><ol><li>Java 中的反射是非常规编码方式。</li><li>Java 反射机制的操作入口是获取 Class 文件。 有 Class.forName()、 .class 和 Object.getClass() 3 种。</li><li>获取 Class 对象后还不够，需要获取它的 Members，包含 Field、Method、Constructor。</li><li>Field 操作主要涉及到类别的获取，及数值的读取与赋值。</li><li>Method 算是反射机制最核心的内容，通常的反射都是为了调用某个 Method 的 invoke() 方法。</li><li>通过 Class.newInstance() 和 Constructor.newInstance() 都可以创建类的对象实例，但推荐后者。因为它适应于任何构造方法，而前者只会调用可见的无参数的构造方法。</li><li>数组和枚举可以被看成普通的 Class 对待。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
      <category term="技术" scheme="https://brokge.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="https://brokge.github.io/tags/Java/"/>
    
      <category term="反射" scheme="https://brokge.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 使用说明</title>
    <link href="https://brokge.github.io/2019/01/08/hello-world/"/>
    <id>https://brokge.github.io/2019/01/08/hello-world/</id>
    <published>2019-01-08T03:02:23.000Z</published>
    <updated>2019-10-09T02:50:32.303Z</updated>
    
    <content type="html"><![CDATA[<!-- START doctoc generated TOC please keep comment here to allow auto update --><!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --><ul><li><a href="#date-2019-01-08-110223">date: 2019-01-08 11:02:23</a></li><li><a href="#quick-start">Quick Start</a><ul><li><a href="#create-a-new-post">Create a new post</a></li><li><a href="#run-server">Run server</a></li><li><a href="#generate-static-files">Generate static files</a></li><li><a href="#deploy-to-remote-sites">Deploy to remote sites</a></li></ul></li></ul><!-- END doctoc generated TOC please keep comment here to allow auto update --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;
&lt;!-- DON&#39;T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPD
      
    
    </summary>
    
    
  </entry>
  
</feed>
