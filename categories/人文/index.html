<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: 人文 - 玉蘇子</title><meta property="og:type" content="blog"><meta property="og:title" content="玉蘇子"><meta property="og:url" content="https://brokge.github.io/"><meta property="og:site_name" content="玉蘇子"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://brokge.github.io/img/og_image.png"><meta property="article:author" content="brokge"><meta property="article:tag" content="玉苏子"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://brokge.github.io"},"headline":"玉蘇子","image":["https://brokge.github.io/img/og_image.png"],"author":{"@type":"Person","name":"brokge"},"description":null}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="玉蘇子" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/scrapy">ScrapyDoc</a><a class="navbar-item" href="/tags">tag</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">人文</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-08T06:29:19.000Z" title="2020-01-08T06:29:19.000Z">2020-01-08</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">16 分钟 读完 (大约 2343 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/08/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">原型模式</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a><ul>
<li><a href="#1-%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">1. 通用实现方法：</a></li>
<li><a href="#2-java-%E8%AF%AD%E8%A8%80%E6%8F%90%E4%BE%9B%E7%9A%84-clone-%E6%96%B9%E6%B3%95">2. Java 语言提供的 clone 方法</a></li>
</ul>
</li>
<li><a href="#%E6%B5%85%E5%85%8B%E9%9A%86%E6%B7%B1%E5%85%8B%E9%9A%86">浅克隆、深克隆</a><ul>
<li><a href="#1-%E6%B5%85%E5%85%8B%E9%9A%86">1. 浅克隆</a></li>
<li><a href="#2-%E6%B7%B1%E5%85%8B%E9%9A%86">2. 深克隆</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结：</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->



<h2><span id="概念">概念</span></h2><p><strong>原型模式(Prototype  Pattern)：</strong> 使用原型实例指定创建对象的种类，并且通过克隆拷贝的方式利用原型实例创建新的对象。原型模式是一种对象创建型模式。</p>
<p>通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p>
<h2><span id="实现方式">实现方式</span></h2><h3><span id="1-通用实现方法">1. 通用实现方法：</span></h3><p>定义 Prototype 接口 和 clone() 方法。<br>原型对象继承其接口，实现clone 方法。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Prototype</span><span class="token punctuation">{</span>
   Prototype  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">implements</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span> String  attr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//成员属性</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAttr</span><span class="token punctuation">(</span>String attr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>

 <span class="token keyword">this</span><span class="token punctuation">.</span>attr <span class="token operator">=</span> attr<span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">public</span> String <span class="token function">getAttr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>attr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//克隆方法</span>
<span class="token keyword">public</span> Prototype <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">//创建新对象</span>
    Prototype prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    prototype<span class="token punctuation">.</span><span class="token function">setAttr</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> prototype<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用方通过下列方法，获得原型实例并得到克隆对象。 </p>
<pre class="line-numbers language-java"><code class="language-java">Prototype obj1  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span><span class="token function">setAttr</span><span class="token punctuation">(</span><span class="token string">"Sunny"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Prototype obj2  <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3><span id="2-java-语言提供的-clone-方法">2. Java 语言提供的 clone 方法</span></h3><p>Java类都继承自java.lang.Object。事实上，Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。我们可以直接利用Object类的clone()方法，具体步骤如下：</p>
<ol>
<li>在派生类中覆盖基类的clone()方法，并声明为public；</li>
<li>在派生类的clone()方法中，调用super.clone()；</li>
<li>派生类需实现Cloneable接口。</li>
</ol>
<p>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</p>
<p>需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">implements</span>  <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> Prototype  <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    　　Object object <span class="token operator">=</span> null<span class="token punctuation">;</span>
    　　<span class="token keyword">try</span> <span class="token punctuation">{</span>
    　　　　　object <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    　　<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    　　　　　System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Not support cloneable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    　　<span class="token punctuation">}</span>
    　　<span class="token keyword">return</span> <span class="token punctuation">(</span>Prototype <span class="token punctuation">)</span>object<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用方：</p>
<pre class="line-numbers language-java"><code class="language-java">Prototype obj1  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Prototype obj2  <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Java 语言中的clone()方法满足：</p>
<p>(1) 对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</p>
<p>(2) 对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</p>
<p>(3) 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p>
<h2><span id="浅克隆-深克隆">浅克隆、深克隆</span></h2><p>通过 Java 的clone 方式可以实现原型模式，但是通过深克隆实现还是浅克隆实现，所达到的结果是不一样的。因为在Java语言中，<strong>数据类型</strong>分为<strong>值类型</strong>（基本数据类型）和<strong>引用类型</strong>，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。</p>
<h3><span id="1-浅克隆">1. 浅克隆</span></h3><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p>
<p>简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
<p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/java%20%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86-%E6%B5%85.png" alt="浅克隆"></p>
<h3><span id="2-深克隆">2. 深克隆</span></h3><p>深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。</p>
<p>简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制</p>
<p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/java%20%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86.png" alt="深克隆"></p>
<ol>
<li>实现深克隆方法：序列化(Serialization)</li>
</ol>
<blockquote>
<p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">WeeklyLog</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Attachment attachment<span class="token punctuation">;</span>

    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String date<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String content<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAttachment</span><span class="token punctuation">(</span>Attachment attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>attachment  <span class="token operator">=</span> attachment<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDate</span><span class="token punctuation">(</span>String date<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> date<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContent</span><span class="token punctuation">(</span>String content<span class="token punctuation">)</span><span class="token punctuation">{</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> Attachment <span class="token function">getAttachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>attachment<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span><span class="token punctuation">(</span>String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

   <span class="token comment" spellcheck="true">//使用序列化技术实现深克隆</span>

    <span class="token keyword">public</span> WeeklyLog <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> OptionalDataException <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">//将对象写入流中</span>
        ByteArrayOutputStream bao<span class="token operator">=</span><span class="token keyword">new</span>  <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        ObjectOutputStream oos<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bao<span class="token punctuation">)</span><span class="token punctuation">;</span>

        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">//将对象从流中取出</span>
        ByteArrayInputStream bis<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bao<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ObjectInputStream ois<span class="token operator">=</span><span class="token keyword">new</span>  <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token punctuation">(</span>WeeklyLog<span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="总结">总结：</span></h2><ul>
<li>原型模式的主要优点如下：</li>
</ul>
<p>(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p>
<p>(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p>
<p>(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p>
<p>(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p>
<ul>
<li>原型模式的主要缺点如下：</li>
</ul>
<p>(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p>
<p>(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p>
<ul>
<li>在以下情况下可以考虑使用原型模式：</li>
</ul>
<p>(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</p>
<p>(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</p>
<p>(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-08T06:39:53.000Z" title="2019-12-08T06:39:53.000Z">2019-12-08</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">15 分钟 读完 (大约 2291 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

<ul>
<li><a href="#%E5%8D%95%E4%BE%8B">单例</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E7%89%B9%E7%82%B9">概念特点</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">实现方式</a><ul>
<li><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F">饿汉式</a></li>
<li><a href="#%E6%87%92%E6%B1%89%E5%BC%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%94%81%E5%AE%9A">懒汉式与线程锁定</a></li>
<li><a href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB%E4%B8%8E%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E7%B1%BB%E6%AF%94%E8%BE%83">饿汉式单例类与懒汉式单例类比较</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A5%E4%B8%8A%E6%80%BB%E7%BB%93">以上总结</a><ul>
<li><a href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">静态内部类</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->


<p>[toc]</p>
<h1><span id="单例">单例</span></h1><h2><span id="概念特点">概念特点</span></h2><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p>
<ul>
<li>三要点：</li>
</ul>
<ol>
<li>某个类只能有一个实例；</li>
<li>是它必须自行创建这个实例；</li>
<li>是它必须自行向整个系统提供这个实例。</li>
</ol>
<ul>
<li>实现过程：</li>
</ul>
<p>在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p>
<ul>
<li>单例模式唯一实例为什么是静态的？</li>
</ul>
<blockquote>
<p>因为程序调用类中方法只有两种方式</p>
<ol>
<li>创建类的一个对象，用该对象去调用类中方法；</li>
<li>使用类名直接调用类中方法，格式“类名.方法名()”； </li>
</ol>
<p>上面说了，构造函数私有化后第一种情况就不能用，只能使用第二种方法。 而使用类名直接调用类中方法，类中方法必须是静态的，而静态方法不能访问非静态成员变量，因此类自定义的实例变量也必须是静态的。 这就是单例模式唯一实例必须设置为静态的原因</p>
</blockquote>
<h2><span id="实现方式">实现方式</span></h2><h3><span id="饿汉式">饿汉式</span></h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//饿汉式</span>
<span class="token keyword">class</span> <span class="token class-name">EagerSingleton</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> EagerSingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EagerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">private</span> <span class="token function">EagerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> 

    <span class="token keyword">public</span> <span class="token keyword">static</span> EagerSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。如果使用饿汉式单例来实现负载均衡器LoadBalancer类的设计，则不会出现创建多个单例对象的情况，可确保单例对象的唯一性。</p>
<h3><span id="懒汉式与线程锁定">懒汉式与线程锁定</span></h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">static</span> LazySingleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span> 

    <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> 

    <span class="token keyword">synchronized</span> <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>懒汉式单例在第一次调用getInstance()方法时实例化，在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，为了避免多个线程同时调用getInstance()方法，我们可以使用关键字synchronized</p>
<p>在getInstance()方法前面增加了关键字synchronized进行线程锁，以处理多个线程同时访问的问题。但是，上述代码虽然解决了线程安全问题，但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。如何既解决线程安全问题又不影响系统性能呢？</p>
<p>我们继续对懒汉式单例进行改进。事实上，我们无须对整个getInstance()方法进行锁定，只需对其中的代码“instance = new LazySingleton();”进行锁定即可。因此getInstance()方法可以进行如下改进</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LazySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>问题貌似得以解决，事实并非如此。如果使用以上代码来实现单例，还是会存在<strong>单例对象不唯一</strong>。</p>
<p>原因如下：</p>
<blockquote>
<p>假如在某一瞬间线程A和线程B都在调用 getInstance() 方法，此时instance对象为null值，均能通过instance == null的判断。由于实现了synchronized加锁机制，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。但当A执行完毕时，线程B并不知道实例已经创建，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，这种方式称为**双重检查锁定(Double-Check Locking)**。使用双重检查锁定实现的懒汉式单例类完整代码如下所示：</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token keyword">class</span> <span class="token class-name">LazySingleton</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> LazySingleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span> 

    <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> 

    <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment" spellcheck="true">//第一重判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//锁定代码块</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LazySingleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//第二重判断</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建单例实例</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>需要注意的是</strong></p>
<blockquote>
<p>如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符<strong>volatile</strong>，被<strong>volatile</strong>修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。由于 volatile 关键字会屏蔽 Java 虚拟机所做的一些代码优化，可能会导致系统运行效率降低。因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p>
</blockquote>
<h3><span id="饿汉式单例类与懒汉式单例类比较">饿汉式单例类与懒汉式单例类比较</span></h3><p><strong>饿汉式单例类在类被加载时就将自己实例化，</strong></p>
<p>优点：</p>
<ol>
<li><p>无须考虑多线程访问问题，可以确保实例的唯一性；</p>
</li>
<li><p>从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。</li>
</ol>
<p><strong>懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载</strong></p>
<p>优点：</p>
<ol>
<li>无须一直占用系统资源，实现了延迟加载。</li>
</ol>
<p>缺点：</p>
<ol>
<li>但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。</li>
</ol>
<h2><span id="以上总结">以上总结</span></h2><p>饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；</p>
<p>懒汉式单例类线程安全控制烦琐，而且性能受影响。</p>
<p>可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题,有没有更好的方式？</p>
<h3><span id="静态内部类">静态内部类</span></h3><blockquote>
<p>Initialization Demand Holder (IoDH)</p>
</blockquote>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">HolderClass</span> <span class="token punctuation">{</span>
            <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> HolderClass<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Singleton s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span> 
            s1 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s2 <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p>
<p>通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-23T07:37:35.000Z" title="2019-09-23T07:37:35.000Z">2019-09-23</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">11 分钟 读完 (大约 1588 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">责任链模式</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%9B%BE">结构图</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a><ul>
<li><a href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%E5%A6%82%E4%B8%8B">职责链模式的主要优点如下：</a></li>
<li><a href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BC%BA%E7%82%B9%E5%A6%82%E4%B8%8B">职责链模式的主要缺点如下：</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->



<h2><span id="概念">概念</span></h2><p>职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。</p>
<h2><span id="结构图">结构图</span></h2><p>责任链模式实现方式，有两种：集合形式、链表形式</p>
<p><img src="https://raw.githubusercontent.com/brokge/drawio/master/img/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="责任链模式-2019-9-23-14-53-40.png"></p>
<p><strong>Handler（抽象处理者）：</strong>  它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的 nextHandler），作为其对下家的引用。通过该引用，处理者可以连成一条链。</p>
<p><strong>ConcreteHandler（具体处理者）：</strong><br>它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</p>
<h2><span id="示例代码">示例代码</span></h2><pre class="line-numbers language-java"><code class="language-java">
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//维持对下家的引用</span>
   <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>

   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler successor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler<span class="token operator">=</span>successor<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 具体处理者是抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>请求满足条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//处理请求</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>successor<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//转发请求</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">HandlerProcessor</span><span class="token punctuation">{</span>

    protect List<span class="token operator">&lt;</span>Handler<span class="token operator">></span> handlerList<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addHandler</span><span class="token punctuation">(</span>Handler handler<span class="token punctuation">)</span><span class="token punctuation">{</span>
        handlerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

        <span class="token keyword">for</span><span class="token punctuation">(</span>Handler handler<span class="token operator">:</span>handlerList<span class="token punctuation">)</span><span class="token punctuation">{</span>
            handler<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。 </p>
<p>链表形式执行：</p>
<pre class="line-numbers language-java"><code class="language-java">
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Handler a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    a<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    a<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>集合形式执行：</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    Handler a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">;</span>
    a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    HandlerProcessor handleProcessor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HandlerProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    handleProcessor<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

    handleProcessor<span class="token punctuation">.</span><span class="token function">processHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="小结">小结</span></h2><h3><span id="职责链模式的主要优点如下">职责链模式的主要优点如下：</span></h3><p>(1) 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。</p>
<p>(2) 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</p>
<p>(3) 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</p>
<p>(4) 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。</p>
<h3><span id="职责链模式的主要缺点如下">职责链模式的主要缺点如下：</span></h3><p>(1) 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。</p>
<p>(2) 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</p>
<p>(3) 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</p>
<h3><span id="适用场景">适用场景</span></h3><p>在以下情况下可以考虑使用职责链模式：</p>
<p>(1) 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</p>
<p>(2) 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</p>
<p>(3) 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-17T08:23:06.000Z" title="2019-09-17T08:23:06.000Z">2019-09-17</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">13 分钟 读完 (大约 1922 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/17/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B/">冰山模型</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><p><a href="#%E4%B8%80%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B">一、冰山模型</a></p>
</li>
<li><p><a href="#%E4%B8%80%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B">一、冰山模型</a></p>
<ul>
<li><a href="#%E7%9F%A5%E8%AF%86%E5%92%8C%E6%8A%80%E8%83%BD">知识和技能</a></li>
<li><a href="#%E8%83%BD%E5%8A%9B">能力</a></li>
<li><a href="#%E4%BB%B7%E5%80%BC%E8%A7%82%E6%80%A7%E6%A0%BC%E5%8A%A8%E6%9C%BA">价值观、性格、动机</a></li>
</ul>
</li>
<li><p><a href="#%E4%BA%8C%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B%E7%A1%AE%E5%AE%9A%E8%81%8C%E4%BD%8D">二、如何根据冰山模型确定职位</a></p>
</li>
<li><p><a href="#%E4%B8%89%E6%8A%95%E5%85%A5%E5%9B%A0%E7%B4%A0%E7%9A%84%E4%B8%8D%E5%90%8C">三、投入因素的不同</a></p>
</li>
<li><p><a href="#%E5%9B%9B%E5%A4%A9%E8%B5%8B%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%A1%A8%E7%8E%B0-sign">四、天赋的四个表现 SIGN</a></p>
</li>
<li><p><a href="#%E4%BA%94%E4%B8%89%E4%B8%AA%E7%9F%A5%E8%AF%86%E5%86%85%E5%8C%96%E6%88%90%E8%83%BD%E5%8A%9B%E7%9A%84%E6%96%B9%E6%B3%95">五、三个知识内化成能力的方法</a></p>
</li>
<li><p><a href="#%E5%85%AD%E4%B8%89%E5%A4%A7%E7%B3%BB%E7%BB%9F-%E8%AE%A9%E7%B3%BB%E7%BB%9F%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%8D%E4%BE%9D%E9%9D%A0%E6%84%8F%E5%BF%97%E5%8A%9B">六、三大系统 让系统化学习不依靠意志力</a></p>
</li>
<li><p><a href="#%E4%B8%83%E5%AD%A6%E4%B9%A0%E4%B8%8D%E9%9D%A0%E6%84%8F%E5%BF%97%E5%8A%9B%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%9B%A0%E7%B4%A0">七、学习不靠意志力三个关键因素</a></p>
</li>
<li><p><a href="#%E5%85%AB%E4%B8%89%E4%B8%AA%E5%BB%BA%E8%AE%AE%E8%AE%A9%E4%BD%A0%E4%B8%8D%E5%81%9A%E5%AE%9A%E5%88%B6%E5%8C%96%E4%BA%BA%E6%89%8D">八、三个建议让你不做「定制化人才」</a></p>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<p>[toc]</p>
<h2 id="一、冰山模型"><a href="#一、冰山模型" class="headerlink" title="一、冰山模型"></a>一、冰山模型</h2><p><img src="https://github.com/brokge/drawio/raw/master/net-scapture/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B.png" alt="冰山模型"></p>
<blockquote>
<p>动机可能就是天赋本身</p>
</blockquote>
<h3 id="知识和技能"><a href="#知识和技能" class="headerlink" title="知识和技能"></a>知识和技能</h3><p>………</p></div><a class="article-more button is-small size-small" href="/2019/09/17/%E5%86%B0%E5%B1%B1%E6%A8%A1%E5%9E%8B/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-06T08:23:55.000Z" title="2019-09-06T08:23:55.000Z">2019-09-06</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">7 分钟 读完 (大约 1088 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/06/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/">简单工厂</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82">简单工厂</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码：</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">简单工厂模式总结</a><ul>
<li><a href="#%E4%BC%98%E7%82%B9"><strong>优点</strong></a></li>
<li><a href="#%E7%BC%BA%E7%82%B9"><strong>缺点</strong></a></li>
</ul>
</li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><strong>适用场景</strong></a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->



<p>[toc]</p>
<h1><span id="简单工厂">简单工厂</span></h1><h2><span id="概念">概念</span></h2><p>定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<h2><span id="特点">特点</span></h2><p>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。<br>达到 <strong>创建和使用分离</strong>。</p>
<h2><span id="示例代码">示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象图表接口：抽象产品类</span>
<span class="token keyword">interface</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//柱状图类：具体产品类</span>
<span class="token keyword">class</span> <span class="token class-name">HistogramChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">HistogramChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//饼状图类：具体产品类</span>
<span class="token keyword">class</span> <span class="token class-name">PieChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">PieChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//折线图类：具体产品类</span>
<span class="token keyword">class</span> <span class="token class-name">LineChart</span> <span class="token keyword">implements</span> <span class="token class-name">Chart</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">LineChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//图表工厂类：工厂类</span>
<span class="token keyword">class</span> <span class="token class-name">ChartFactory</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//静态工厂方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Chart <span class="token function">getChart</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Chart chart <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"histogram"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HistogramChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置柱状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PieChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置饼状图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"line"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            chart <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LineChart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化设置折线图！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> chart<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="简单工厂模式总结">简单工厂模式总结</span></h2><p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开。</p>
<h3><span id="优点"><strong>优点</strong></span></h3><p> 简单工厂模式的主要优点如下：</p>
<blockquote>
<p>(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p>
<p>(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p>
<p>(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
</blockquote>
<h3><span id="缺点"><strong>缺点</strong></span></h3><p>简单工厂模式的主要缺点如下：</p>
<blockquote>
<p>(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p>
<p>(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p>
<p>(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p>
<p>(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p>
</blockquote>
<h2><span id="适用场景"><strong>适用场景</strong></span></h2><p>在以下情况下可以考虑使用简单工厂模式：</p>
<blockquote>
<p>(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p>
<p>(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-06T08:22:07.000Z" title="2019-09-06T08:22:07.000Z">2019-09-06</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">10 分钟 读完 (大约 1531 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/">工厂方法</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码：</a></li>
<li><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93">工厂方法模式总结</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h2><span id="背景">背景</span></h2><p>简单工厂模式实现了对象的创建和使用分离，但是仍然存在如下两个问题：</p>
<blockquote>
<p>(1) 工厂类过于庞大，包含了大量的if…else…代码，导致维护和测试难度增大；</p>
<p>(2) 系统扩展不灵活，当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”</p>
</blockquote>
<p>如何实现增加新产品而不影响已有代码？</p>
<h2><span id="概念">概念</span></h2><p>定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)</p>
<h2><span id="特点">特点</span></h2><p>不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。</p>
<h2><span id="示例代码">示例代码：</span></h2><pre class="line-numbers language-java"><code class="language-java">
<span class="token comment" spellcheck="true">//日志记录器接口：抽象产品</span>
<span class="token keyword">interface</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//数据库日志记录器：具体产品</span>
<span class="token keyword">class</span> <span class="token class-name">DatabaseLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据库日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//文件日志记录器：具体产品</span>
<span class="token keyword">class</span> <span class="token class-name">FileLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//日志记录器工厂接口：抽象工厂</span>
<span class="token keyword">interface</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//数据库日志记录器工厂类：具体工厂</span>
<span class="token keyword">class</span> <span class="token class-name">DatabaseLoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//连接数据库，代码省略</span>
            <span class="token comment" spellcheck="true">//创建数据库日志记录器对象</span>
            Logger logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DatabaseLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token comment" spellcheck="true">//初始化数据库日志记录器，代码省略</span>
            <span class="token keyword">return</span> logger<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//文件日志记录器工厂类：具体工厂</span>
<span class="token keyword">class</span> <span class="token class-name">FileLoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">LoggerFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Logger <span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//创建文件日志记录器对象</span>
            Logger logger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token comment" spellcheck="true">//创建文件，代码省略</span>
            <span class="token keyword">return</span> logger<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//调用</span>
<span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LoggerFactory factory<span class="token punctuation">;</span>
        Logger logger<span class="token punctuation">;</span>
        factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileLoggerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//可引入配置文件实现</span>
        logger <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2><span id="工厂方法模式总结">工厂方法模式总结</span></h2><p>工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API类库的核心模式。</p>
<ol>
<li>主要优点</li>
</ol>
<p>工厂方法模式的主要优点如下：</p>
<blockquote>
<p>(1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</p>
<p>(2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。</p>
<p>(3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</p>
</blockquote>
<ol start="2">
<li>主要缺点</li>
</ol>
<p>工厂方法模式的主要缺点如下：</p>
<blockquote>
<p>(1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<p>(2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
</blockquote>
<ol start="3">
<li>适用场景</li>
</ol>
<p>在以下情况下可以考虑使用工厂方法模式：</p>
<blockquote>
<p>(1) 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。</p>
<p>(2) 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-05T11:55:06.000Z" title="2019-09-05T11:55:06.000Z">2019-09-05</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">16 分钟 读完 (大约 2350 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">抽象工厂</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">抽象工厂</a><ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E5%92%8C%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C">和工厂方法的不同</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B">案例</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">抽象工厂 示例代码：</a></li>
<li><a href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-%E7%9A%84%E5%80%BE%E6%96%9C%E6%80%A7">开闭原则 的倾斜性</a></li>
<li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->



<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>产品类型</strong>：单个产品类型。</p>
<p><strong>产品族</strong>：包含多个产品类型。</p>
<p>抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，</p></div><a class="article-more button is-small size-small" href="/2019/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-09-05T09:15:15.000Z" title="2019-09-05T09:15:15.000Z">2019-09-05</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">10 分钟 读完 (大约 1463 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></h1><div class="content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">设计模式概述：</a><ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%92%E5%88%86">设计模式划分</a></li>
<li><a href="#%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99">七大原则</a></li>
</ul>
</li>
<li><a href="#23-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%92%E5%88%86">23 种设计模式划分</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%9E%8B">创建型</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%9E%8B">结构型</a></li>
<li><a href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">行为型模式</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->



<h2><span id="设计模式概述">设计模式概述：</span></h2><h3><span id="设计模式划分">设计模式划分</span></h3><p>设计模式可分为<strong>创建型</strong>(Creational)，<strong>结构型</strong>(Structural)和<strong>行为型</strong>(Behavioral)三种，其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责</p>
<h3><span id="七大原则">七大原则</span></h3><ol>
<li>单一职责<blockquote>
<p>职责单一，相对独立，不细说。</p>
</blockquote>
</li>
<li>开放封闭原则<blockquote>
<p>对扩展开放，修改封闭，这个也不细说了。</p>
</blockquote>
</li>
<li><strong>依赖倒转</strong><blockquote>
<p>抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程,依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。<strong>实现依赖倒转原则时</strong>，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入</p>
</blockquote>
</li>
<li><strong>里氏替换原则</strong><blockquote>
<p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。<br>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p>
</blockquote>
</li>
<li><strong>组合复用原则</strong><blockquote>
<p>尽量使用对象组合，而不是继承来达到复用的目的。<br>如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p>
</blockquote>
</li>
<li><strong>接口隔离原则</strong><blockquote>
<p>使用多个特定的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</p>
</blockquote>
</li>
</ol>
<p> <strong>接口隔离原则=使用单一职责原则的思想+考虑客户端具体的功能需求+适当切分定义接口文件+编程语言支持可实现多接口的语法特性</strong><br> 7. <strong>迪米特原则</strong></p>
<blockquote>
<p>一个软件实体应当尽可能少地与其他实体发生相互作用。<br>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过<strong>第三者</strong>转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 迪米特法则目的是降低系统的耦合度，使类与类之间保持松散的耦合关系</p>
</blockquote>
<p>在代码的重构中，很多时候以上原则是相铺相成互相结合。</p>
<p>开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。相互补充，目标一致，只是分析问题时所站角度不同而已。</p>
<h2><span id="23-种设计模式划分">23 种设计模式划分</span></h2><h3><span id="创建型">创建型</span></h3><ol>
<li><a href="https://blog.dxdoctor.com/2019/09/06/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/">简单工厂</a></li>
<li><a href="https://blog.dxdoctor.com/2019/09/06/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/">工厂方法</a></li>
<li><a href="https://blog.dxdoctor.com/2019/09/05/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">抽象工厂</a></li>
<li>单例模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ol>
<h3><span id="结构型">结构型</span></h3><ol>
<li>适配器模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>装饰模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ol>
<h3><span id="行为型模式">行为型模式</span></h3><ol>
<li><a href="https://blog.dxdoctor.com/2019/09/23/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">职责链模式</a></li>
<li>命令模式</li>
<li>解释器模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>模版方法模式</li>
<li>访问者模式</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-11-01T11:20:40.000Z" title="2018-11-01T11:20:40.000Z">2018-11-01</time><span class="level-item"><a class="link-muted" href="/categories/%E4%BA%BA%E6%96%87/">人文</a></span><span class="level-item">15 分钟 读完 (大约 2216 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/11/01/%E5%A4%A7%E5%AD%A6/">大学</a></h1><div class="content"><p>大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始，知所先后，则近道矣。古之欲明明德于天下者，先治其国；欲治其国者，先齐其家；欲齐其家者，先脩其身；欲脩其身者，先正其心；欲正其心者，先诚其意；欲诚其意者，先致其知，致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身脩，身脩而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，壹是皆以脩身为本。其本乱而末治者否矣，其所厚者薄，而其所薄者厚，未之有也！此谓知本，此谓知之至也。</p>
<p>所谓诚其意者，毋自欺也，如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也！小人闲居为不善，无所不至，见君子而后厌然，揜其不善，而著其善。人之视己，如见其肺肝然，则何益矣！此谓诚于中，形于外，故君子必慎其独也。曾子曰：「十目所视，十手所指，其严乎！」富润屋，德润身，心广体胖，故君子必诚其意。</p>
<p>《诗》云：「瞻彼淇澳，菉竹猗猗。有斐君子，如切如磋，如琢如磨。瑟兮僩兮，赫兮喧兮。有斐君子，终不可喧兮！」「如切如磋」者，道学也；「如琢如磨」者，自脩也；「瑟兮僩兮」者，恂慄也；「赫兮喧兮」者，威仪也；「有斐君子，终不可喧兮」者，道盛德至善，民之不能忘也。《诗》云：「於戏，前王不忘！」君子贤其贤而亲其亲，小人乐其乐而利其利，此以没世不忘也。</p>
<p>《康诰》曰：「克明德。」《太甲》曰：「顾諟天之明命。」《帝典》曰：「克明峻德。」皆自明也。</p>
<p>汤之《盘铭》曰：「茍日新，日日新，又日新。」《康诰》曰：「作新民。」《诗》曰：「周虽旧邦，其命维新。」是故君子无所不用其极。<br>《诗》云：「邦畿千里，维民所止。」《诗》云：「缗蛮黄鸟，止于丘隅。」子曰：「於止，知其所止，可以人而不如鸟乎？」《诗》云：「穆穆文王，於缉熙敬止！」为人君，止于仁；为人臣止于敬；为人子，止于孝；为人父，止于慈；与国人交，止于信。</p>
<p>子曰：「听讼，吾犹人也，必也使无讼乎！」无情者不得尽其辞，大畏民志。此谓知本。</p>
<p>所谓脩身在正其心者，身有所忿懥，则不得其正；有所恐惧，则不得其正；有所好乐，则不得其正；有所忧患，则不得其正。心不在焉，视而不见，听而不闻，食而不知其味。此谓脩身在正其心。</p>
<p>所谓齐其家在脩其身者，人之其所亲爱而辟焉，之其所贱恶而辟焉，之其所畏敬而辟焉，之其所哀矜而辟焉，之其所敖惰而辟焉。故好而知其恶，恶而知其美者，天下鲜矣！故谚有之曰：「人莫知其子之恶，莫知其苗之硕。」此谓身不脩，不可以齐其家。</p>
<p>所谓治国必先齐其家者，其家不可教而能教人者，无之。故君子不出家而成教于国：孝者，所以事君也；弟者，所以事长也；慈者，所以使众也。《康诰》曰：「如保赤子」，心诚求之，虽不中，不远矣。未有学养子而后嫁者也！一家仁，一国兴仁；一家让，一国兴让；一人贪戾，一国作乱。其机如此。此谓一言偾事，一人定国。尧、舜率天下以仁，而民从之；桀、纣率天下以暴，而民从之。其所令反其所好，而民不从。是故君子有诸己而后求诸人，无诸己而后非诸人。所藏乎身不恕，而能喻诸人者，未之有也。故治国在齐其家。《诗》云：「桃之夭夭，其叶蓁蓁；之子于归，宜其家人。」宜其家人，而后可以教国人。《诗》云：「宜兄宜弟。」宜兄宜弟，而后可以教国人。《诗》云：「其仪不忒，正是四国。」其为父子兄弟足法，而后民法之也。此谓治国在齐其家。</p>
<p>所谓平天下在治其国者，上老老而民兴孝，上长长而民兴弟，上恤孤而民不倍，是以君子有絜矩之道也。所恶于上，毋以使下；所恶于下，毋以事上；所恶于前，毋以先后；所恶于后，毋以从前；所恶于右，毋以交于左；所恶于左，毋以交于右。此之谓絜矩之道。</p>
<p>《诗》云：「乐只君子，民之父母。」民之所好好之，民之所恶恶之，此之谓民之父母。《诗》云：「节彼南山，维石岩岩。赫赫师尹，民具尔瞻。」有国者不可以不慎，辟，则为天下戮矣。《诗》云：「殷之未丧师，克配上帝。仪监于殷，峻命不易。」道得众则得国，失众则失国。是故君子先慎乎德。有德此有人，有人此有土，有土此有财，有财此有用。德者本也，财者末也。外本内末，争民施夺。是故财聚则民散，财散则民聚。是故言悖而出者，亦悖而入；货悖而入者，亦悖而出。《康诰》曰：「惟命不于常！」道善则得之，不善则失之矣。《楚书》曰：「楚国无以为宝，惟善以为宝。」舅犯曰：「亡人无以为宝，仁亲以为宝。」《秦誓》曰：「若有一介臣，断断兮无他技，其心休休焉，其如有容焉。人之有技，若己有之；人之彦圣，其心好之，不啻若自其口出。实能容之，以能保我子孙黎民，尚亦有利哉！人之有技，媢嫉以恶之；人之彦圣，而违之俾不通。实不能容，以不能保我子孙黎民，亦曰殆哉！」唯仁人放流之，迸诸四夷，不与同中国，此谓唯仁人为能爱人，能恶人。见贤而不能举，举而不能先，命也；见不善而不能退，退而不能远，过也。</p>
<p>好人之所恶，恶人之所好，是谓拂人之性，菑必逮夫身。是故君子有大道，必忠信以得之，骄泰以失之。</p>
<p>生财有大道，生之者众，食之者寡，为之者疾，用之者舒，则财恒足矣。仁者以财发身，不仁者以身发财。未有上好仁而下不好义者也，未有好义其事不终者也，未有府库财非其财者也。</p>
<p>孟献子曰：「畜马乘，不察于鸡豚；伐冰之家，不畜牛羊；百乘之家，不畜聚敛之臣。与其有聚敛之臣，宁有盗臣。」此谓国不以利为利，以义为利也。长国家而务财用者，必自小人矣。彼为善之，小人之使为国家，菑害并至。虽有善者，亦无如之何矣！此谓国不以利为利，以义为利也。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Brokge"></figure><p class="title is-size-4 is-block line-height-inherit">Brokge</p><p class="is-size-6 is-block">玉苏子</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>日常搬砖</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">19</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/brokge" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/brokge"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/%E4%BA%BA%E6%96%87/"><span class="level-start"><span class="level-item">人文</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">技术</span></span><span class="level-end"><span class="level-item tag">21</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%80%E6%9C%AF/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%9F%A5%E8%AF%86%E5%BA%93/"><span class="level-start"><span class="level-item">知识库</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-06T09:35:01.000Z">2020-06-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/06/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A2%B3%E7%90%86/">网络协议梳理</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-05T13:08:38.000Z">2020-06-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BA%BF%E7%A8%8B%E4%B8%AA%E6%95%B0/">多线程编程如何确定线程个数</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-02T08:28:45.000Z">2020-06-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/02/Dubbo%E8%AF%A6%E8%A7%A3/">Dubbo详解</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-11T12:04:17.000Z">2020-02-11</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/11/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/">Redis核心原理详解</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-10T04:50:24.000Z">2020-02-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/10/redis5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">Redis5 集群搭建</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%98%E5%8C%96/"><span class="tag">优化</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%B0%84/"><span class="tag">反射</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><span class="tag">微服务</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%9E%8B/"><span class="tag">思维模型</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99/"><span class="tag">正则</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B3%A8%E8%A7%A3/"><span class="tag">注解</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E7%A8%8B/"><span class="tag">线程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">7</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="玉蘇子" height="28"></a><p class="size-small"><span>&copy; 2020 brokge</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://brokge.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>